//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

use yellowstone_vixen_core::constants::is_known_aggregator;
#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated_sdk::types::{TokenBoughtEvent, TokenSoldEvent},
    instructions::{
        AddOperators as AddOperatorsIxAccounts, AddOperatorsInstructionArgs as AddOperatorsIxData,
        BuyToken as BuyTokenIxAccounts, BuyTokenInstructionArgs as BuyTokenIxData,
        CancelAuthorityTransfer as CancelAuthorityTransferIxAccounts,
        CloseBondingCurveVault as CloseBondingCurveVaultIxAccounts,
        CollectTradingFees as CollectTradingFeesIxAccounts,
        CompleteAuthorityTransfer as CompleteAuthorityTransferIxAccounts,
        CreateRaydiumPool as CreateRaydiumPoolIxAccounts,
        CreateRaydiumRandomPool as CreateRaydiumRandomPoolIxAccounts,
        CreateToken as CreateTokenIxAccounts, CreateTokenFallback as CreateTokenFallbackIxAccounts,
        CreateTokenFallbackInstructionArgs as CreateTokenFallbackIxData,
        CreateTokenInstructionArgs as CreateTokenIxData,
        DeployBondingCurve as DeployBondingCurveIxAccounts,
        DeployBondingCurveFallback as DeployBondingCurveFallbackIxAccounts,
        DeployBondingCurveFallbackInstructionArgs as DeployBondingCurveFallbackIxData,
        DeployBondingCurveInstructionArgs as DeployBondingCurveIxData,
        DepositIntoRaydium as DepositIntoRaydiumIxAccounts,
        DepositIntoRaydiumInstructionArgs as DepositIntoRaydiumIxData,
        Graduate as GraduateIxAccounts, Initialize as InitializeIxAccounts,
        InitializeInstructionArgs as InitializeIxData,
        InitiateAuthorityTransfer as InitiateAuthorityTransferIxAccounts,
        InitiateAuthorityTransferInstructionArgs as InitiateAuthorityTransferIxData,
        LockRaydiumLiquidity as LockRaydiumLiquidityIxAccounts,
        RemoveOperators as RemoveOperatorsIxAccounts,
        RemoveOperatorsInstructionArgs as RemoveOperatorsIxData, SellToken as SellTokenIxAccounts,
        SellTokenInstructionArgs as SellTokenIxData,
        SplitTradingFees as SplitTradingFeesIxAccounts,
        SwapSolForTokensOnRaydium as SwapSolForTokensOnRaydiumIxAccounts,
        SwapSolForTokensOnRaydiumInstructionArgs as SwapSolForTokensOnRaydiumIxData,
        SwapTokensForSolOnRaydium as SwapTokensForSolOnRaydiumIxAccounts,
        SwapTokensForSolOnRaydiumInstructionArgs as SwapTokensForSolOnRaydiumIxData,
        TogglePaused as TogglePausedIxAccounts, UpdateConfig as UpdateConfigIxAccounts,
        UpdateConfigInstructionArgs as UpdateConfigIxData,
    },
    ID,
};

/// Boop Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum BoopProgramIx {
    AddOperators(AddOperatorsIxAccounts, AddOperatorsIxData),
    BuyToken(BuyTokenIxAccounts, BuyTokenIxData, Option<TokenBoughtEvent>),
    CancelAuthorityTransfer(CancelAuthorityTransferIxAccounts),
    CloseBondingCurveVault(CloseBondingCurveVaultIxAccounts),
    CollectTradingFees(CollectTradingFeesIxAccounts),
    CompleteAuthorityTransfer(CompleteAuthorityTransferIxAccounts),
    CreateRaydiumPool(CreateRaydiumPoolIxAccounts),
    CreateRaydiumRandomPool(CreateRaydiumRandomPoolIxAccounts),
    CreateToken(CreateTokenIxAccounts, CreateTokenIxData),
    CreateTokenFallback(CreateTokenFallbackIxAccounts, CreateTokenFallbackIxData),
    DeployBondingCurve(DeployBondingCurveIxAccounts, DeployBondingCurveIxData),
    DeployBondingCurveFallback(
        DeployBondingCurveFallbackIxAccounts,
        DeployBondingCurveFallbackIxData,
    ),
    DepositIntoRaydium(DepositIntoRaydiumIxAccounts, DepositIntoRaydiumIxData),
    Graduate(GraduateIxAccounts),
    Initialize(InitializeIxAccounts, InitializeIxData),
    InitiateAuthorityTransfer(
        InitiateAuthorityTransferIxAccounts,
        InitiateAuthorityTransferIxData,
    ),
    LockRaydiumLiquidity(LockRaydiumLiquidityIxAccounts),
    RemoveOperators(RemoveOperatorsIxAccounts, RemoveOperatorsIxData),
    SellToken(SellTokenIxAccounts, SellTokenIxData, Option<TokenSoldEvent>),
    SplitTradingFees(SplitTradingFeesIxAccounts),
    SwapSolForTokensOnRaydium(
        SwapSolForTokensOnRaydiumIxAccounts,
        SwapSolForTokensOnRaydiumIxData,
    ),
    SwapTokensForSolOnRaydium(
        SwapTokensForSolOnRaydiumIxAccounts,
        SwapTokensForSolOnRaydiumIxData,
    ),
    TogglePaused(TogglePausedIxAccounts),
    UpdateConfig(UpdateConfigIxAccounts, UpdateConfigIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = BoopProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<BoopProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> { "Boop::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;
        if ix.data.len() < 8 {
            return Err(yellowstone_vixen_core::ParseError::from(
                "Instruction data too short".to_owned(),
            ));
        }

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [165, 199, 62, 214, 81, 54, 4, 150] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddOperatorsIxAccounts {
                    config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: AddOperatorsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::AddOperators(ix_accounts, de_ix_data))
            },
            [138, 127, 14, 91, 38, 87, 115, 105] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = BuyTokenIxAccounts {
                    mint: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    trading_fees_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_sol_vault: next_account(accounts)?,
                    recipient_token_account: next_account(accounts)?,
                    buyer: next_account(accounts)?,
                    config: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    wsol: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                };
                let de_ix_data: BuyTokenIxData = yellowstone_vixen_core::deserialize_checked_swap(ix_data, &ix_discriminator, "BuyToken", deserialize_checked)?;

                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }

                let token_bought_event = TokenBoughtEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(BoopProgramIx::BuyToken(
                    ix_accounts,
                    de_ix_data,
                    token_bought_event,
                ))
            },
            [94, 131, 125, 184, 183, 24, 125, 229] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CancelAuthorityTransferIxAccounts {
                    authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CancelAuthorityTransfer(ix_accounts))
            },
            [189, 71, 189, 239, 113, 66, 59, 189] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseBondingCurveVaultIxAccounts {
                    config: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    recipient_token_account: next_account(accounts)?,
                    recipient: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CloseBondingCurveVault(ix_accounts))
            },
            [189, 38, 205, 234, 81, 77, 25, 1] => {
                let expected_accounts_len = 24;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectTradingFeesIxAccounts {
                    operator: next_account(accounts)?,
                    protocol_fee_recipient: next_account(accounts)?,
                    config: next_account(accounts)?,
                    lock_program: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    fee_nft_account: next_account(accounts)?,
                    locked_liquidity: next_account(accounts)?,
                    cpmm_program: next_account(accounts)?,
                    cp_authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    recipient_token0_account: next_account(accounts)?,
                    recipient_token1_account: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    locked_lp_vault: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CollectTradingFees(ix_accounts))
            },
            [81, 233, 91, 132, 175, 31, 151, 141] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CompleteAuthorityTransferIxAccounts {
                    pending_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CompleteAuthorityTransfer(ix_accounts))
            },
            [65, 45, 119, 77, 204, 178, 84, 2] => {
                let expected_accounts_len = 22;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateRaydiumPoolIxAccounts {
                    cpmm_program: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token0_mint: next_account(accounts)?,
                    token1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_vault: next_account(accounts)?,
                    creator_lp_token: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    create_pool_fee: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    config: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CreateRaydiumPool(ix_accounts))
            },
            [78, 44, 173, 29, 132, 180, 4, 172] => {
                let expected_accounts_len = 22;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateRaydiumRandomPoolIxAccounts {
                    cpmm_program: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token0_mint: next_account(accounts)?,
                    token1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_vault: next_account(accounts)?,
                    creator_lp_token: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    create_pool_fee: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    config: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                Ok(BoopProgramIx::CreateRaydiumRandomPool(ix_accounts))
            },
            [84, 52, 204, 228, 24, 140, 234, 75] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenIxAccounts {
                    config: next_account(accounts)?,
                    metadata: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_metadata_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::CreateToken(ix_accounts, de_ix_data))
            },
            [253, 184, 126, 199, 235, 232, 172, 162] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenFallbackIxAccounts {
                    config: next_account(accounts)?,
                    metadata: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_metadata_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenFallbackIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::CreateTokenFallback(ix_accounts, de_ix_data))
            },
            [180, 89, 199, 76, 168, 236, 217, 138] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DeployBondingCurveIxAccounts {
                    mint: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_sol_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    config: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                };
                let de_ix_data: DeployBondingCurveIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::DeployBondingCurve(ix_accounts, de_ix_data))
            },
            [53, 230, 172, 84, 77, 174, 22, 61] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DeployBondingCurveFallbackIxAccounts {
                    mint: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_sol_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    config: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                };
                let de_ix_data: DeployBondingCurveFallbackIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::DeployBondingCurveFallback(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [168, 89, 99, 30, 117, 49, 88, 224] => {
                let expected_accounts_len = 21;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DepositIntoRaydiumIxAccounts {
                    config: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    operator_wsol_account: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_vault: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    cpmm_program: next_account(accounts)?,
                    owner_lp_token: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    token0_mint: next_account(accounts)?,
                    token1_mint: next_account(accounts)?,
                };
                let de_ix_data: DepositIntoRaydiumIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::DepositIntoRaydium(ix_accounts, de_ix_data))
            },
            [45, 235, 225, 181, 17, 218, 64, 130] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GraduateIxAccounts {
                    mint: next_account(accounts)?,
                    wsol: next_account(accounts)?,
                    protocol_fee_recipient: next_account(accounts)?,
                    token_distributor: next_account(accounts)?,
                    token_distributor_token_account: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve_sol_vault: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_account: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::Graduate(ix_accounts))
            },
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeIxAccounts {
                    config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializeIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::Initialize(ix_accounts, de_ix_data))
            },
            [210, 43, 101, 215, 119, 140, 106, 218] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitiateAuthorityTransferIxAccounts {
                    authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitiateAuthorityTransferIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::InitiateAuthorityTransfer(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [173, 255, 148, 6, 122, 99, 140, 22] => {
                let expected_accounts_len = 22;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = LockRaydiumLiquidityIxAccounts {
                    lock_program: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    fee_nft_owner: next_account(accounts)?,
                    fee_nft_mint: next_account(accounts)?,
                    fee_nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    locked_liquidity: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    liquidity_owner_lp: next_account(accounts)?,
                    locked_lp_vault: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    config: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    metadata_account: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::LockRaydiumLiquidity(ix_accounts))
            },
            [42, 20, 89, 83, 222, 37, 4, 109] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveOperatorsIxAccounts {
                    config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: RemoveOperatorsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::RemoveOperators(ix_accounts, de_ix_data))
            },
            [109, 61, 40, 187, 230, 176, 135, 174] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SellTokenIxAccounts {
                    mint: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    trading_fees_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_sol_vault: next_account(accounts)?,
                    seller_token_account: next_account(accounts)?,
                    seller: next_account(accounts)?,
                    recipient: next_account(accounts)?,
                    config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                };
                let de_ix_data: SellTokenIxData = yellowstone_vixen_core::deserialize_checked_swap(ix_data, &ix_discriminator, "SellToken", deserialize_checked)?;

                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }

                let token_sold_event = TokenSoldEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(BoopProgramIx::SellToken(
                    ix_accounts,
                    de_ix_data,
                    token_sold_event,
                ))
            },
            [96, 126, 225, 47, 185, 213, 50, 58] => {
                let expected_accounts_len = 24;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SplitTradingFeesIxAccounts {
                    operator: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    wsol: next_account(accounts)?,
                    config: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    trading_fees_vault: next_account(accounts)?,
                    fee_splitter_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    fee_splitter_config: next_account(accounts)?,
                    fee_splitter_creator_vault: next_account(accounts)?,
                    fee_splitter_vault_authority: next_account(accounts)?,
                    fee_splitter_creator_vault_authority: next_account(accounts)?,
                    fee_splitter_staking_mint: next_account(accounts)?,
                    fee_splitter_wsol_vault: next_account(accounts)?,
                    fee_splitter_creator_vault_authority_wsol_vault: next_account(accounts)?,
                    fee_splitter_treasury_wsol_vault: next_account(accounts)?,
                    fee_splitter_team_wsol_vault: next_account(accounts)?,
                    fee_splitter_reward_pool: next_account(accounts)?,
                    fee_splitter_reward_pool_staking_vault: next_account(accounts)?,
                    fee_splitter_reward_pool_reward_vault: next_account(accounts)?,
                    fee_splitter_reward_pool_program: next_account(accounts)?,
                };
                Ok(BoopProgramIx::SplitTradingFees(ix_accounts))
            },
            [107, 248, 131, 239, 152, 234, 54, 35] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapSolForTokensOnRaydiumIxAccounts {
                    config: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_vault: next_account(accounts)?,
                    output_token_mint: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    cp_swap_program: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                };
                let de_ix_data: SwapSolForTokensOnRaydiumIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::SwapSolForTokensOnRaydium(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [216, 172, 130, 148, 34, 98, 215, 163] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapTokensForSolOnRaydiumIxAccounts {
                    config: next_account(accounts)?,
                    bonding_curve: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    vault_authority: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    bonding_curve_vault: next_account(accounts)?,
                    bonding_curve_wsol_vault: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    output_token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    cp_swap_program: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                };
                let de_ix_data: SwapTokensForSolOnRaydiumIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::SwapTokensForSolOnRaydium(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [54, 83, 147, 198, 123, 97, 218, 72] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TogglePausedIxAccounts {
                    authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                };
                Ok(BoopProgramIx::TogglePaused(ix_accounts))
            },
            [29, 158, 252, 191, 10, 83, 219, 99] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateConfigIxAccounts {
                    config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: UpdateConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(BoopProgramIx::UpdateConfig(ix_accounts, de_ix_data))
            },
            // self cpi log
            [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d] => {
                Err(yellowstone_vixen_core::ParseError::Filtered)
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AddOperatorsIxAccounts, BoopProgramIx, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::AddOperatorsIxAccounts> for AddOperatorsIxAccounts {
        fn into_proto(self) -> proto_def::AddOperatorsIxAccounts {
            proto_def::AddOperatorsIxAccounts {
                config: self.config.to_string(),
                authority: self.authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::AddOperatorsIxData;
    impl IntoProto<proto_def::AddOperatorsIxData> for AddOperatorsIxData {
        fn into_proto(self) -> proto_def::AddOperatorsIxData {
            proto_def::AddOperatorsIxData {
                operators: self.operators.into_iter().map(|x| x.to_string()).collect(),
            }
        }
    }
    use super::BuyTokenIxAccounts;
    impl IntoProto<proto_def::BuyTokenIxAccounts> for BuyTokenIxAccounts {
        fn into_proto(self) -> proto_def::BuyTokenIxAccounts {
            proto_def::BuyTokenIxAccounts {
                mint: self.mint.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                trading_fees_vault: self.trading_fees_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_sol_vault: self.bonding_curve_sol_vault.to_string(),
                recipient_token_account: self.recipient_token_account.to_string(),
                buyer: self.buyer.to_string(),
                config: self.config.to_string(),
                vault_authority: self.vault_authority.to_string(),
                wsol: self.wsol.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::BuyTokenIxData;
    impl IntoProto<proto_def::BuyTokenIxData> for BuyTokenIxData {
        fn into_proto(self) -> proto_def::BuyTokenIxData {
            proto_def::BuyTokenIxData {
                buy_amount: self.buy_amount,
                amount_out_min: self.amount_out_min,
            }
        }
    }
    use super::CancelAuthorityTransferIxAccounts;
    impl IntoProto<proto_def::CancelAuthorityTransferIxAccounts> for CancelAuthorityTransferIxAccounts {
        fn into_proto(self) -> proto_def::CancelAuthorityTransferIxAccounts {
            proto_def::CancelAuthorityTransferIxAccounts {
                authority: self.authority.to_string(),
                config: self.config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CloseBondingCurveVaultIxAccounts;
    impl IntoProto<proto_def::CloseBondingCurveVaultIxAccounts> for CloseBondingCurveVaultIxAccounts {
        fn into_proto(self) -> proto_def::CloseBondingCurveVaultIxAccounts {
            proto_def::CloseBondingCurveVaultIxAccounts {
                config: self.config.to_string(),
                operator: self.operator.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                mint: self.mint.to_string(),
                recipient_token_account: self.recipient_token_account.to_string(),
                recipient: self.recipient.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::CollectTradingFeesIxAccounts;
    impl IntoProto<proto_def::CollectTradingFeesIxAccounts> for CollectTradingFeesIxAccounts {
        fn into_proto(self) -> proto_def::CollectTradingFeesIxAccounts {
            proto_def::CollectTradingFeesIxAccounts {
                operator: self.operator.to_string(),
                protocol_fee_recipient: self.protocol_fee_recipient.to_string(),
                config: self.config.to_string(),
                lock_program: self.lock_program.to_string(),
                vault_authority: self.vault_authority.to_string(),
                authority: self.authority.to_string(),
                fee_nft_account: self.fee_nft_account.to_string(),
                locked_liquidity: self.locked_liquidity.to_string(),
                cpmm_program: self.cpmm_program.to_string(),
                cp_authority: self.cp_authority.to_string(),
                pool_state: self.pool_state.to_string(),
                lp_mint: self.lp_mint.to_string(),
                recipient_token0_account: self.recipient_token0_account.to_string(),
                recipient_token1_account: self.recipient_token1_account.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                locked_lp_vault: self.locked_lp_vault.to_string(),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::CompleteAuthorityTransferIxAccounts;
    impl IntoProto<proto_def::CompleteAuthorityTransferIxAccounts>
        for CompleteAuthorityTransferIxAccounts
    {
        fn into_proto(self) -> proto_def::CompleteAuthorityTransferIxAccounts {
            proto_def::CompleteAuthorityTransferIxAccounts {
                pending_authority: self.pending_authority.to_string(),
                config: self.config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateRaydiumPoolIxAccounts;
    impl IntoProto<proto_def::CreateRaydiumPoolIxAccounts> for CreateRaydiumPoolIxAccounts {
        fn into_proto(self) -> proto_def::CreateRaydiumPoolIxAccounts {
            proto_def::CreateRaydiumPoolIxAccounts {
                cpmm_program: self.cpmm_program.to_string(),
                amm_config: self.amm_config.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_vault: self.bonding_curve_wsol_vault.to_string(),
                creator_lp_token: self.creator_lp_token.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                create_pool_fee: self.create_pool_fee.to_string(),
                observation_state: self.observation_state.to_string(),
                operator: self.operator.to_string(),
                config: self.config.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::CreateRaydiumRandomPoolIxAccounts;
    impl IntoProto<proto_def::CreateRaydiumRandomPoolIxAccounts> for CreateRaydiumRandomPoolIxAccounts {
        fn into_proto(self) -> proto_def::CreateRaydiumRandomPoolIxAccounts {
            proto_def::CreateRaydiumRandomPoolIxAccounts {
                cpmm_program: self.cpmm_program.to_string(),
                amm_config: self.amm_config.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_vault: self.bonding_curve_wsol_vault.to_string(),
                creator_lp_token: self.creator_lp_token.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                create_pool_fee: self.create_pool_fee.to_string(),
                observation_state: self.observation_state.to_string(),
                operator: self.operator.to_string(),
                config: self.config.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::CreateTokenIxAccounts;
    impl IntoProto<proto_def::CreateTokenIxAccounts> for CreateTokenIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenIxAccounts {
            proto_def::CreateTokenIxAccounts {
                config: self.config.to_string(),
                metadata: self.metadata.to_string(),
                mint: self.mint.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                token_metadata_program: self.token_metadata_program.to_string(),
            }
        }
    }
    use super::CreateTokenIxData;
    impl IntoProto<proto_def::CreateTokenIxData> for CreateTokenIxData {
        fn into_proto(self) -> proto_def::CreateTokenIxData {
            proto_def::CreateTokenIxData {
                salt: self.salt,
                name: self.name,
                symbol: self.symbol,
                uri: self.uri,
            }
        }
    }
    use super::CreateTokenFallbackIxAccounts;
    impl IntoProto<proto_def::CreateTokenFallbackIxAccounts> for CreateTokenFallbackIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenFallbackIxAccounts {
            proto_def::CreateTokenFallbackIxAccounts {
                config: self.config.to_string(),
                metadata: self.metadata.to_string(),
                mint: self.mint.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                token_metadata_program: self.token_metadata_program.to_string(),
            }
        }
    }
    use super::CreateTokenFallbackIxData;
    impl IntoProto<proto_def::CreateTokenFallbackIxData> for CreateTokenFallbackIxData {
        fn into_proto(self) -> proto_def::CreateTokenFallbackIxData {
            proto_def::CreateTokenFallbackIxData {
                salt: self.salt,
                name: self.name,
                symbol: self.symbol,
                uri: self.uri,
            }
        }
    }
    use super::DeployBondingCurveIxAccounts;
    impl IntoProto<proto_def::DeployBondingCurveIxAccounts> for DeployBondingCurveIxAccounts {
        fn into_proto(self) -> proto_def::DeployBondingCurveIxAccounts {
            proto_def::DeployBondingCurveIxAccounts {
                mint: self.mint.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_sol_vault: self.bonding_curve_sol_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                config: self.config.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::DeployBondingCurveIxData;
    impl IntoProto<proto_def::DeployBondingCurveIxData> for DeployBondingCurveIxData {
        fn into_proto(self) -> proto_def::DeployBondingCurveIxData {
            proto_def::DeployBondingCurveIxData {
                creator: self.creator.to_string(),
                salt: self.salt,
            }
        }
    }
    use super::DeployBondingCurveFallbackIxAccounts;
    impl IntoProto<proto_def::DeployBondingCurveFallbackIxAccounts>
        for DeployBondingCurveFallbackIxAccounts
    {
        fn into_proto(self) -> proto_def::DeployBondingCurveFallbackIxAccounts {
            proto_def::DeployBondingCurveFallbackIxAccounts {
                mint: self.mint.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_sol_vault: self.bonding_curve_sol_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                config: self.config.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::DeployBondingCurveFallbackIxData;
    impl IntoProto<proto_def::DeployBondingCurveFallbackIxData> for DeployBondingCurveFallbackIxData {
        fn into_proto(self) -> proto_def::DeployBondingCurveFallbackIxData {
            proto_def::DeployBondingCurveFallbackIxData {
                creator: self.creator.to_string(),
                salt: self.salt,
            }
        }
    }
    use super::DepositIntoRaydiumIxAccounts;
    impl IntoProto<proto_def::DepositIntoRaydiumIxAccounts> for DepositIntoRaydiumIxAccounts {
        fn into_proto(self) -> proto_def::DepositIntoRaydiumIxAccounts {
            proto_def::DepositIntoRaydiumIxAccounts {
                config: self.config.to_string(),
                amm_config: self.amm_config.to_string(),
                operator: self.operator.to_string(),
                operator_wsol_account: self.operator_wsol_account.to_string(),
                vault_authority: self.vault_authority.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_vault: self.bonding_curve_wsol_vault.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                lp_mint: self.lp_mint.to_string(),
                cpmm_program: self.cpmm_program.to_string(),
                owner_lp_token: self.owner_lp_token.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
            }
        }
    }
    use super::DepositIntoRaydiumIxData;
    impl IntoProto<proto_def::DepositIntoRaydiumIxData> for DepositIntoRaydiumIxData {
        fn into_proto(self) -> proto_def::DepositIntoRaydiumIxData {
            proto_def::DepositIntoRaydiumIxData {
                lp_token_amount: self.lp_token_amount,
                maximum_token0_amount: self.maximum_token0_amount,
                maximum_token1_amount: self.maximum_token1_amount,
            }
        }
    }
    use super::GraduateIxAccounts;
    impl IntoProto<proto_def::GraduateIxAccounts> for GraduateIxAccounts {
        fn into_proto(self) -> proto_def::GraduateIxAccounts {
            proto_def::GraduateIxAccounts {
                mint: self.mint.to_string(),
                wsol: self.wsol.to_string(),
                protocol_fee_recipient: self.protocol_fee_recipient.to_string(),
                token_distributor: self.token_distributor.to_string(),
                token_distributor_token_account: self.token_distributor_token_account.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve_sol_vault: self.bonding_curve_sol_vault.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_account: self.bonding_curve_wsol_account.to_string(),
                operator: self.operator.to_string(),
                config: self.config.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::InitializeIxAccounts;
    impl IntoProto<proto_def::InitializeIxAccounts> for InitializeIxAccounts {
        fn into_proto(self) -> proto_def::InitializeIxAccounts {
            proto_def::InitializeIxAccounts {
                config: self.config.to_string(),
                authority: self.authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeIxData;
    impl IntoProto<proto_def::InitializeIxData> for InitializeIxData {
        fn into_proto(self) -> proto_def::InitializeIxData {
            proto_def::InitializeIxData {
                protocol_fee_recipient: self.protocol_fee_recipient.to_string(),
                token_distributor: self.token_distributor.to_string(),
            }
        }
    }
    use super::InitiateAuthorityTransferIxAccounts;
    impl IntoProto<proto_def::InitiateAuthorityTransferIxAccounts>
        for InitiateAuthorityTransferIxAccounts
    {
        fn into_proto(self) -> proto_def::InitiateAuthorityTransferIxAccounts {
            proto_def::InitiateAuthorityTransferIxAccounts {
                authority: self.authority.to_string(),
                config: self.config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitiateAuthorityTransferIxData;
    impl IntoProto<proto_def::InitiateAuthorityTransferIxData> for InitiateAuthorityTransferIxData {
        fn into_proto(self) -> proto_def::InitiateAuthorityTransferIxData {
            proto_def::InitiateAuthorityTransferIxData {
                new_authority: self.new_authority.to_string(),
            }
        }
    }
    use super::LockRaydiumLiquidityIxAccounts;
    impl IntoProto<proto_def::LockRaydiumLiquidityIxAccounts> for LockRaydiumLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::LockRaydiumLiquidityIxAccounts {
            proto_def::LockRaydiumLiquidityIxAccounts {
                lock_program: self.lock_program.to_string(),
                vault_authority: self.vault_authority.to_string(),
                authority: self.authority.to_string(),
                fee_nft_owner: self.fee_nft_owner.to_string(),
                fee_nft_mint: self.fee_nft_mint.to_string(),
                fee_nft_account: self.fee_nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                locked_liquidity: self.locked_liquidity.to_string(),
                lp_mint: self.lp_mint.to_string(),
                liquidity_owner_lp: self.liquidity_owner_lp.to_string(),
                locked_lp_vault: self.locked_lp_vault.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                operator: self.operator.to_string(),
                config: self.config.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                metadata_account: self.metadata_account.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                metadata_program: self.metadata_program.to_string(),
            }
        }
    }
    use super::RemoveOperatorsIxAccounts;
    impl IntoProto<proto_def::RemoveOperatorsIxAccounts> for RemoveOperatorsIxAccounts {
        fn into_proto(self) -> proto_def::RemoveOperatorsIxAccounts {
            proto_def::RemoveOperatorsIxAccounts {
                config: self.config.to_string(),
                authority: self.authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::RemoveOperatorsIxData;
    impl IntoProto<proto_def::RemoveOperatorsIxData> for RemoveOperatorsIxData {
        fn into_proto(self) -> proto_def::RemoveOperatorsIxData {
            proto_def::RemoveOperatorsIxData {
                operators: self.operators.into_iter().map(|x| x.to_string()).collect(),
            }
        }
    }
    use super::SellTokenIxAccounts;
    impl IntoProto<proto_def::SellTokenIxAccounts> for SellTokenIxAccounts {
        fn into_proto(self) -> proto_def::SellTokenIxAccounts {
            proto_def::SellTokenIxAccounts {
                mint: self.mint.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                trading_fees_vault: self.trading_fees_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_sol_vault: self.bonding_curve_sol_vault.to_string(),
                seller_token_account: self.seller_token_account.to_string(),
                seller: self.seller.to_string(),
                recipient: self.recipient.to_string(),
                config: self.config.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::SellTokenIxData;
    impl IntoProto<proto_def::SellTokenIxData> for SellTokenIxData {
        fn into_proto(self) -> proto_def::SellTokenIxData {
            proto_def::SellTokenIxData {
                sell_amount: self.sell_amount,
                amount_out_min: self.amount_out_min,
            }
        }
    }
    use super::SplitTradingFeesIxAccounts;
    impl IntoProto<proto_def::SplitTradingFeesIxAccounts> for SplitTradingFeesIxAccounts {
        fn into_proto(self) -> proto_def::SplitTradingFeesIxAccounts {
            proto_def::SplitTradingFeesIxAccounts {
                operator: self.operator.to_string(),
                mint: self.mint.to_string(),
                wsol: self.wsol.to_string(),
                config: self.config.to_string(),
                vault_authority: self.vault_authority.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                trading_fees_vault: self.trading_fees_vault.to_string(),
                fee_splitter_program: self.fee_splitter_program.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                fee_splitter_config: self.fee_splitter_config.to_string(),
                fee_splitter_creator_vault: self.fee_splitter_creator_vault.to_string(),
                fee_splitter_vault_authority: self.fee_splitter_vault_authority.to_string(),
                fee_splitter_creator_vault_authority: self
                    .fee_splitter_creator_vault_authority
                    .to_string(),
                fee_splitter_staking_mint: self.fee_splitter_staking_mint.to_string(),
                fee_splitter_wsol_vault: self.fee_splitter_wsol_vault.to_string(),
                fee_splitter_creator_vault_authority_wsol_vault: self
                    .fee_splitter_creator_vault_authority_wsol_vault
                    .to_string(),
                fee_splitter_treasury_wsol_vault: self.fee_splitter_treasury_wsol_vault.to_string(),
                fee_splitter_team_wsol_vault: self.fee_splitter_team_wsol_vault.to_string(),
                fee_splitter_reward_pool: self.fee_splitter_reward_pool.to_string(),
                fee_splitter_reward_pool_staking_vault: self
                    .fee_splitter_reward_pool_staking_vault
                    .to_string(),
                fee_splitter_reward_pool_reward_vault: self
                    .fee_splitter_reward_pool_reward_vault
                    .to_string(),
                fee_splitter_reward_pool_program: self.fee_splitter_reward_pool_program.to_string(),
            }
        }
    }
    use super::SwapSolForTokensOnRaydiumIxAccounts;
    impl IntoProto<proto_def::SwapSolForTokensOnRaydiumIxAccounts>
        for SwapSolForTokensOnRaydiumIxAccounts
    {
        fn into_proto(self) -> proto_def::SwapSolForTokensOnRaydiumIxAccounts {
            proto_def::SwapSolForTokensOnRaydiumIxAccounts {
                config: self.config.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                amm_config: self.amm_config.to_string(),
                operator: self.operator.to_string(),
                vault_authority: self.vault_authority.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_vault: self.bonding_curve_wsol_vault.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                token_program: self.token_program.to_string(),
                cp_swap_program: self.cp_swap_program.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapSolForTokensOnRaydiumIxData;
    impl IntoProto<proto_def::SwapSolForTokensOnRaydiumIxData> for SwapSolForTokensOnRaydiumIxData {
        fn into_proto(self) -> proto_def::SwapSolForTokensOnRaydiumIxData {
            proto_def::SwapSolForTokensOnRaydiumIxData {
                amount_in: self.amount_in,
                minimum_amount_out: self.minimum_amount_out,
            }
        }
    }
    use super::SwapTokensForSolOnRaydiumIxAccounts;
    impl IntoProto<proto_def::SwapTokensForSolOnRaydiumIxAccounts>
        for SwapTokensForSolOnRaydiumIxAccounts
    {
        fn into_proto(self) -> proto_def::SwapTokensForSolOnRaydiumIxAccounts {
            proto_def::SwapTokensForSolOnRaydiumIxAccounts {
                config: self.config.to_string(),
                bonding_curve: self.bonding_curve.to_string(),
                amm_config: self.amm_config.to_string(),
                operator: self.operator.to_string(),
                vault_authority: self.vault_authority.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                bonding_curve_vault: self.bonding_curve_vault.to_string(),
                bonding_curve_wsol_vault: self.bonding_curve_wsol_vault.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                token_program: self.token_program.to_string(),
                cp_swap_program: self.cp_swap_program.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapTokensForSolOnRaydiumIxData;
    impl IntoProto<proto_def::SwapTokensForSolOnRaydiumIxData> for SwapTokensForSolOnRaydiumIxData {
        fn into_proto(self) -> proto_def::SwapTokensForSolOnRaydiumIxData {
            proto_def::SwapTokensForSolOnRaydiumIxData {
                amount_in: self.amount_in,
                minimum_amount_out: self.minimum_amount_out,
            }
        }
    }
    use super::TogglePausedIxAccounts;
    impl IntoProto<proto_def::TogglePausedIxAccounts> for TogglePausedIxAccounts {
        fn into_proto(self) -> proto_def::TogglePausedIxAccounts {
            proto_def::TogglePausedIxAccounts {
                authority: self.authority.to_string(),
                config: self.config.to_string(),
            }
        }
    }
    use super::UpdateConfigIxAccounts;
    impl IntoProto<proto_def::UpdateConfigIxAccounts> for UpdateConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateConfigIxAccounts {
            proto_def::UpdateConfigIxAccounts {
                config: self.config.to_string(),
                authority: self.authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateConfigIxData;
    impl IntoProto<proto_def::UpdateConfigIxData> for UpdateConfigIxData {
        fn into_proto(self) -> proto_def::UpdateConfigIxData {
            proto_def::UpdateConfigIxData {
                new_protocol_fee_recipient: self.new_protocol_fee_recipient.to_string(),
                new_virtual_sol_reserves: self.new_virtual_sol_reserves,
                new_virtual_token_reserves: self.new_virtual_token_reserves,
                new_graduation_target: self.new_graduation_target,
                new_graduation_fee: self.new_graduation_fee,
                new_damping_term: self.new_damping_term.into(),
                new_swap_fee_basis_points: self.new_swap_fee_basis_points.into(),
                new_token_for_stakers_basis_points: self.new_token_for_stakers_basis_points.into(),
                new_token_amount_for_raydium_liquidity: self.new_token_amount_for_raydium_liquidity,
                new_max_graduation_price_deviation_basis_points: self
                    .new_max_graduation_price_deviation_basis_points
                    .into(),
                new_max_swap_amount_for_pool_price_correction_basis_points: self
                    .new_max_swap_amount_for_pool_price_correction_basis_points
                    .into(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for BoopProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                BoopProgramIx::AddOperators(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::AddOperators(
                        proto_def::AddOperatorsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::BuyToken(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::BuyToken(
                        proto_def::BuyTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CancelAuthorityTransfer(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelAuthorityTransfer(
                        proto_def::CancelAuthorityTransferIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CloseBondingCurveVault(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseBondingCurveVault(
                        proto_def::CloseBondingCurveVaultIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CollectTradingFees(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectTradingFees(
                        proto_def::CollectTradingFeesIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CompleteAuthorityTransfer(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CompleteAuthorityTransfer(
                        proto_def::CompleteAuthorityTransferIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CreateRaydiumPool(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateRaydiumPool(
                        proto_def::CreateRaydiumPoolIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CreateRaydiumRandomPool(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateRaydiumRandomPool(
                        proto_def::CreateRaydiumRandomPoolIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CreateToken(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateToken(
                        proto_def::CreateTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::CreateTokenFallback(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenFallback(
                        proto_def::CreateTokenFallbackIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::DeployBondingCurve(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DeployBondingCurve(
                        proto_def::DeployBondingCurveIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::DeployBondingCurveFallback(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DeployBondingCurveFallback(
                        proto_def::DeployBondingCurveFallbackIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::DepositIntoRaydium(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DepositIntoRaydium(
                        proto_def::DepositIntoRaydiumIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::Graduate(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Graduate(
                        proto_def::GraduateIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::Initialize(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Initialize(
                        proto_def::InitializeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::InitiateAuthorityTransfer(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitiateAuthorityTransfer(
                        proto_def::InitiateAuthorityTransferIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::LockRaydiumLiquidity(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::LockRaydiumLiquidity(
                        proto_def::LockRaydiumLiquidityIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::RemoveOperators(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveOperators(
                        proto_def::RemoveOperatorsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::SellToken(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SellToken(
                        proto_def::SellTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::SplitTradingFees(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SplitTradingFees(
                        proto_def::SplitTradingFeesIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::SwapSolForTokensOnRaydium(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapSolForTokensOnRaydium(
                        proto_def::SwapSolForTokensOnRaydiumIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::SwapTokensForSolOnRaydium(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapTokensForSolOnRaydium(
                        proto_def::SwapTokensForSolOnRaydiumIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::TogglePaused(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TogglePaused(
                        proto_def::TogglePausedIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                BoopProgramIx::UpdateConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateConfig(
                        proto_def::UpdateConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
