//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use yellowstone_vixen_core::constants::is_known_aggregator;

use crate::{
    deserialize_checked,
    generated::types::SwapEvent,
    instructions::{
        ClosePermissionPda as ClosePermissionPdaIxAccounts,
        CollectCreatorFee as CollectCreatorFeeIxAccounts,
        CollectFundFee as CollectFundFeeIxAccounts,
        CollectFundFeeInstructionArgs as CollectFundFeeIxData,
        CollectProtocolFee as CollectProtocolFeeIxAccounts,
        CollectProtocolFeeInstructionArgs as CollectProtocolFeeIxData,
        CreateAmmConfig as CreateAmmConfigIxAccounts,
        CreateAmmConfigInstructionArgs as CreateAmmConfigIxData,
        CreatePermissionPda as CreatePermissionPdaIxAccounts, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData, Initialize as InitializeIxAccounts,
        InitializeInstructionArgs as InitializeIxData,
        InitializeWithPermission as InitializeWithPermissionIxAccounts,
        InitializeWithPermissionInstructionArgs as InitializeWithPermissionIxData,
        SwapBaseInput as SwapBaseInputIxAccounts,
        SwapBaseInputInstructionArgs as SwapBaseInputIxData,
        SwapBaseOutput as SwapBaseOutputIxAccounts,
        SwapBaseOutputInstructionArgs as SwapBaseOutputIxData,
        UpdateAmmConfig as UpdateAmmConfigIxAccounts,
        UpdateAmmConfigInstructionArgs as UpdateAmmConfigIxData,
        UpdatePoolStatus as UpdatePoolStatusIxAccounts,
        UpdatePoolStatusInstructionArgs as UpdatePoolStatusIxData, Withdraw as WithdrawIxAccounts,
        WithdrawInstructionArgs as WithdrawIxData,
    },
    ID,
};

/// RaydiumCpSwap Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum RaydiumCpSwapProgramIx {
    ClosePermissionPda(ClosePermissionPdaIxAccounts),
    CollectCreatorFee(CollectCreatorFeeIxAccounts),
    CollectFundFee(CollectFundFeeIxAccounts, CollectFundFeeIxData),
    CollectProtocolFee(CollectProtocolFeeIxAccounts, CollectProtocolFeeIxData),
    CreateAmmConfig(CreateAmmConfigIxAccounts, CreateAmmConfigIxData),
    CreatePermissionPda(CreatePermissionPdaIxAccounts),
    Deposit(DepositIxAccounts, DepositIxData),
    Initialize(InitializeIxAccounts, InitializeIxData),
    InitializeWithPermission(
        InitializeWithPermissionIxAccounts,
        InitializeWithPermissionIxData,
    ),
    SwapBaseInput(
        SwapBaseInputIxAccounts,
        SwapBaseInputIxData,
        Option<SwapEvent>,
    ),
    SwapBaseOutput(
        SwapBaseOutputIxAccounts,
        SwapBaseOutputIxData,
        Option<SwapEvent>,
    ),
    UpdateAmmConfig(UpdateAmmConfigIxAccounts, UpdateAmmConfigIxData),
    UpdatePoolStatus(UpdatePoolStatusIxAccounts, UpdatePoolStatusIxData),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = RaydiumCpSwapProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<RaydiumCpSwapProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "RaydiumCpSwap::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        if ix.data.len() < 8 {
            return Err(yellowstone_vixen_core::ParseError::from(
                "Instruction data too short".to_owned(),
            ));
        }

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [156, 84, 32, 118, 69, 135, 70, 123] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClosePermissionPdaIxAccounts {
                    owner: next_account(accounts)?,
                    permission_authority: next_account(accounts)?,
                    permission: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(RaydiumCpSwapProgramIx::ClosePermissionPda(ix_accounts))
            },
            [20, 22, 86, 123, 198, 28, 219, 132] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectCreatorFeeIxAccounts {
                    creator: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    creator_token0: next_account(accounts)?,
                    creator_token1: next_account(accounts)?,
                    token0_program: next_account(accounts)?,
                    token1_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(RaydiumCpSwapProgramIx::CollectCreatorFee(ix_accounts))
            },
            [167, 138, 78, 149, 223, 194, 6, 126] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectFundFeeIxAccounts {
                    owner: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token0_account: next_account(accounts)?,
                    recipient_token1_account: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectFundFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::CollectFundFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [136, 136, 252, 221, 194, 66, 126, 89] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectProtocolFeeIxAccounts {
                    owner: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token0_account: next_account(accounts)?,
                    recipient_token1_account: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectProtocolFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::CollectProtocolFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [137, 52, 237, 212, 215, 117, 108, 104] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::CreateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [135, 136, 2, 216, 137, 169, 181, 202] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatePermissionPdaIxAccounts {
                    owner: next_account(accounts)?,
                    permission_authority: next_account(accounts)?,
                    permission: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(RaydiumCpSwapProgramIx::CreatePermissionPda(ix_accounts))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DepositIxAccounts {
                    owner: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    owner_lp_token: next_account(accounts)?,
                    token0_account: next_account(accounts)?,
                    token1_account: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                };
                let de_ix_data: DepositIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                let expected_accounts_len = 20;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeIxAccounts {
                    creator: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token0_mint: next_account(accounts)?,
                    token1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    creator_token0: next_account(accounts)?,
                    creator_token1: next_account(accounts)?,
                    creator_lp_token: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    create_pool_fee: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token0_program: next_account(accounts)?,
                    token1_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: InitializeIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::Initialize(ix_accounts, de_ix_data))
            },
            [63, 55, 254, 65, 49, 178, 89, 121] => {
                let expected_accounts_len = 21;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeWithPermissionIxAccounts {
                    payer: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token0_mint: next_account(accounts)?,
                    token1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    payer_token0: next_account(accounts)?,
                    payer_token1: next_account(accounts)?,
                    payer_lp_token: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    create_pool_fee: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    permission: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token0_program: next_account(accounts)?,
                    token1_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializeWithPermissionIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::InitializeWithPermission(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [143, 190, 90, 218, 196, 30, 51, 222] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapBaseInputIxAccounts {
                    payer: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    input_token_program: next_account(accounts)?,
                    output_token_program: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    output_token_mint: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                };
                let de_ix_data: SwapBaseInputIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }
                let swap_event = SwapEvent::from_logs(&ix.parsed_logs);
                Ok(RaydiumCpSwapProgramIx::SwapBaseInput(
                    ix_accounts,
                    de_ix_data,
                    swap_event,
                ))
            },
            [55, 217, 98, 86, 163, 74, 180, 173] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapBaseOutputIxAccounts {
                    payer: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    input_token_program: next_account(accounts)?,
                    output_token_program: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    output_token_mint: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                };
                let de_ix_data: SwapBaseOutputIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }
                let swap_event = SwapEvent::from_logs(&ix.parsed_logs);
                Ok(RaydiumCpSwapProgramIx::SwapBaseOutput(
                    ix_accounts,
                    de_ix_data,
                    swap_event,
                ))
            },
            [49, 60, 174, 136, 154, 28, 116, 200] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                };
                let de_ix_data: UpdateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::UpdateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [130, 87, 108, 6, 46, 224, 117, 123] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdatePoolStatusIxAccounts {
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                };
                let de_ix_data: UpdatePoolStatusIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::UpdatePoolStatus(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [183, 18, 70, 156, 148, 109, 161, 34] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WithdrawIxAccounts {
                    owner: next_account(accounts)?,
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    owner_lp_token: next_account(accounts)?,
                    token0_account: next_account(accounts)?,
                    token1_account: next_account(accounts)?,
                    token0_vault: next_account(accounts)?,
                    token1_vault: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                let de_ix_data: WithdrawIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(RaydiumCpSwapProgramIx::Withdraw(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{ClosePermissionPdaIxAccounts, InstructionParser, RaydiumCpSwapProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClosePermissionPdaIxAccounts> for ClosePermissionPdaIxAccounts {
        fn into_proto(self) -> proto_def::ClosePermissionPdaIxAccounts {
            proto_def::ClosePermissionPdaIxAccounts {
                owner: self.owner.to_string(),
                permission_authority: self.permission_authority.to_string(),
                permission: self.permission.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CollectCreatorFeeIxAccounts;
    impl IntoProto<proto_def::CollectCreatorFeeIxAccounts> for CollectCreatorFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectCreatorFeeIxAccounts {
            proto_def::CollectCreatorFeeIxAccounts {
                creator: self.creator.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                creator_token0: self.creator_token0.to_string(),
                creator_token1: self.creator_token1.to_string(),
                token0_program: self.token0_program.to_string(),
                token1_program: self.token1_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxAccounts;
    impl IntoProto<proto_def::CollectFundFeeIxAccounts> for CollectFundFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectFundFeeIxAccounts {
            proto_def::CollectFundFeeIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token0_account: self.recipient_token0_account.to_string(),
                recipient_token1_account: self.recipient_token1_account.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxData;
    impl IntoProto<proto_def::CollectFundFeeIxData> for CollectFundFeeIxData {
        fn into_proto(self) -> proto_def::CollectFundFeeIxData {
            proto_def::CollectFundFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CollectProtocolFeeIxAccounts;
    impl IntoProto<proto_def::CollectProtocolFeeIxAccounts> for CollectProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxAccounts {
            proto_def::CollectProtocolFeeIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token0_account: self.recipient_token0_account.to_string(),
                recipient_token1_account: self.recipient_token1_account.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectProtocolFeeIxData;
    impl IntoProto<proto_def::CollectProtocolFeeIxData> for CollectProtocolFeeIxData {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxData {
            proto_def::CollectProtocolFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CreateAmmConfigIxAccounts;
    impl IntoProto<proto_def::CreateAmmConfigIxAccounts> for CreateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxAccounts {
            proto_def::CreateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateAmmConfigIxData;
    impl IntoProto<proto_def::CreateAmmConfigIxData> for CreateAmmConfigIxData {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxData {
            proto_def::CreateAmmConfigIxData {
                index: self.index.into(),
                trade_fee_rate: self.trade_fee_rate,
                protocol_fee_rate: self.protocol_fee_rate,
                fund_fee_rate: self.fund_fee_rate,
                create_pool_fee: self.create_pool_fee,
                creator_fee_rate: self.creator_fee_rate,
            }
        }
    }
    use super::CreatePermissionPdaIxAccounts;
    impl IntoProto<proto_def::CreatePermissionPdaIxAccounts> for CreatePermissionPdaIxAccounts {
        fn into_proto(self) -> proto_def::CreatePermissionPdaIxAccounts {
            proto_def::CreatePermissionPdaIxAccounts {
                owner: self.owner.to_string(),
                permission_authority: self.permission_authority.to_string(),
                permission: self.permission.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::DepositIxAccounts;
    impl IntoProto<proto_def::DepositIxAccounts> for DepositIxAccounts {
        fn into_proto(self) -> proto_def::DepositIxAccounts {
            proto_def::DepositIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                owner_lp_token: self.owner_lp_token.to_string(),
                token0_account: self.token0_account.to_string(),
                token1_account: self.token1_account.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
            }
        }
    }
    use super::DepositIxData;
    impl IntoProto<proto_def::DepositIxData> for DepositIxData {
        fn into_proto(self) -> proto_def::DepositIxData {
            proto_def::DepositIxData {
                lp_token_amount: self.lp_token_amount,
                maximum_token0_amount: self.maximum_token0_amount,
                maximum_token1_amount: self.maximum_token1_amount,
            }
        }
    }
    use super::InitializeIxAccounts;
    impl IntoProto<proto_def::InitializeIxAccounts> for InitializeIxAccounts {
        fn into_proto(self) -> proto_def::InitializeIxAccounts {
            proto_def::InitializeIxAccounts {
                creator: self.creator.to_string(),
                amm_config: self.amm_config.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                creator_token0: self.creator_token0.to_string(),
                creator_token1: self.creator_token1.to_string(),
                creator_lp_token: self.creator_lp_token.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                create_pool_fee: self.create_pool_fee.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                token0_program: self.token0_program.to_string(),
                token1_program: self.token1_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::InitializeIxData;
    impl IntoProto<proto_def::InitializeIxData> for InitializeIxData {
        fn into_proto(self) -> proto_def::InitializeIxData {
            proto_def::InitializeIxData {
                init_amount0: self.init_amount0,
                init_amount1: self.init_amount1,
                open_time: self.open_time,
            }
        }
    }
    use super::InitializeWithPermissionIxAccounts;
    impl IntoProto<proto_def::InitializeWithPermissionIxAccounts>
        for InitializeWithPermissionIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializeWithPermissionIxAccounts {
            proto_def::InitializeWithPermissionIxAccounts {
                payer: self.payer.to_string(),
                creator: self.creator.to_string(),
                amm_config: self.amm_config.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                payer_token0: self.payer_token0.to_string(),
                payer_token1: self.payer_token1.to_string(),
                payer_lp_token: self.payer_lp_token.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                create_pool_fee: self.create_pool_fee.to_string(),
                observation_state: self.observation_state.to_string(),
                permission: self.permission.to_string(),
                token_program: self.token_program.to_string(),
                token0_program: self.token0_program.to_string(),
                token1_program: self.token1_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeWithPermissionIxData;
    impl IntoProto<proto_def::InitializeWithPermissionIxData> for InitializeWithPermissionIxData {
        fn into_proto(self) -> proto_def::InitializeWithPermissionIxData {
            proto_def::InitializeWithPermissionIxData {
                init_amount0: self.init_amount0,
                init_amount1: self.init_amount1,
                open_time: self.open_time,
                creator_fee_on: self.creator_fee_on as i32,
            }
        }
    }
    use super::SwapBaseInputIxAccounts;
    impl IntoProto<proto_def::SwapBaseInputIxAccounts> for SwapBaseInputIxAccounts {
        fn into_proto(self) -> proto_def::SwapBaseInputIxAccounts {
            proto_def::SwapBaseInputIxAccounts {
                payer: self.payer.to_string(),
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_token_program: self.output_token_program.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapBaseInputIxData;
    impl IntoProto<proto_def::SwapBaseInputIxData> for SwapBaseInputIxData {
        fn into_proto(self) -> proto_def::SwapBaseInputIxData {
            proto_def::SwapBaseInputIxData {
                amount_in: self.amount_in,
                minimum_amount_out: self.minimum_amount_out,
            }
        }
    }
    use super::SwapBaseOutputIxAccounts;
    impl IntoProto<proto_def::SwapBaseOutputIxAccounts> for SwapBaseOutputIxAccounts {
        fn into_proto(self) -> proto_def::SwapBaseOutputIxAccounts {
            proto_def::SwapBaseOutputIxAccounts {
                payer: self.payer.to_string(),
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_token_program: self.output_token_program.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapBaseOutputIxData;
    impl IntoProto<proto_def::SwapBaseOutputIxData> for SwapBaseOutputIxData {
        fn into_proto(self) -> proto_def::SwapBaseOutputIxData {
            proto_def::SwapBaseOutputIxData {
                max_amount_in: self.max_amount_in,
                amount_out: self.amount_out,
            }
        }
    }
    use super::UpdateAmmConfigIxAccounts;
    impl IntoProto<proto_def::UpdateAmmConfigIxAccounts> for UpdateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxAccounts {
            proto_def::UpdateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
            }
        }
    }
    use super::UpdateAmmConfigIxData;
    impl IntoProto<proto_def::UpdateAmmConfigIxData> for UpdateAmmConfigIxData {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxData {
            proto_def::UpdateAmmConfigIxData {
                param: self.param.into(),
                value: self.value,
            }
        }
    }
    use super::UpdatePoolStatusIxAccounts;
    impl IntoProto<proto_def::UpdatePoolStatusIxAccounts> for UpdatePoolStatusIxAccounts {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxAccounts {
            proto_def::UpdatePoolStatusIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::UpdatePoolStatusIxData;
    impl IntoProto<proto_def::UpdatePoolStatusIxData> for UpdatePoolStatusIxData {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxData {
            proto_def::UpdatePoolStatusIxData {
                status: self.status.into(),
            }
        }
    }
    use super::WithdrawIxAccounts;
    impl IntoProto<proto_def::WithdrawIxAccounts> for WithdrawIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawIxAccounts {
            proto_def::WithdrawIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                owner_lp_token: self.owner_lp_token.to_string(),
                token0_account: self.token0_account.to_string(),
                token1_account: self.token1_account.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::WithdrawIxData;
    impl IntoProto<proto_def::WithdrawIxData> for WithdrawIxData {
        fn into_proto(self) -> proto_def::WithdrawIxData {
            proto_def::WithdrawIxData {
                lp_token_amount: self.lp_token_amount,
                minimum_token0_amount: self.minimum_token0_amount,
                minimum_token1_amount: self.minimum_token1_amount,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for RaydiumCpSwapProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                RaydiumCpSwapProgramIx::ClosePermissionPda(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClosePermissionPda(
                        proto_def::ClosePermissionPdaIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CollectCreatorFee(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectCreatorFee(
                        proto_def::CollectCreatorFeeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CollectFundFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectFundFee(
                        proto_def::CollectFundFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CollectProtocolFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectProtocolFee(
                        proto_def::CollectProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CreateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateAmmConfig(
                        proto_def::CreateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CreatePermissionPda(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatePermissionPda(
                        proto_def::CreatePermissionPdaIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Deposit(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Deposit(
                        proto_def::DepositIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Initialize(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Initialize(
                        proto_def::InitializeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::InitializeWithPermission(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeWithPermission(
                            proto_def::InitializeWithPermissionIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                RaydiumCpSwapProgramIx::SwapBaseInput(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapBaseInput(
                        proto_def::SwapBaseInputIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::SwapBaseOutput(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapBaseOutput(
                        proto_def::SwapBaseOutputIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::UpdateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAmmConfig(
                        proto_def::UpdateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::UpdatePoolStatus(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdatePoolStatus(
                        proto_def::UpdatePoolStatusIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Withdraw(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Withdraw(
                        proto_def::WithdrawIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
