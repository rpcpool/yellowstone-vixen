//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CollectFundFee as CollectFundFeeIxAccounts,
        CollectFundFeeInstructionArgs as CollectFundFeeIxData,
        CollectProtocolFee as CollectProtocolFeeIxAccounts,
        CollectProtocolFeeInstructionArgs as CollectProtocolFeeIxData,
        CreateAmmConfig as CreateAmmConfigIxAccounts,
        CreateAmmConfigInstructionArgs as CreateAmmConfigIxData, Deposit as DepositIxAccounts,
        DepositInstructionArgs as DepositIxData, Initialize as InitializeIxAccounts,
        InitializeInstructionArgs as InitializeIxData, SwapBaseInput as SwapBaseInputIxAccounts,
        SwapBaseInputInstructionArgs as SwapBaseInputIxData,
        SwapBaseOutput as SwapBaseOutputIxAccounts,
        SwapBaseOutputInstructionArgs as SwapBaseOutputIxData,
        UpdateAmmConfig as UpdateAmmConfigIxAccounts,
        UpdateAmmConfigInstructionArgs as UpdateAmmConfigIxData,
        UpdatePoolStatus as UpdatePoolStatusIxAccounts,
        UpdatePoolStatusInstructionArgs as UpdatePoolStatusIxData, Withdraw as WithdrawIxAccounts,
        WithdrawInstructionArgs as WithdrawIxData,
    },
    ID,
};

/// RaydiumCpSwap Instructions
#[derive(Debug, strum_macros::Display)]
pub enum RaydiumCpSwapProgramIx {
    CreateAmmConfig(CreateAmmConfigIxAccounts, CreateAmmConfigIxData),
    UpdateAmmConfig(UpdateAmmConfigIxAccounts, UpdateAmmConfigIxData),
    UpdatePoolStatus(UpdatePoolStatusIxAccounts, UpdatePoolStatusIxData),
    CollectProtocolFee(CollectProtocolFeeIxAccounts, CollectProtocolFeeIxData),
    CollectFundFee(CollectFundFeeIxAccounts, CollectFundFeeIxData),
    Initialize(InitializeIxAccounts, InitializeIxData),
    Deposit(DepositIxAccounts, DepositIxData),
    Withdraw(WithdrawIxAccounts, WithdrawIxData),
    SwapBaseInput(SwapBaseInputIxAccounts, SwapBaseInputIxData),
    SwapBaseOutput(SwapBaseOutputIxAccounts, SwapBaseOutputIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = RaydiumCpSwapProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "RaydiumCpSwap::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<RaydiumCpSwapProgramIx> {
        let accounts_len = ix.accounts.len();
        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        match ix_discriminator {
            [137, 52, 237, 212, 215, 117, 108, 104] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateAmmConfigIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: CreateAmmConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CreateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [49, 60, 174, 136, 154, 28, 116, 200] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateAmmConfigIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateAmmConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::UpdateAmmConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [130, 87, 108, 6, 46, 224, 117, 123] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdatePoolStatusIxAccounts {
                    authority: ix.accounts[0].0.into(),
                    pool_state: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdatePoolStatusIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::UpdatePoolStatus(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [136, 136, 252, 221, 194, 66, 126, 89] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = CollectProtocolFeeIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    amm_config: ix.accounts[3].0.into(),
                    token0_vault: ix.accounts[4].0.into(),
                    token1_vault: ix.accounts[5].0.into(),
                    vault0_mint: ix.accounts[6].0.into(),
                    vault1_mint: ix.accounts[7].0.into(),
                    recipient_token0_account: ix.accounts[8].0.into(),
                    recipient_token1_account: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    token_program2022: ix.accounts[11].0.into(),
                };
                let de_ix_data: CollectProtocolFeeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CollectProtocolFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [167, 138, 78, 149, 223, 194, 6, 126] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = CollectFundFeeIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    amm_config: ix.accounts[3].0.into(),
                    token0_vault: ix.accounts[4].0.into(),
                    token1_vault: ix.accounts[5].0.into(),
                    vault0_mint: ix.accounts[6].0.into(),
                    vault1_mint: ix.accounts[7].0.into(),
                    recipient_token0_account: ix.accounts[8].0.into(),
                    recipient_token1_account: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    token_program2022: ix.accounts[11].0.into(),
                };
                let de_ix_data: CollectFundFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::CollectFundFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                check_min_accounts_req(accounts_len, 20)?;
                let ix_accounts = InitializeIxAccounts {
                    creator: ix.accounts[0].0.into(),
                    amm_config: ix.accounts[1].0.into(),
                    authority: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    token0_mint: ix.accounts[4].0.into(),
                    token1_mint: ix.accounts[5].0.into(),
                    lp_mint: ix.accounts[6].0.into(),
                    creator_token0: ix.accounts[7].0.into(),
                    creator_token1: ix.accounts[8].0.into(),
                    creator_lp_token: ix.accounts[9].0.into(),
                    token0_vault: ix.accounts[10].0.into(),
                    token1_vault: ix.accounts[11].0.into(),
                    create_pool_fee: ix.accounts[12].0.into(),
                    observation_state: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                    token0_program: ix.accounts[15].0.into(),
                    token1_program: ix.accounts[16].0.into(),
                    associated_token_program: ix.accounts[17].0.into(),
                    system_program: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                };
                let de_ix_data: InitializeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Initialize(ix_accounts, de_ix_data))
            },
            [242, 35, 198, 137, 82, 225, 242, 182] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = DepositIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    owner_lp_token: ix.accounts[3].0.into(),
                    token0_account: ix.accounts[4].0.into(),
                    token1_account: ix.accounts[5].0.into(),
                    token0_vault: ix.accounts[6].0.into(),
                    token1_vault: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    token_program2022: ix.accounts[9].0.into(),
                    vault0_mint: ix.accounts[10].0.into(),
                    vault1_mint: ix.accounts[11].0.into(),
                    lp_mint: ix.accounts[12].0.into(),
                };
                let de_ix_data: DepositIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Deposit(ix_accounts, de_ix_data))
            },
            [183, 18, 70, 156, 148, 109, 161, 34] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = WithdrawIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    pool_state: ix.accounts[2].0.into(),
                    owner_lp_token: ix.accounts[3].0.into(),
                    token0_account: ix.accounts[4].0.into(),
                    token1_account: ix.accounts[5].0.into(),
                    token0_vault: ix.accounts[6].0.into(),
                    token1_vault: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    token_program2022: ix.accounts[9].0.into(),
                    vault0_mint: ix.accounts[10].0.into(),
                    vault1_mint: ix.accounts[11].0.into(),
                    lp_mint: ix.accounts[12].0.into(),
                    memo_program: ix.accounts[13].0.into(),
                };
                let de_ix_data: WithdrawIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::Withdraw(ix_accounts, de_ix_data))
            },
            [143, 190, 90, 218, 196, 30, 51, 222] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SwapBaseInputIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    amm_config: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    input_token_account: ix.accounts[4].0.into(),
                    output_token_account: ix.accounts[5].0.into(),
                    input_vault: ix.accounts[6].0.into(),
                    output_vault: ix.accounts[7].0.into(),
                    input_token_program: ix.accounts[8].0.into(),
                    output_token_program: ix.accounts[9].0.into(),
                    input_token_mint: ix.accounts[10].0.into(),
                    output_token_mint: ix.accounts[11].0.into(),
                    observation_state: ix.accounts[12].0.into(),
                };
                let de_ix_data: SwapBaseInputIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::SwapBaseInput(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [55, 217, 98, 86, 163, 74, 180, 173] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SwapBaseOutputIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    authority: ix.accounts[1].0.into(),
                    amm_config: ix.accounts[2].0.into(),
                    pool_state: ix.accounts[3].0.into(),
                    input_token_account: ix.accounts[4].0.into(),
                    output_token_account: ix.accounts[5].0.into(),
                    input_vault: ix.accounts[6].0.into(),
                    output_vault: ix.accounts[7].0.into(),
                    input_token_program: ix.accounts[8].0.into(),
                    output_token_program: ix.accounts[9].0.into(),
                    input_token_mint: ix.accounts[10].0.into(),
                    output_token_mint: ix.accounts[11].0.into(),
                    observation_state: ix.accounts[12].0.into(),
                };
                let de_ix_data: SwapBaseOutputIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(RaydiumCpSwapProgramIx::SwapBaseOutput(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        }
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{CreateAmmConfigIxAccounts, InstructionParser, RaydiumCpSwapProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::CreateAmmConfigIxAccounts> for CreateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxAccounts {
            proto_def::CreateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateAmmConfigIxData;
    impl IntoProto<proto_def::CreateAmmConfigIxData> for CreateAmmConfigIxData {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxData {
            proto_def::CreateAmmConfigIxData {
                index: self.index.into(),
                trade_fee_rate: self.trade_fee_rate,
                protocol_fee_rate: self.protocol_fee_rate,
                fund_fee_rate: self.fund_fee_rate,
                create_pool_fee: self.create_pool_fee,
            }
        }
    }
    use super::UpdateAmmConfigIxAccounts;
    impl IntoProto<proto_def::UpdateAmmConfigIxAccounts> for UpdateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxAccounts {
            proto_def::UpdateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
            }
        }
    }
    use super::UpdateAmmConfigIxData;
    impl IntoProto<proto_def::UpdateAmmConfigIxData> for UpdateAmmConfigIxData {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxData {
            proto_def::UpdateAmmConfigIxData {
                param: self.param.into(),
                value: self.value,
            }
        }
    }
    use super::UpdatePoolStatusIxAccounts;
    impl IntoProto<proto_def::UpdatePoolStatusIxAccounts> for UpdatePoolStatusIxAccounts {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxAccounts {
            proto_def::UpdatePoolStatusIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::UpdatePoolStatusIxData;
    impl IntoProto<proto_def::UpdatePoolStatusIxData> for UpdatePoolStatusIxData {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxData {
            proto_def::UpdatePoolStatusIxData {
                status: self.status.into(),
            }
        }
    }
    use super::CollectProtocolFeeIxAccounts;
    impl IntoProto<proto_def::CollectProtocolFeeIxAccounts> for CollectProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxAccounts {
            proto_def::CollectProtocolFeeIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token0_account: self.recipient_token0_account.to_string(),
                recipient_token1_account: self.recipient_token1_account.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectProtocolFeeIxData;
    impl IntoProto<proto_def::CollectProtocolFeeIxData> for CollectProtocolFeeIxData {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxData {
            proto_def::CollectProtocolFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CollectFundFeeIxAccounts;
    impl IntoProto<proto_def::CollectFundFeeIxAccounts> for CollectFundFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectFundFeeIxAccounts {
            proto_def::CollectFundFeeIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token0_account: self.recipient_token0_account.to_string(),
                recipient_token1_account: self.recipient_token1_account.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxData;
    impl IntoProto<proto_def::CollectFundFeeIxData> for CollectFundFeeIxData {
        fn into_proto(self) -> proto_def::CollectFundFeeIxData {
            proto_def::CollectFundFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::InitializeIxAccounts;
    impl IntoProto<proto_def::InitializeIxAccounts> for InitializeIxAccounts {
        fn into_proto(self) -> proto_def::InitializeIxAccounts {
            proto_def::InitializeIxAccounts {
                creator: self.creator.to_string(),
                amm_config: self.amm_config.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                token0_mint: self.token0_mint.to_string(),
                token1_mint: self.token1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                creator_token0: self.creator_token0.to_string(),
                creator_token1: self.creator_token1.to_string(),
                creator_lp_token: self.creator_lp_token.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                create_pool_fee: self.create_pool_fee.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                token0_program: self.token0_program.to_string(),
                token1_program: self.token1_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::InitializeIxData;
    impl IntoProto<proto_def::InitializeIxData> for InitializeIxData {
        fn into_proto(self) -> proto_def::InitializeIxData {
            proto_def::InitializeIxData {
                init_amount0: self.init_amount0,
                init_amount1: self.init_amount1,
                open_time: self.open_time,
            }
        }
    }
    use super::DepositIxAccounts;
    impl IntoProto<proto_def::DepositIxAccounts> for DepositIxAccounts {
        fn into_proto(self) -> proto_def::DepositIxAccounts {
            proto_def::DepositIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                owner_lp_token: self.owner_lp_token.to_string(),
                token0_account: self.token0_account.to_string(),
                token1_account: self.token1_account.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
            }
        }
    }
    use super::DepositIxData;
    impl IntoProto<proto_def::DepositIxData> for DepositIxData {
        fn into_proto(self) -> proto_def::DepositIxData {
            proto_def::DepositIxData {
                lp_token_amount: self.lp_token_amount,
                maximum_token0_amount: self.maximum_token0_amount,
                maximum_token1_amount: self.maximum_token1_amount,
            }
        }
    }
    use super::WithdrawIxAccounts;
    impl IntoProto<proto_def::WithdrawIxAccounts> for WithdrawIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawIxAccounts {
            proto_def::WithdrawIxAccounts {
                owner: self.owner.to_string(),
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
                owner_lp_token: self.owner_lp_token.to_string(),
                token0_account: self.token0_account.to_string(),
                token1_account: self.token1_account.to_string(),
                token0_vault: self.token0_vault.to_string(),
                token1_vault: self.token1_vault.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                lp_mint: self.lp_mint.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::WithdrawIxData;
    impl IntoProto<proto_def::WithdrawIxData> for WithdrawIxData {
        fn into_proto(self) -> proto_def::WithdrawIxData {
            proto_def::WithdrawIxData {
                lp_token_amount: self.lp_token_amount,
                minimum_token0_amount: self.minimum_token0_amount,
                minimum_token1_amount: self.minimum_token1_amount,
            }
        }
    }
    use super::SwapBaseInputIxAccounts;
    impl IntoProto<proto_def::SwapBaseInputIxAccounts> for SwapBaseInputIxAccounts {
        fn into_proto(self) -> proto_def::SwapBaseInputIxAccounts {
            proto_def::SwapBaseInputIxAccounts {
                payer: self.payer.to_string(),
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_token_program: self.output_token_program.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapBaseInputIxData;
    impl IntoProto<proto_def::SwapBaseInputIxData> for SwapBaseInputIxData {
        fn into_proto(self) -> proto_def::SwapBaseInputIxData {
            proto_def::SwapBaseInputIxData {
                amount_in: self.amount_in,
                minimum_amount_out: self.minimum_amount_out,
            }
        }
    }
    use super::SwapBaseOutputIxAccounts;
    impl IntoProto<proto_def::SwapBaseOutputIxAccounts> for SwapBaseOutputIxAccounts {
        fn into_proto(self) -> proto_def::SwapBaseOutputIxAccounts {
            proto_def::SwapBaseOutputIxAccounts {
                payer: self.payer.to_string(),
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_token_program: self.output_token_program.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                observation_state: self.observation_state.to_string(),
            }
        }
    }
    use super::SwapBaseOutputIxData;
    impl IntoProto<proto_def::SwapBaseOutputIxData> for SwapBaseOutputIxData {
        fn into_proto(self) -> proto_def::SwapBaseOutputIxData {
            proto_def::SwapBaseOutputIxData {
                max_amount_in: self.max_amount_in,
                amount_out: self.amount_out,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for RaydiumCpSwapProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                RaydiumCpSwapProgramIx::CreateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateAmmConfig(
                        proto_def::CreateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::UpdateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAmmConfig(
                        proto_def::UpdateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::UpdatePoolStatus(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdatePoolStatus(
                        proto_def::UpdatePoolStatusIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CollectProtocolFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectProtocolFee(
                        proto_def::CollectProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::CollectFundFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectFundFee(
                        proto_def::CollectFundFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Initialize(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Initialize(
                        proto_def::InitializeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Deposit(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Deposit(
                        proto_def::DepositIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::Withdraw(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Withdraw(
                        proto_def::WithdrawIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::SwapBaseInput(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapBaseInput(
                        proto_def::SwapBaseInputIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                RaydiumCpSwapProgramIx::SwapBaseOutput(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapBaseOutput(
                        proto_def::SwapBaseOutputIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
