//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

// #[cfg(feature = "proto")]
pub mod proto_types_parsers {
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use crate::proto_def;

    use crate::types::AddResolverEvent;
    impl IntoProto<proto_def::AddResolverEvent> for AddResolverEvent {
        fn into_proto(self) -> proto_def::AddResolverEvent {
            proto_def::AddResolverEvent {
                resolver: self.resolver.to_string(),
            }
        }
    }
    use crate::types::CancelOrderEvent;
    impl IntoProto<proto_def::CancelOrderEvent> for CancelOrderEvent {
        fn into_proto(self) -> proto_def::CancelOrderEvent {
            proto_def::CancelOrderEvent {
                order_id: self.order_id,
                payer: self.payer.to_string(),
                maker: self.maker.to_string(),
                update_ts: self.update_ts,
            }
        }
    }
    use crate::types::CommissionSwapArgs;
    impl IntoProto<proto_def::CommissionSwapArgs> for CommissionSwapArgs {
        fn into_proto(self) -> proto_def::CommissionSwapArgs {
            proto_def::CommissionSwapArgs {
                amount_in: self.amount_in,
                expect_amount_out: self.expect_amount_out,
                min_return: self.min_return,
                amounts: self.amounts.to_vec(),
                routes: self
                    .routes
                    .into_iter()
                    .map(|route_vec| proto_def::Route {
                        dexes: route_vec.iter().flat_map(|route| route.dexes.iter().map(|&dex| dex as i32)).collect(),
                        weights: route_vec.iter().flat_map(|route| route.weights.iter().cloned()).collect(),
                    })
                    .collect(),
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
            }
        }
    }
    use crate::types::FillOrderEvent;
    impl IntoProto<proto_def::FillOrderEvent> for FillOrderEvent {
        fn into_proto(self) -> proto_def::FillOrderEvent {
            proto_def::FillOrderEvent {
                order_id: self.order_id,
                payer: self.payer.to_string(),
                maker: self.maker.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                making_amount: self.making_amount,
                taking_amount: self.taking_amount,
                update_ts: self.update_ts,
            }
        }
    }
    use crate::types::InitGlobalConfigEvent;
    impl IntoProto<proto_def::InitGlobalConfigEvent> for InitGlobalConfigEvent {
        fn into_proto(self) -> proto_def::InitGlobalConfigEvent {
            proto_def::InitGlobalConfigEvent {
                admin: self.admin.to_string(),
                trade_fee: self.trade_fee,
            }
        }
    }
    use crate::types::PauseTradingEvent;
    impl IntoProto<proto_def::PauseTradingEvent> for PauseTradingEvent {
        fn into_proto(self) -> proto_def::PauseTradingEvent {
            proto_def::PauseTradingEvent {
                paused: self.paused,
            }
        }
    }
    use crate::types::PlaceOrderEvent;
    impl IntoProto<proto_def::PlaceOrderEvent> for PlaceOrderEvent {
        fn into_proto(self) -> proto_def::PlaceOrderEvent {
            proto_def::PlaceOrderEvent {
                order_id: self.order_id,
                maker: self.maker.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                output_token_mint: self.output_token_mint.to_string(),
                making_amount: self.making_amount,
                expect_taking_amount: self.expect_taking_amount,
                min_return_amount: self.min_return_amount,
                create_ts: self.create_ts,
                deadline: self.deadline,
                trade_fee: self.trade_fee,
            }
        }
    }
    use crate::types::RefundEvent;
    impl IntoProto<proto_def::RefundEvent> for RefundEvent {
        fn into_proto(self) -> proto_def::RefundEvent {
            proto_def::RefundEvent {
                order_id: self.order_id,
                maker: self.maker.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                amount: self.amount,
            }
        }
    }
    use crate::types::RemoveResolverEvent;
    impl IntoProto<proto_def::RemoveResolverEvent> for RemoveResolverEvent {
        fn into_proto(self) -> proto_def::RemoveResolverEvent {
            proto_def::RemoveResolverEvent {
                resolver: self.resolver.to_string(),
            }
        }
    }
    use crate::types::Route;
    impl IntoProto<proto_def::Route> for Route {
        fn into_proto(self) -> proto_def::Route {
            proto_def::Route {
                dexes: self.dexes.into_iter().map(|x| x as i32).collect(),
                weights: self.weights,
            }
        }
    }
    use crate::types::SetAdminEvent;
    impl IntoProto<proto_def::SetAdminEvent> for SetAdminEvent {
        fn into_proto(self) -> proto_def::SetAdminEvent {
            proto_def::SetAdminEvent {
                admin: self.admin.to_string(),
            }
        }
    }
    use crate::types::SetFeeMultiplierEvent;
    impl IntoProto<proto_def::SetFeeMultiplierEvent> for SetFeeMultiplierEvent {
        fn into_proto(self) -> proto_def::SetFeeMultiplierEvent {
            proto_def::SetFeeMultiplierEvent {
                fee_multiplier: self.fee_multiplier.into(),
            }
        }
    }
    use crate::types::SetTradeFeeEvent;
    impl IntoProto<proto_def::SetTradeFeeEvent> for SetTradeFeeEvent {
        fn into_proto(self) -> proto_def::SetTradeFeeEvent {
            proto_def::SetTradeFeeEvent {
                trade_fee: self.trade_fee,
            }
        }
    }
    use crate::types::SwapArgs;
    impl IntoProto<proto_def::SwapArgs> for SwapArgs {
        fn into_proto(self) -> proto_def::SwapArgs {
            proto_def::SwapArgs {
                amount_in: self.amount_in,
                expect_amount_out: self.expect_amount_out,
                min_return: self.min_return,
                amounts: self.amounts.to_vec(),
                routes: self
                    .routes
                    .into_iter()
                    .map(|route_vec| proto_def::Route {
                        dexes: route_vec.iter().flat_map(|route| route.dexes.iter().map(|&dex| dex as i32)).collect(),
                        weights: route_vec.iter().flat_map(|route| route.weights.iter().cloned()).collect(),
                    })
                    .collect(),
            }
        }
    }
    use crate::types::SwapEvent;
    impl IntoProto<proto_def::SwapEvent> for SwapEvent {
        fn into_proto(self) -> proto_def::SwapEvent {
            proto_def::SwapEvent {
                dex: self.dex as i32,
                amount_in: self.amount_in,
                amount_out: self.amount_out,
            }
        }
    }
    use crate::types::UpdateOrderEvent;
    impl IntoProto<proto_def::UpdateOrderEvent> for UpdateOrderEvent {
        fn into_proto(self) -> proto_def::UpdateOrderEvent {
            proto_def::UpdateOrderEvent {
                order_id: self.order_id,
                maker: self.maker.to_string(),
                expect_taking_amount: self.expect_taking_amount,
                min_return_amount: self.min_return_amount,
                deadline: self.deadline,
                update_ts: self.update_ts,
                increase_fee: self.increase_fee,
            }
        }
    }
}
