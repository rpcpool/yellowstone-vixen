//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated::types::AggregationEvent,
    instructions::{
        Claim as ClaimIxAccounts, CommissionSolProxySwap as CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapInstructionArgs as CommissionSolProxySwapIxData,
        CommissionSolSwap as CommissionSolSwapIxAccounts,
        CommissionSolSwapInstructionArgs as CommissionSolSwapIxData,
        CommissionSplProxySwap as CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapInstructionArgs as CommissionSplProxySwapIxData,
        CommissionSplSwap as CommissionSplSwapIxAccounts,
        CommissionSplSwapInstructionArgs as CommissionSplSwapIxData,
        CommissionWrapUnwrap as CommissionWrapUnwrapIxAccounts,
        CommissionWrapUnwrapInstructionArgs as CommissionWrapUnwrapIxData,
        CreateTokenAccount as CreateTokenAccountIxAccounts,
        CreateTokenAccountInstructionArgs as CreateTokenAccountIxData,
        CreateTokenAccountWithSeed as CreateTokenAccountWithSeedIxAccounts,
        CreateTokenAccountWithSeedInstructionArgs as CreateTokenAccountWithSeedIxData,
        PlatformFeeSolProxySwapV2 as PlatformFeeSolProxySwapV2IxAccounts,
        PlatformFeeSolProxySwapV2InstructionArgs as PlatformFeeSolProxySwapV2IxData,
        PlatformFeeSolWrapUnwrapV2 as PlatformFeeSolWrapUnwrapV2IxAccounts,
        PlatformFeeSolWrapUnwrapV2InstructionArgs as PlatformFeeSolWrapUnwrapV2IxData,
        PlatformFeeSplProxySwapV2 as PlatformFeeSplProxySwapV2IxAccounts,
        PlatformFeeSplProxySwapV2InstructionArgs as PlatformFeeSplProxySwapV2IxData,
        ProxySwap as ProxySwapIxAccounts, ProxySwapInstructionArgs as ProxySwapIxData,
        Swap as SwapIxAccounts, SwapInstructionArgs as SwapIxData,
        SwapTobV3 as SwapTobV3IxAccounts, SwapTobV3InstructionArgs as SwapTobV3IxData,
        SwapTobV3WithReceiver as SwapTobV3WithReceiverIxAccounts,
        SwapTobV3WithReceiverInstructionArgs as SwapTobV3WithReceiverIxData,
        SwapV3 as SwapV3IxAccounts, SwapV3InstructionArgs as SwapV3IxData,
        WrapUnwrapV3 as WrapUnwrapV3IxAccounts, WrapUnwrapV3InstructionArgs as WrapUnwrapV3IxData,
    },
    ID,
};

/// DexSolana Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum DexSolanaProgramIx {
    Claim(ClaimIxAccounts),
    CommissionSolProxySwap(
        CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSolSwap(
        CommissionSolSwapIxAccounts,
        CommissionSolSwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSplProxySwap(
        CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSplSwap(
        CommissionSplSwapIxAccounts,
        CommissionSplSwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionWrapUnwrap(CommissionWrapUnwrapIxAccounts, CommissionWrapUnwrapIxData),
    CreateTokenAccount(CreateTokenAccountIxAccounts, CreateTokenAccountIxData),
    CreateTokenAccountWithSeed(
        CreateTokenAccountWithSeedIxAccounts,
        CreateTokenAccountWithSeedIxData,
    ),
    PlatformFeeSolProxySwapV2(
        PlatformFeeSolProxySwapV2IxAccounts,
        PlatformFeeSolProxySwapV2IxData,
        Option<AggregationEvent>,
    ),
    PlatformFeeSolWrapUnwrapV2(
        PlatformFeeSolWrapUnwrapV2IxAccounts,
        PlatformFeeSolWrapUnwrapV2IxData,
    ),
    PlatformFeeSplProxySwapV2(
        PlatformFeeSplProxySwapV2IxAccounts,
        PlatformFeeSplProxySwapV2IxData,
        Option<AggregationEvent>,
    ),
    ProxySwap(
        ProxySwapIxAccounts,
        ProxySwapIxData,
        Option<AggregationEvent>,
    ),
    Swap(SwapIxAccounts, SwapIxData, Option<AggregationEvent>),
    SwapTobV3(
        SwapTobV3IxAccounts,
        SwapTobV3IxData,
        Option<AggregationEvent>,
    ),
    SwapTobV3WithReceiver(
        SwapTobV3WithReceiverIxAccounts,
        SwapTobV3WithReceiverIxData,
        Option<AggregationEvent>,
    ),
    SwapV3(SwapV3IxAccounts, SwapV3IxData, Option<AggregationEvent>),
    WrapUnwrapV3(WrapUnwrapV3IxAccounts, WrapUnwrapV3IxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = DexSolanaProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<DexSolanaProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("DexSolana::InstructionParser")
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimIxAccounts {
                    signer: next_account(accounts)?,
                    receiver: next_account(accounts)?,
                    source_token_account: next_program_id_optional_account(accounts)?,
                    destination_token_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_account(accounts)?,
                    token_mint: next_program_id_optional_account(accounts)?,
                    token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                };
                Ok(DexSolanaProgramIx::Claim(ix_accounts))
            },
            [30, 33, 208, 91, 31, 157, 37, 18] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSolProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: CommissionSolProxySwapIxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "CommissionSolProxySwap",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSolProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [81, 128, 134, 73, 114, 73, 45, 94] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSolSwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionSolSwapIxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "CommissionSolSwap",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSolSwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [96, 67, 12, 151, 129, 164, 18, 71] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSplProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: CommissionSplProxySwapIxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "CommissionSplProxySwap",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSplProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [235, 71, 211, 196, 114, 199, 143, 92] | [173, 131, 78, 38, 150, 165, 123, 15] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSplSwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionSplSwapIxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "CommissionSplSwap",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSplSwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [12, 73, 156, 71, 233, 172, 189, 197] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionWrapUnwrapIxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_sol_account: next_account(accounts)?,
                    commission_wsol_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionWrapUnwrapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CommissionWrapUnwrap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [147, 241, 123, 100, 244, 132, 174, 118] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenAccountIxAccounts {
                    payer: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    token_account: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenAccountIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CreateTokenAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [125, 191, 239, 140, 66, 8, 9, 228] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenAccountWithSeedIxAccounts {
                    payer: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    token_account: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenAccountWithSeedIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CreateTokenAccountWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [69, 200, 254, 247, 40, 52, 118, 202] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSolProxySwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSolProxySwapV2IxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "PlatformFeeSolProxySwapV2",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::PlatformFeeSolProxySwapV2(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [196, 172, 152, 92, 60, 186, 64, 227] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSolWrapUnwrapV2IxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_sol_account: next_account(accounts)?,
                    commission_wsol_account: next_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSolWrapUnwrapV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::PlatformFeeSolWrapUnwrapV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [69, 164, 210, 89, 146, 214, 173, 67] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSplProxySwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSplProxySwapV2IxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "PlatformFeeSplProxySwapV2",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::PlatformFeeSplProxySwapV2(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [19, 44, 130, 148, 72, 56, 44, 238] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: ProxySwapIxData = yellowstone_vixen_core::deserialize_checked_swap(
                    ix_data,
                    &ix_discriminator,
                    "ProxySwap",
                    deserialize_checked,
                )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::ProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = yellowstone_vixen_core::deserialize_checked_swap(
                    ix_data,
                    &ix_discriminator,
                    "Swap",
                    deserialize_checked,
                )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::Swap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [14, 191, 44, 246, 142, 225, 224, 157] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapTobV3IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapTobV3IxData = yellowstone_vixen_core::deserialize_checked_swap(
                    ix_data,
                    &ix_discriminator,
                    "SwapTobV3",
                    deserialize_checked,
                )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapTobV3(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [63, 114, 246, 131, 51, 2, 247, 29] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapTobV3WithReceiverIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                    sol_receiver: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapTobV3WithReceiverIxData =
                    yellowstone_vixen_core::deserialize_checked_swap(
                        ix_data,
                        &ix_discriminator,
                        "SwapTobV3WithReceiver",
                        deserialize_checked,
                    )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapTobV3WithReceiver(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [240, 224, 38, 33, 176, 31, 241, 175] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapV3IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapV3IxData = yellowstone_vixen_core::deserialize_checked_swap(
                    ix_data,
                    &ix_discriminator,
                    "SwapV3",
                    deserialize_checked,
                )?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapV3(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [180, 178, 191, 54, 70, 8, 13, 224] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WrapUnwrapV3IxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    authority_pda: next_program_id_optional_account(accounts)?,
                    wsol_sa: next_program_id_optional_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: WrapUnwrapV3IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::WrapUnwrapV3(ix_accounts, de_ix_data))
            },
            // self cpi log
            [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d] => {
                Err(yellowstone_vixen_core::ParseError::Filtered)
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{ClaimIxAccounts, DexSolanaProgramIx, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimIxAccounts> for ClaimIxAccounts {
        fn into_proto(self) -> proto_def::ClaimIxAccounts {
            proto_def::ClaimIxAccounts {
                signer: self.signer.to_string(),
                receiver: self.receiver.to_string(),
                source_token_account: self.source_token_account.map(|p| p.to_string()),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.to_string(),
                token_mint: self.token_mint.map(|p| p.to_string()),
                token_program: self.token_program.map(|p| p.to_string()),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSolProxySwapIxAccounts;
    impl IntoProto<proto_def::CommissionSolProxySwapIxAccounts> for CommissionSolProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSolProxySwapIxAccounts {
            proto_def::CommissionSolProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSolProxySwapIxData;
    impl IntoProto<proto_def::CommissionSolProxySwapIxData> for CommissionSolProxySwapIxData {
        fn into_proto(self) -> proto_def::CommissionSolProxySwapIxData {
            proto_def::CommissionSolProxySwapIxData {
                data: Some(self.data.into_proto()),
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSolSwapIxAccounts;
    impl IntoProto<proto_def::CommissionSolSwapIxAccounts> for CommissionSolSwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSolSwapIxAccounts {
            proto_def::CommissionSolSwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CommissionSolSwapIxData;
    impl IntoProto<proto_def::CommissionSolSwapIxData> for CommissionSolSwapIxData {
        fn into_proto(self) -> proto_def::CommissionSolSwapIxData {
            proto_def::CommissionSolSwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSplProxySwapIxAccounts;
    impl IntoProto<proto_def::CommissionSplProxySwapIxAccounts> for CommissionSplProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSplProxySwapIxAccounts {
            proto_def::CommissionSplProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSplProxySwapIxData;
    impl IntoProto<proto_def::CommissionSplProxySwapIxData> for CommissionSplProxySwapIxData {
        fn into_proto(self) -> proto_def::CommissionSplProxySwapIxData {
            proto_def::CommissionSplProxySwapIxData {
                data: Some(self.data.into_proto()),
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSplSwapIxAccounts;
    impl IntoProto<proto_def::CommissionSplSwapIxAccounts> for CommissionSplSwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSplSwapIxAccounts {
            proto_def::CommissionSplSwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CommissionSplSwapIxData;
    impl IntoProto<proto_def::CommissionSplSwapIxData> for CommissionSplSwapIxData {
        fn into_proto(self) -> proto_def::CommissionSplSwapIxData {
            proto_def::CommissionSplSwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionWrapUnwrapIxAccounts;
    impl IntoProto<proto_def::CommissionWrapUnwrapIxAccounts> for CommissionWrapUnwrapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionWrapUnwrapIxAccounts {
            proto_def::CommissionWrapUnwrapIxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_sol_account: self.commission_sol_account.to_string(),
                commission_wsol_account: self.commission_wsol_account.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CommissionWrapUnwrapIxData;
    impl IntoProto<proto_def::CommissionWrapUnwrapIxData> for CommissionWrapUnwrapIxData {
        fn into_proto(self) -> proto_def::CommissionWrapUnwrapIxData {
            proto_def::CommissionWrapUnwrapIxData {
                amount_in: self.amount_in,
                wrap_direction: self.wrap_direction,
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CreateTokenAccountIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountIxAccounts> for CreateTokenAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxAccounts {
            proto_def::CreateTokenAccountIxAccounts {
                payer: self.payer.to_string(),
                owner: self.owner.to_string(),
                token_account: self.token_account.to_string(),
                token_mint: self.token_mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxData;
    impl IntoProto<proto_def::CreateTokenAccountIxData> for CreateTokenAccountIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxData {
            proto_def::CreateTokenAccountIxData {
                bump: self.bump.into(),
            }
        }
    }
    use super::CreateTokenAccountWithSeedIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountWithSeedIxAccounts>
        for CreateTokenAccountWithSeedIxAccounts
    {
        fn into_proto(self) -> proto_def::CreateTokenAccountWithSeedIxAccounts {
            proto_def::CreateTokenAccountWithSeedIxAccounts {
                payer: self.payer.to_string(),
                owner: self.owner.to_string(),
                token_account: self.token_account.to_string(),
                token_mint: self.token_mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountWithSeedIxData;
    impl IntoProto<proto_def::CreateTokenAccountWithSeedIxData> for CreateTokenAccountWithSeedIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountWithSeedIxData {
            proto_def::CreateTokenAccountWithSeedIxData {
                bump: self.bump.into(),
                seed: self.seed,
            }
        }
    }
    use super::PlatformFeeSolProxySwapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSolProxySwapV2IxAccounts>
        for PlatformFeeSolProxySwapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSolProxySwapV2IxAccounts {
            proto_def::PlatformFeeSolProxySwapV2IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::PlatformFeeSolProxySwapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSolProxySwapV2IxData> for PlatformFeeSolProxySwapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSolProxySwapV2IxData {
            proto_def::PlatformFeeSolProxySwapV2IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                trim_rate: self.trim_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::PlatformFeeSolWrapUnwrapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts>
        for PlatformFeeSolWrapUnwrapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts {
            proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_sol_account: self.commission_sol_account.to_string(),
                commission_wsol_account: self.commission_wsol_account.to_string(),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::PlatformFeeSolWrapUnwrapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSolWrapUnwrapV2IxData> for PlatformFeeSolWrapUnwrapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSolWrapUnwrapV2IxData {
            proto_def::PlatformFeeSolWrapUnwrapV2IxData {
                amount_in: self.amount_in,
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                order_id: self.order_id,
            }
        }
    }
    use super::PlatformFeeSplProxySwapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSplProxySwapV2IxAccounts>
        for PlatformFeeSplProxySwapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSplProxySwapV2IxAccounts {
            proto_def::PlatformFeeSplProxySwapV2IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::PlatformFeeSplProxySwapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSplProxySwapV2IxData> for PlatformFeeSplProxySwapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSplProxySwapV2IxData {
            proto_def::PlatformFeeSplProxySwapV2IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                trim_rate: self.trim_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::ProxySwapIxAccounts;
    impl IntoProto<proto_def::ProxySwapIxAccounts> for ProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::ProxySwapIxAccounts {
            proto_def::ProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::ProxySwapIxData;
    impl IntoProto<proto_def::ProxySwapIxData> for ProxySwapIxData {
        fn into_proto(self) -> proto_def::ProxySwapIxData {
            proto_def::ProxySwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapTobV3IxAccounts;
    impl IntoProto<proto_def::SwapTobV3IxAccounts> for SwapTobV3IxAccounts {
        fn into_proto(self) -> proto_def::SwapTobV3IxAccounts {
            proto_def::SwapTobV3IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapTobV3IxData;
    impl IntoProto<proto_def::SwapTobV3IxData> for SwapTobV3IxData {
        fn into_proto(self) -> proto_def::SwapTobV3IxData {
            proto_def::SwapTobV3IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                trim_rate: self.trim_rate.into(),
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapTobV3WithReceiverIxAccounts;
    impl IntoProto<proto_def::SwapTobV3WithReceiverIxAccounts> for SwapTobV3WithReceiverIxAccounts {
        fn into_proto(self) -> proto_def::SwapTobV3WithReceiverIxAccounts {
            proto_def::SwapTobV3WithReceiverIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
                sol_receiver: self.sol_receiver.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapTobV3WithReceiverIxData;
    impl IntoProto<proto_def::SwapTobV3WithReceiverIxData> for SwapTobV3WithReceiverIxData {
        fn into_proto(self) -> proto_def::SwapTobV3WithReceiverIxData {
            proto_def::SwapTobV3WithReceiverIxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                trim_rate: self.trim_rate.into(),
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapV3IxAccounts;
    impl IntoProto<proto_def::SwapV3IxAccounts> for SwapV3IxAccounts {
        fn into_proto(self) -> proto_def::SwapV3IxAccounts {
            proto_def::SwapV3IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapV3IxData;
    impl IntoProto<proto_def::SwapV3IxData> for SwapV3IxData {
        fn into_proto(self) -> proto_def::SwapV3IxData {
            proto_def::SwapV3IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::WrapUnwrapV3IxAccounts;
    impl IntoProto<proto_def::WrapUnwrapV3IxAccounts> for WrapUnwrapV3IxAccounts {
        fn into_proto(self) -> proto_def::WrapUnwrapV3IxAccounts {
            proto_def::WrapUnwrapV3IxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                authority_pda: self.authority_pda.map(|p| p.to_string()),
                wsol_sa: self.wsol_sa.map(|p| p.to_string()),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::WrapUnwrapV3IxData;
    impl IntoProto<proto_def::WrapUnwrapV3IxData> for WrapUnwrapV3IxData {
        fn into_proto(self) -> proto_def::WrapUnwrapV3IxData {
            proto_def::WrapUnwrapV3IxData {
                order_id: self.order_id,
                amount_in: self.amount_in,
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate.into(),
                tob: self.tob,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for DexSolanaProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                DexSolanaProgramIx::Claim(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Claim(proto_def::ClaimIx {
                        accounts: Some(acc.into_proto()),
                    })),
                },
                DexSolanaProgramIx::CommissionSolProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSolProxySwap(
                        proto_def::CommissionSolProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSolSwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSolSwap(
                        proto_def::CommissionSolSwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSplProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSplProxySwap(
                        proto_def::CommissionSplProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSplSwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSplSwap(
                        proto_def::CommissionSplSwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionWrapUnwrap(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionWrapUnwrap(
                        proto_def::CommissionWrapUnwrapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CreateTokenAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenAccount(
                        proto_def::CreateTokenAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CreateTokenAccountWithSeed(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::CreateTokenAccountWithSeed(
                                proto_def::CreateTokenAccountWithSeedIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSolProxySwapV2(acc, data, _) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::PlatformFeeSolProxySwapV2(
                            proto_def::PlatformFeeSolProxySwapV2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSolWrapUnwrapV2(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::PlatformFeeSolWrapUnwrapV2(
                                proto_def::PlatformFeeSolWrapUnwrapV2Ix {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSplProxySwapV2(acc, data, _) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::PlatformFeeSplProxySwapV2(
                            proto_def::PlatformFeeSplProxySwapV2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DexSolanaProgramIx::ProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ProxySwap(
                        proto_def::ProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::Swap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                DexSolanaProgramIx::SwapTobV3(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapTobV3(
                        proto_def::SwapTobV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::SwapTobV3WithReceiver(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapTobV3WithReceiver(
                        proto_def::SwapTobV3WithReceiverIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::SwapV3(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapV3(
                        proto_def::SwapV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::WrapUnwrapV3(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WrapUnwrapV3(
                        proto_def::WrapUnwrapV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use yellowstone_vixen_core::{
        instruction::{InstructionShared, InstructionUpdate},
        Pubkey,
    };

    use super::*;

    // Helper function to create a Pubkey from a base58 string
    fn pubkey_from_str(s: &str) -> Pubkey { s.parse().unwrap() }

    #[test]
    fn test_swap_instruction_without_order_id() {
        // Test parsing old version Swap instruction (without order_id field)
        // This is the actual data from the error log that was failing
        let accounts = vec![
            pubkey_from_str("11111111111111111111111111111111"), // payer
            pubkey_from_str("11111111111111111111111111111111"), // source_token_account
            pubkey_from_str("11111111111111111111111111111111"), // destination_token_account
            pubkey_from_str("11111111111111111111111111111111"), // source_mint
            pubkey_from_str("11111111111111111111111111111111"), // destination_mint
        ];

        // Swap discriminator: [248, 198, 158, 145, 225, 117, 135, 200]
        let mut data = vec![248, 198, 158, 145, 225, 117, 135, 200];

        // Instruction data from error log (54 bytes, WITHOUT order_id)
        let ix_data_hex = "d676b0d200000000a37e7c1e040000006a44ab0e0400000001000000d676b0d2000000000100000001000000010000000a0100000064";
        data.extend_from_slice(&hex::decode(ix_data_hex).unwrap());

        let ix_update = InstructionUpdate {
            accounts: accounts.clone(),
            data,
            program: pubkey_from_str("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), // OKX DEX program
            parent_program: None,
            inner: vec![],
            shared: Arc::new(InstructionShared {
                slot: 0,
                signature: vec![],
                is_vote: false,
                txn_index: 0,
                err: None,
                fee: 0,
                pre_balances: vec![],
                post_balances: vec![],
                pre_token_balances: vec![],
                post_token_balances: vec![],
                log_messages: vec![],
                rewards: vec![],
                compute_units_consumed: None,
                recent_blockhash: vec![],
                accounts: Default::default(),
                message_header: Default::default(),
                created_token_accounts: vec![],
            }),
            ix_index: 0,
            parsed_logs: vec![],
        };

        let result = InstructionParser::parse_impl(&ix_update);
        assert!(
            result.is_ok(),
            "Should successfully parse Swap instruction without order_id"
        );

        if let Ok(DexSolanaProgramIx::Swap(_accounts, ix_data, _event)) = result {
            // Verify that order_id defaults to 0 for old version
            assert_eq!(ix_data.order_id, 0, "order_id should default to 0");

            // Verify SwapArgs data is correctly parsed
            assert_eq!(ix_data.data.amount_in, 3_534_780_118);
            assert_eq!(ix_data.data.expect_amount_out, 17_691_344_547);
            assert_eq!(ix_data.data.min_return, 17_425_974_378);
            assert_eq!(ix_data.data.amounts.len(), 1);
            assert_eq!(ix_data.data.amounts[0], 3_534_780_118);
            assert_eq!(ix_data.data.routes.len(), 1);
            assert_eq!(ix_data.data.routes[0].len(), 1);
        } else {
            panic!("Expected Swap instruction");
        }
    }

    #[test]
    fn test_swap_instruction_with_order_id() {
        // Test parsing new version Swap instruction (with order_id field)
        let accounts = vec![
            pubkey_from_str("11111111111111111111111111111111"), // payer
            pubkey_from_str("11111111111111111111111111111111"), // source_token_account
            pubkey_from_str("11111111111111111111111111111111"), // destination_token_account
            pubkey_from_str("11111111111111111111111111111111"), // source_mint
            pubkey_from_str("11111111111111111111111111111111"), // destination_mint
        ];

        // Swap discriminator: [248, 198, 158, 145, 225, 117, 135, 200]
        let mut data = vec![248, 198, 158, 145, 225, 117, 135, 200];

        // Instruction data (54 bytes) + order_id (8 bytes) = 62 bytes
        let ix_data_hex = "d676b0d200000000a37e7c1e040000006a44ab0e0400000001000000d676b0d2000000000100000001000000010000000a0100000064";
        data.extend_from_slice(&hex::decode(ix_data_hex).unwrap());

        // Add order_id: 12345678
        data.extend_from_slice(&12345678u64.to_le_bytes());

        let ix_update = InstructionUpdate {
            accounts: accounts.clone(),
            data,
            program: pubkey_from_str("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),
            parent_program: None,
            inner: vec![],
            shared: Arc::new(InstructionShared {
                slot: 0,
                signature: vec![],
                is_vote: false,
                txn_index: 0,
                err: None,
                fee: 0,
                pre_balances: vec![],
                post_balances: vec![],
                pre_token_balances: vec![],
                post_token_balances: vec![],
                log_messages: vec![],
                rewards: vec![],
                compute_units_consumed: None,
                recent_blockhash: vec![],
                accounts: Default::default(),
                message_header: Default::default(),
                created_token_accounts: vec![],
            }),
            ix_index: 0,
            parsed_logs: vec![],
        };

        let result = InstructionParser::parse_impl(&ix_update);
        assert!(
            result.is_ok(),
            "Should successfully parse Swap instruction with order_id"
        );

        if let Ok(DexSolanaProgramIx::Swap(_accounts, ix_data, _event)) = result {
            // Verify that order_id is correctly parsed
            assert_eq!(ix_data.order_id, 12345678, "order_id should be 12345678");

            // Verify SwapArgs data is correctly parsed
            assert_eq!(ix_data.data.amount_in, 3_534_780_118);
            assert_eq!(ix_data.data.expect_amount_out, 17_691_344_547);
            assert_eq!(ix_data.data.min_return, 17_425_974_378);
        } else {
            panic!("Expected Swap instruction");
        }
    }
}
