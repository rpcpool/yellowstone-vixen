//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::deserialize_checked;

use crate::instructions::{
    ActivateGame as ActivateGameIxAccounts, ActivateGameInstructionArgs as ActivateGameIxData,
    AddAuthorizedProgram as AddAuthorizedProgramIxAccounts,
    AddAuthorizedProgramInstructionArgs as AddAuthorizedProgramIxData,
    AddOperator as AddOperatorIxAccounts, AddOperatorInstructionArgs as AddOperatorIxData,
    CancelBet as CancelBetIxAccounts, CancelBetInstructionArgs as CancelBetIxData,
    CancelGame as CancelGameIxAccounts, CancelGameInstructionArgs as CancelGameIxData,
    ClaimPayout as ClaimPayoutIxAccounts, ClaimPayoutInstructionArgs as ClaimPayoutIxData,
    CloseBetting as CloseBettingIxAccounts, CloseBettingInstructionArgs as CloseBettingIxData,
    CreateGame as CreateGameIxAccounts, CreateGameInstructionArgs as CreateGameIxData,
    GetPayouts as GetPayoutsIxAccounts, GetPayoutsInstructionArgs as GetPayoutsIxData,
    InitializeAuthorizedPrograms as InitializeAuthorizedProgramsIxAccounts,
    InitializeAuthorizedProgramsInstructionArgs as InitializeAuthorizedProgramsIxData,
    PlaceBet as PlaceBetIxAccounts, PlaceBetInstructionArgs as PlaceBetIxData,
    RemoveAuthorizedProgram as RemoveAuthorizedProgramIxAccounts,
    RemoveAuthorizedProgramInstructionArgs as RemoveAuthorizedProgramIxData,
    RemoveOperator as RemoveOperatorIxAccounts,
    RemoveOperatorInstructionArgs as RemoveOperatorIxData, SettleGame as SettleGameIxAccounts,
    SettleGameInstructionArgs as SettleGameIxData, UpdateAdmin as UpdateAdminIxAccounts,
    UpdateAdminInstructionArgs as UpdateAdminIxData, UpdateFeeConfig as UpdateFeeConfigIxAccounts,
    UpdateFeeConfigInstructionArgs as UpdateFeeConfigIxData,
    UpdateLiquidityPoolProgram as UpdateLiquidityPoolProgramIxAccounts,
    UpdateLiquidityPoolProgramInstructionArgs as UpdateLiquidityPoolProgramIxData,
};
use crate::ID;

/// Settlement Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum SettlementProgramIx {
    ActivateGame(ActivateGameIxAccounts, ActivateGameIxData),
    AddAuthorizedProgram(AddAuthorizedProgramIxAccounts, AddAuthorizedProgramIxData),
    AddOperator(AddOperatorIxAccounts, AddOperatorIxData),
    CancelBet(CancelBetIxAccounts, CancelBetIxData),
    CancelGame(CancelGameIxAccounts, CancelGameIxData),
    ClaimPayout(ClaimPayoutIxAccounts, ClaimPayoutIxData),
    CloseBetting(CloseBettingIxAccounts, CloseBettingIxData),
    CreateGame(CreateGameIxAccounts, CreateGameIxData),
    GetPayouts(GetPayoutsIxAccounts, GetPayoutsIxData),
    InitializeAuthorizedPrograms(
        InitializeAuthorizedProgramsIxAccounts,
        InitializeAuthorizedProgramsIxData,
    ),
    PlaceBet(PlaceBetIxAccounts, PlaceBetIxData),
    RemoveAuthorizedProgram(
        RemoveAuthorizedProgramIxAccounts,
        RemoveAuthorizedProgramIxData,
    ),
    RemoveOperator(RemoveOperatorIxAccounts, RemoveOperatorIxData),
    SettleGame(SettleGameIxAccounts, SettleGameIxData),
    UpdateAdmin(UpdateAdminIxAccounts, UpdateAdminIxData),
    UpdateFeeConfig(UpdateFeeConfigIxAccounts, UpdateFeeConfigIxData),
    UpdateLiquidityPoolProgram(
        UpdateLiquidityPoolProgramIxAccounts,
        UpdateLiquidityPoolProgramIxData,
    ),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;

    #[cfg(not(feature = "shared-data"))]
    type Output = SettlementProgramIx;

    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<SettlementProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "Settlement::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [166, 184, 159, 118, 22, 67, 88, 37] => {
                let expected_accounts_len = 18;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ActivateGameIxAccounts {
                    game_registry: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    game_keeper_signer: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    game_keeper_program: next_account(accounts)?,
                    game_randomness: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    gk_global_config: next_account(accounts)?,
                    gk_global_config_program: next_account(accounts)?,
                    settlement_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: ActivateGameIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::ActivateGame(ix_accounts, de_ix_data))
            },
            [80, 106, 127, 205, 217, 53, 202, 202] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddAuthorizedProgramIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: AddAuthorizedProgramIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::AddAuthorizedProgram(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [149, 142, 187, 68, 33, 250, 87, 105] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddOperatorIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: AddOperatorIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::AddOperator(ix_accounts, de_ix_data))
            },
            [17, 248, 130, 128, 153, 227, 231, 9] => {
                let expected_accounts_len = 20;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CancelBetIxAccounts {
                    game_registry: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    player_token_account: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    token_pool: next_program_id_optional_account(accounts)?,
                    pool_exposure: next_program_id_optional_account(accounts)?,
                    liquidity_pool_program: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    player: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    bet_tracker: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CancelBetIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::CancelBet(ix_accounts, de_ix_data))
            },
            [121, 194, 154, 118, 103, 235, 149, 52] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CancelGameIxAccounts {
                    game_registry: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    game_keeper_program: next_program_id_optional_account(accounts)?,
                    game_randomness: next_program_id_optional_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CancelGameIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::CancelGame(ix_accounts, de_ix_data))
            },
            [127, 240, 132, 62, 227, 198, 146, 133] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimPayoutIxAccounts {
                    game_settlement: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    winner_token_account: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    global_entropy: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    claimer: next_account(accounts)?,
                };
                let de_ix_data: ClaimPayoutIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::ClaimPayout(ix_accounts, de_ix_data))
            },
            [183, 243, 76, 1, 242, 130, 138, 58] => {
                let expected_accounts_len = 24;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseBettingIxAccounts {
                    game_registry: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    bet_tracker: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    lp_program_config: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    token_pool: next_account(accounts)?,
                    pool_exposure: next_account(accounts)?,
                    vault: next_account(accounts)?,
                    lp_global_config: next_account(accounts)?,
                    liquidity_pool_program: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    global_entropy: next_account(accounts)?,
                    game_keeper_program: next_account(accounts)?,
                    game_randomness: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CloseBettingIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::CloseBetting(ix_accounts, de_ix_data))
            },
            [124, 69, 75, 66, 184, 220, 72, 206] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateGameIxAccounts {
                    game_registry: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    game_program_account: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    game_settlement: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CreateGameIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::CreateGame(ix_accounts, de_ix_data))
            },
            [19, 115, 125, 97, 44, 130, 166, 164] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GetPayoutsIxAccounts {
                    game_registry: next_account(accounts)?,
                    game_settlement: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: GetPayoutsIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::GetPayouts(ix_accounts, de_ix_data))
            },
            [169, 252, 192, 189, 35, 61, 191, 45] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeAuthorizedProgramsIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializeAuthorizedProgramsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::InitializeAuthorizedPrograms(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [222, 62, 67, 220, 63, 166, 126, 33] => {
                let expected_accounts_len = 20;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlaceBetIxAccounts {
                    game_registry: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    player_token_account: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    player: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    bet_tracker: next_account(accounts)?,
                    game_keeper_program: next_account(accounts)?,
                    game_randomness: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: PlaceBetIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::PlaceBet(ix_accounts, de_ix_data))
            },
            [70, 182, 172, 234, 229, 156, 205, 245] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveAuthorizedProgramIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: RemoveAuthorizedProgramIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::RemoveAuthorizedProgram(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [84, 183, 126, 251, 137, 150, 214, 134] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveOperatorIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: RemoveOperatorIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::RemoveOperator(ix_accounts, de_ix_data))
            },
            [96, 54, 24, 189, 239, 198, 86, 29] => {
                let expected_accounts_len = 19;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SettleGameIxAccounts {
                    operator: next_account(accounts)?,
                    game_registry: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    game_settlement: next_account(accounts)?,
                    bet_tracker: next_account(accounts)?,
                    game_randomness: next_account(accounts)?,
                    game_keeper_signer: next_account(accounts)?,
                    authorized_programs: next_account(accounts)?,
                    game_program: next_account(accounts)?,
                    game_account: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    game_keeper_program: next_account(accounts)?,
                    rando_program: next_account(accounts)?,
                    randomness_state: next_account(accounts)?,
                    slot_hashes: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    instruction_sysvar: next_account(accounts)?,
                };
                let de_ix_data: SettleGameIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::SettleGame(ix_accounts, de_ix_data))
            },
            [161, 176, 40, 213, 60, 184, 179, 228] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateAdminIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    current_admin: next_account(accounts)?,
                };
                let de_ix_data: UpdateAdminIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::UpdateAdmin(ix_accounts, de_ix_data))
            },
            [104, 184, 103, 242, 88, 151, 107, 20] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateFeeConfigIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: UpdateFeeConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::UpdateFeeConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [48, 62, 102, 41, 238, 208, 42, 8] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateLiquidityPoolProgramIxAccounts {
                    authorized_programs: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: UpdateLiquidityPoolProgramIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(SettlementProgramIx::UpdateLiquidityPoolProgram(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use super::{InstructionParser, SettlementProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    use yellowstone_vixen_core::proto::ParseProto;

    use super::ActivateGameIxAccounts;
    impl IntoProto<proto_def::ActivateGameIxAccounts> for ActivateGameIxAccounts {
        fn into_proto(self) -> proto_def::ActivateGameIxAccounts {
            proto_def::ActivateGameIxAccounts {
                game_registry: self.game_registry.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                game_keeper_signer: self.game_keeper_signer.to_string(),
                operator: self.operator.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                game_keeper_program: self.game_keeper_program.to_string(),
                game_randomness: self.game_randomness.to_string(),
                rando_program: self.rando_program.to_string(),
                gk_global_config: self.gk_global_config.to_string(),
                gk_global_config_program: self.gk_global_config_program.to_string(),
                settlement_program: self.settlement_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ActivateGameIxData;
    impl IntoProto<proto_def::ActivateGameIxData> for ActivateGameIxData {
        fn into_proto(self) -> proto_def::ActivateGameIxData {
            proto_def::ActivateGameIxData {
                game_id: self.game_id,
                house_commitment: self
                    .house_commitment
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
            }
        }
    }
    use super::AddAuthorizedProgramIxAccounts;
    impl IntoProto<proto_def::AddAuthorizedProgramIxAccounts> for AddAuthorizedProgramIxAccounts {
        fn into_proto(self) -> proto_def::AddAuthorizedProgramIxAccounts {
            proto_def::AddAuthorizedProgramIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::AddAuthorizedProgramIxData;
    impl IntoProto<proto_def::AddAuthorizedProgramIxData> for AddAuthorizedProgramIxData {
        fn into_proto(self) -> proto_def::AddAuthorizedProgramIxData {
            proto_def::AddAuthorizedProgramIxData {
                program_id: self.program_id.to_string(),
            }
        }
    }
    use super::AddOperatorIxAccounts;
    impl IntoProto<proto_def::AddOperatorIxAccounts> for AddOperatorIxAccounts {
        fn into_proto(self) -> proto_def::AddOperatorIxAccounts {
            proto_def::AddOperatorIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::AddOperatorIxData;
    impl IntoProto<proto_def::AddOperatorIxData> for AddOperatorIxData {
        fn into_proto(self) -> proto_def::AddOperatorIxData {
            proto_def::AddOperatorIxData {
                operator: self.operator.to_string(),
            }
        }
    }
    use super::CancelBetIxAccounts;
    impl IntoProto<proto_def::CancelBetIxAccounts> for CancelBetIxAccounts {
        fn into_proto(self) -> proto_def::CancelBetIxAccounts {
            proto_def::CancelBetIxAccounts {
                game_registry: self.game_registry.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_mint: self.token_mint.to_string(),
                player_token_account: self.player_token_account.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                token_pool: self.token_pool.map(|p| p.to_string()),
                pool_exposure: self.pool_exposure.map(|p| p.to_string()),
                liquidity_pool_program: self.liquidity_pool_program.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                player: self.player.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                bet_tracker: self.bet_tracker.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CancelBetIxData;
    impl IntoProto<proto_def::CancelBetIxData> for CancelBetIxData {
        fn into_proto(self) -> proto_def::CancelBetIxData {
            proto_def::CancelBetIxData {
                game_id: self.game_id,
                bet_id: self.bet_id,
            }
        }
    }
    use super::CancelGameIxAccounts;
    impl IntoProto<proto_def::CancelGameIxAccounts> for CancelGameIxAccounts {
        fn into_proto(self) -> proto_def::CancelGameIxAccounts {
            proto_def::CancelGameIxAccounts {
                game_registry: self.game_registry.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                operator: self.operator.to_string(),
                game_keeper_program: self.game_keeper_program.map(|p| p.to_string()),
                game_randomness: self.game_randomness.map(|p| p.to_string()),
                authorized_programs: self.authorized_programs.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CancelGameIxData;
    impl IntoProto<proto_def::CancelGameIxData> for CancelGameIxData {
        fn into_proto(self) -> proto_def::CancelGameIxData {
            proto_def::CancelGameIxData {
                game_id: self.game_id,
            }
        }
    }
    use super::ClaimPayoutIxAccounts;
    impl IntoProto<proto_def::ClaimPayoutIxAccounts> for ClaimPayoutIxAccounts {
        fn into_proto(self) -> proto_def::ClaimPayoutIxAccounts {
            proto_def::ClaimPayoutIxAccounts {
                game_settlement: self.game_settlement.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                winner_token_account: self.winner_token_account.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                rando_program: self.rando_program.to_string(),
                global_entropy: self.global_entropy.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                token_program: self.token_program.to_string(),
                claimer: self.claimer.to_string(),
            }
        }
    }
    use super::ClaimPayoutIxData;
    impl IntoProto<proto_def::ClaimPayoutIxData> for ClaimPayoutIxData {
        fn into_proto(self) -> proto_def::ClaimPayoutIxData {
            proto_def::ClaimPayoutIxData {
                game_id: self.game_id,
                payout_index: self.payout_index,
            }
        }
    }
    use super::CloseBettingIxAccounts;
    impl IntoProto<proto_def::CloseBettingIxAccounts> for CloseBettingIxAccounts {
        fn into_proto(self) -> proto_def::CloseBettingIxAccounts {
            proto_def::CloseBettingIxAccounts {
                game_registry: self.game_registry.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                bet_tracker: self.bet_tracker.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                lp_program_config: self.lp_program_config.to_string(),
                global_config: self.global_config.to_string(),
                token_pool: self.token_pool.to_string(),
                pool_exposure: self.pool_exposure.to_string(),
                vault: self.vault.to_string(),
                lp_global_config: self.lp_global_config.to_string(),
                liquidity_pool_program: self.liquidity_pool_program.to_string(),
                token_mint: self.token_mint.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                operator: self.operator.to_string(),
                rando_program: self.rando_program.to_string(),
                global_entropy: self.global_entropy.to_string(),
                game_keeper_program: self.game_keeper_program.to_string(),
                game_randomness: self.game_randomness.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CloseBettingIxData;
    impl IntoProto<proto_def::CloseBettingIxData> for CloseBettingIxData {
        fn into_proto(self) -> proto_def::CloseBettingIxData {
            proto_def::CloseBettingIxData {
                game_id: self.game_id,
            }
        }
    }
    use super::CreateGameIxAccounts;
    impl IntoProto<proto_def::CreateGameIxAccounts> for CreateGameIxAccounts {
        fn into_proto(self) -> proto_def::CreateGameIxAccounts {
            proto_def::CreateGameIxAccounts {
                game_registry: self.game_registry.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                game_program_account: self.game_program_account.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                token_mint: self.token_mint.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                game_settlement: self.game_settlement.to_string(),
                creator: self.creator.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CreateGameIxData;
    impl IntoProto<proto_def::CreateGameIxData> for CreateGameIxData {
        fn into_proto(self) -> proto_def::CreateGameIxData {
            proto_def::CreateGameIxData {
                operator: self.operator.to_string(),
                game_config_data: self
                    .game_config_data
                    .into_iter()
                    .map(|x| x as u32)
                    .collect(),
                game_id: self.game_id,
                affiliate: self.affiliate.map(|x| x.to_string()),
            }
        }
    }
    use super::GetPayoutsIxAccounts;
    impl IntoProto<proto_def::GetPayoutsIxAccounts> for GetPayoutsIxAccounts {
        fn into_proto(self) -> proto_def::GetPayoutsIxAccounts {
            proto_def::GetPayoutsIxAccounts {
                game_registry: self.game_registry.to_string(),
                game_settlement: self.game_settlement.map(|p| p.to_string()),
            }
        }
    }
    use super::GetPayoutsIxData;
    impl IntoProto<proto_def::GetPayoutsIxData> for GetPayoutsIxData {
        fn into_proto(self) -> proto_def::GetPayoutsIxData {
            proto_def::GetPayoutsIxData {
                game_id: self.game_id,
            }
        }
    }
    use super::InitializeAuthorizedProgramsIxAccounts;
    impl IntoProto<proto_def::InitializeAuthorizedProgramsIxAccounts>
        for InitializeAuthorizedProgramsIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializeAuthorizedProgramsIxAccounts {
            proto_def::InitializeAuthorizedProgramsIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeAuthorizedProgramsIxData;
    impl IntoProto<proto_def::InitializeAuthorizedProgramsIxData>
        for InitializeAuthorizedProgramsIxData
    {
        fn into_proto(self) -> proto_def::InitializeAuthorizedProgramsIxData {
            proto_def::InitializeAuthorizedProgramsIxData {
                initial_programs: self
                    .initial_programs
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                liquidity_pool_program_id: self.liquidity_pool_program_id.to_string(),
                game_keeper_program_id: self.game_keeper_program_id.to_string(),
                protocol_fee_account: self.protocol_fee_account.to_string(),
                max_operators: self.max_operators,
            }
        }
    }
    use super::PlaceBetIxAccounts;
    impl IntoProto<proto_def::PlaceBetIxAccounts> for PlaceBetIxAccounts {
        fn into_proto(self) -> proto_def::PlaceBetIxAccounts {
            proto_def::PlaceBetIxAccounts {
                game_registry: self.game_registry.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_mint: self.token_mint.to_string(),
                player_token_account: self.player_token_account.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                player: self.player.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                bet_tracker: self.bet_tracker.to_string(),
                game_keeper_program: self.game_keeper_program.to_string(),
                game_randomness: self.game_randomness.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::PlaceBetIxData;
    impl IntoProto<proto_def::PlaceBetIxData> for PlaceBetIxData {
        fn into_proto(self) -> proto_def::PlaceBetIxData {
            proto_def::PlaceBetIxData {
                game_id: self.game_id,
                bet_amount: self.bet_amount,
                bet_data: self.bet_data.into_iter().map(|x| x as u32).collect(),
                bet_id: self.bet_id,
            }
        }
    }
    use super::RemoveAuthorizedProgramIxAccounts;
    impl IntoProto<proto_def::RemoveAuthorizedProgramIxAccounts> for RemoveAuthorizedProgramIxAccounts {
        fn into_proto(self) -> proto_def::RemoveAuthorizedProgramIxAccounts {
            proto_def::RemoveAuthorizedProgramIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::RemoveAuthorizedProgramIxData;
    impl IntoProto<proto_def::RemoveAuthorizedProgramIxData> for RemoveAuthorizedProgramIxData {
        fn into_proto(self) -> proto_def::RemoveAuthorizedProgramIxData {
            proto_def::RemoveAuthorizedProgramIxData {
                program_id: self.program_id.to_string(),
            }
        }
    }
    use super::RemoveOperatorIxAccounts;
    impl IntoProto<proto_def::RemoveOperatorIxAccounts> for RemoveOperatorIxAccounts {
        fn into_proto(self) -> proto_def::RemoveOperatorIxAccounts {
            proto_def::RemoveOperatorIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::RemoveOperatorIxData;
    impl IntoProto<proto_def::RemoveOperatorIxData> for RemoveOperatorIxData {
        fn into_proto(self) -> proto_def::RemoveOperatorIxData {
            proto_def::RemoveOperatorIxData {
                operator: self.operator.to_string(),
            }
        }
    }
    use super::SettleGameIxAccounts;
    impl IntoProto<proto_def::SettleGameIxAccounts> for SettleGameIxAccounts {
        fn into_proto(self) -> proto_def::SettleGameIxAccounts {
            proto_def::SettleGameIxAccounts {
                operator: self.operator.to_string(),
                game_registry: self.game_registry.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                game_settlement: self.game_settlement.to_string(),
                bet_tracker: self.bet_tracker.to_string(),
                game_randomness: self.game_randomness.to_string(),
                game_keeper_signer: self.game_keeper_signer.to_string(),
                authorized_programs: self.authorized_programs.to_string(),
                game_program: self.game_program.to_string(),
                game_account: self.game_account.to_string(),
                global_config: self.global_config.to_string(),
                game_keeper_program: self.game_keeper_program.to_string(),
                rando_program: self.rando_program.to_string(),
                randomness_state: self.randomness_state.to_string(),
                slot_hashes: self.slot_hashes.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                instruction_sysvar: self.instruction_sysvar.to_string(),
            }
        }
    }
    use super::SettleGameIxData;
    impl IntoProto<proto_def::SettleGameIxData> for SettleGameIxData {
        fn into_proto(self) -> proto_def::SettleGameIxData {
            proto_def::SettleGameIxData {
                game_id: self.game_id,
                num_payouts: self.num_payouts,
                house_nonce: self.house_nonce.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::UpdateAdminIxAccounts;
    impl IntoProto<proto_def::UpdateAdminIxAccounts> for UpdateAdminIxAccounts {
        fn into_proto(self) -> proto_def::UpdateAdminIxAccounts {
            proto_def::UpdateAdminIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                current_admin: self.current_admin.to_string(),
            }
        }
    }
    use super::UpdateAdminIxData;
    impl IntoProto<proto_def::UpdateAdminIxData> for UpdateAdminIxData {
        fn into_proto(self) -> proto_def::UpdateAdminIxData {
            proto_def::UpdateAdminIxData {
                new_admin: self.new_admin.to_string(),
            }
        }
    }
    use super::UpdateFeeConfigIxAccounts;
    impl IntoProto<proto_def::UpdateFeeConfigIxAccounts> for UpdateFeeConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateFeeConfigIxAccounts {
            proto_def::UpdateFeeConfigIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::UpdateFeeConfigIxData;
    impl IntoProto<proto_def::UpdateFeeConfigIxData> for UpdateFeeConfigIxData {
        fn into_proto(self) -> proto_def::UpdateFeeConfigIxData {
            proto_def::UpdateFeeConfigIxData {
                new_fee_config: Some(self.new_fee_config.into_proto()),
            }
        }
    }
    use super::UpdateLiquidityPoolProgramIxAccounts;
    impl IntoProto<proto_def::UpdateLiquidityPoolProgramIxAccounts>
        for UpdateLiquidityPoolProgramIxAccounts
    {
        fn into_proto(self) -> proto_def::UpdateLiquidityPoolProgramIxAccounts {
            proto_def::UpdateLiquidityPoolProgramIxAccounts {
                authorized_programs: self.authorized_programs.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::UpdateLiquidityPoolProgramIxData;
    impl IntoProto<proto_def::UpdateLiquidityPoolProgramIxData> for UpdateLiquidityPoolProgramIxData {
        fn into_proto(self) -> proto_def::UpdateLiquidityPoolProgramIxData {
            proto_def::UpdateLiquidityPoolProgramIxData {
                new_liquidity_pool_program_id: self.new_liquidity_pool_program_id.to_string(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for SettlementProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                SettlementProgramIx::ActivateGame(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ActivateGame(
                        proto_def::ActivateGameIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::AddAuthorizedProgram(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::AddAuthorizedProgram(
                        proto_def::AddAuthorizedProgramIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::AddOperator(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::AddOperator(
                        proto_def::AddOperatorIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::CancelBet(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelBet(
                        proto_def::CancelBetIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::CancelGame(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelGame(
                        proto_def::CancelGameIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::ClaimPayout(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimPayout(
                        proto_def::ClaimPayoutIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::CloseBetting(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseBetting(
                        proto_def::CloseBettingIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::CreateGame(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateGame(
                        proto_def::CreateGameIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::GetPayouts(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::GetPayouts(
                        proto_def::GetPayoutsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::InitializeAuthorizedPrograms(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::InitializeAuthorizedPrograms(
                                proto_def::InitializeAuthorizedProgramsIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                SettlementProgramIx::PlaceBet(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::PlaceBet(
                        proto_def::PlaceBetIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::RemoveAuthorizedProgram(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveAuthorizedProgram(
                        proto_def::RemoveAuthorizedProgramIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::RemoveOperator(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveOperator(
                        proto_def::RemoveOperatorIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::SettleGame(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SettleGame(
                        proto_def::SettleGameIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::UpdateAdmin(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAdmin(
                        proto_def::UpdateAdminIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::UpdateFeeConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateFeeConfig(
                        proto_def::UpdateFeeConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                SettlementProgramIx::UpdateLiquidityPoolProgram(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::UpdateLiquidityPoolProgram(
                                proto_def::UpdateLiquidityPoolProgramIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
