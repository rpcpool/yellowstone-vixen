//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use crate::accounts::AuthorizedPrograms;
use crate::accounts::GameBetTracker;
use crate::accounts::GameRandomness;
use crate::accounts::GameRegistry;
use crate::accounts::GameSettlement;
use crate::accounts::GlobalConfig;
use crate::accounts::LiquidityPool;
use crate::accounts::PoolExposure;
use crate::accounts::RandomnessState;
use crate::ID;

use crate::deserialize_checked;

/// Settlement Program State
#[allow(clippy::large_enum_variant)]
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum SettlementProgramState {
    AuthorizedPrograms(AuthorizedPrograms),
    GameBetTracker(GameBetTracker),
    GameRandomness(GameRandomness),
    GameRegistry(GameRegistry),
    GameSettlement(GameSettlement),
    GlobalConfig(GlobalConfig),
    LiquidityPool(LiquidityPool),
    PoolExposure(PoolExposure),
    RandomnessState(RandomnessState),
}

impl SettlementProgramState {
    pub fn try_unpack(data_bytes: &[u8]) -> yellowstone_vixen_core::ParseResult<Self> {
        let acc_discriminator: [u8; 8] = data_bytes[0..8].try_into()?;
        let acc = match acc_discriminator {
            [151, 56, 130, 104, 13, 168, 62, 228] => {
                Ok(SettlementProgramState::AuthorizedPrograms(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [130, 5, 46, 118, 107, 4, 250, 89] => Ok(SettlementProgramState::GameBetTracker(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [94, 25, 168, 174, 218, 83, 202, 138] => Ok(SettlementProgramState::GameRandomness(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [24, 88, 182, 125, 149, 163, 9, 71] => Ok(SettlementProgramState::GameRegistry(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [140, 70, 219, 65, 138, 137, 33, 234] => Ok(SettlementProgramState::GameSettlement(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [149, 8, 156, 202, 160, 252, 176, 217] => Ok(SettlementProgramState::GlobalConfig(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [66, 38, 17, 64, 188, 80, 68, 129] => Ok(SettlementProgramState::LiquidityPool(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [118, 21, 235, 231, 216, 225, 225, 107] => Ok(SettlementProgramState::PoolExposure(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [162, 226, 24, 69, 173, 182, 21, 48] => Ok(SettlementProgramState::RandomnessState(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Account discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &acc {
            Ok(acc) => {
                tracing::info!(
                    name: "correctly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = acc.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = "error",
                    discriminator = ?acc_discriminator,
                    error = ?e
                );
            },
        }

        acc
    }
}

#[derive(Debug, Copy, Clone)]
pub struct AccountParser;

impl yellowstone_vixen_core::Parser for AccountParser {
    type Input = yellowstone_vixen_core::AccountUpdate;
    type Output = SettlementProgramState;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "settlement::AccountParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .account_owners([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        acct: &yellowstone_vixen_core::AccountUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        let inner = acct
            .account
            .as_ref()
            .ok_or(solana_program_error::ProgramError::InvalidArgument)?;
        let res = SettlementProgramState::try_unpack(&inner.data);

        #[cfg(feature = "tracing")]
        if let Err(e) = &res {
            let acc_discriminator: [u8; 8] = inner.data[0..8].try_into()?;
            tracing::info!(
                name: "incorrectly_parsed_account",
                name = "account_update",
                program = ID.to_string(),
                account = "deserialization_error",
                discriminator = ?acc_discriminator,
                error = ?e
            );
        }

        res
    }
}

impl yellowstone_vixen_core::ProgramParser for AccountParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use super::{AccountParser, SettlementProgramState};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    use yellowstone_vixen_core::proto::ParseProto;

    use super::AuthorizedPrograms;
    impl IntoProto<proto_def::AuthorizedPrograms> for AuthorizedPrograms {
        fn into_proto(self) -> proto_def::AuthorizedPrograms {
            proto_def::AuthorizedPrograms {
                programs: self.programs.into_iter().map(|x| x.to_string()).collect(),
                operators: self
                    .operators
                    .unwrap_or_default()
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                admin: self.admin.to_string(),
                game_counter: self.game_counter,
                ev_fee_config: Some(self.ev_fee_config.into_proto()),
                liquidity_pool_program_id: self.liquidity_pool_program_id.to_string(),
                game_keeper_program_id: self.game_keeper_program_id.to_string(),
                rando_program_id: self.rando_program_id.to_string(),
                protocol_fee_account: self.protocol_fee_account.to_string(),
                bump: self.bump.into(),
            }
        }
    }
    use super::GameBetTracker;
    impl IntoProto<proto_def::GameBetTracker> for GameBetTracker {
        fn into_proto(self) -> proto_def::GameBetTracker {
            proto_def::GameBetTracker {
                game_id: self.game_id,
                global_count: self.global_count,
                total_volume: self.total_volume,
                total_ev: self.total_ev,
                total_fees: self.total_fees,
                total_exposure: self.total_exposure,
                bet_count: self.bet_count,
                bump: self.bump.into(),
            }
        }
    }
    use super::GameRandomness;
    impl IntoProto<proto_def::GameRandomness> for GameRandomness {
        fn into_proto(self) -> proto_def::GameRandomness {
            proto_def::GameRandomness {
                game_id: self.game_id,
                settlement_program: self.settlement_program.to_string(),
                game_creator: self.game_creator.to_string(),
                house_nonce_commitment: self
                    .house_nonce_commitment
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
                house_nonce_revealed: self.house_nonce_revealed,
                final_randomness: self
                    .final_randomness
                    .unwrap_or_default()
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
                created_at: self.created_at,
                state: self.state as i32,
                entropy_nonce: self.entropy_nonce,
                sealed_randomness_height: self.sealed_randomness_height,
                bump: self.bump.into(),
            }
        }
    }
    use super::GameRegistry;
    impl IntoProto<proto_def::GameRegistry> for GameRegistry {
        fn into_proto(self) -> proto_def::GameRegistry {
            proto_def::GameRegistry {
                game_id: self.game_id,
                global_count: self.global_count,
                game_program: self.game_program.to_string(),
                creator: self.creator.to_string(),
                operator: self.operator.to_string(),
                token_mint: self.token_mint.to_string(),
                game_config_data: self
                    .game_config_data
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
                created_at: self.created_at,
                state: self.state as i32,
                affiliate: self.affiliate.map(|x| x.to_string()),
                bump: self.bump.into(),
            }
        }
    }
    use super::GameSettlement;
    impl IntoProto<proto_def::GameSettlement> for GameSettlement {
        fn into_proto(self) -> proto_def::GameSettlement {
            proto_def::GameSettlement {
                game_id: self.game_id,
                payouts: self.payouts.into_iter().map(|x| x.into_proto()).collect(),
                total_claimable: self.total_claimable,
                total_claimed: self.total_claimed,
                claimed_bitmap: self.claimed_bitmap.into_iter().map(|x| x.into()).collect(),
                settled_at: self.settled_at,
            }
        }
    }
    use super::GlobalConfig;
    impl IntoProto<proto_def::GlobalConfig> for GlobalConfig {
        fn into_proto(self) -> proto_def::GlobalConfig {
            proto_def::GlobalConfig {
                admin: self.admin.to_string(),
                authorized_settlements: self
                    .authorized_settlements
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                created_at: self.created_at,
                updated_at: self.updated_at,
                bump: self.bump.into(),
            }
        }
    }
    use super::LiquidityPool;
    impl IntoProto<proto_def::LiquidityPool> for LiquidityPool {
        fn into_proto(self) -> proto_def::LiquidityPool {
            proto_def::LiquidityPool {
                token_mint: self.token_mint.to_string(),
                vault: self.vault.to_string(),
                lp_token_mint: self.lp_token_mint.to_string(),
                total_lp_tokens: self.total_lp_tokens,
                current_exposure: self.current_exposure,
                total_exposure_settled: self.total_exposure_settled,
                total_queued_deposits: self.total_queued_deposits,
                created_at: self.created_at,
                is_active: self.is_active,
                bump: self.bump.into(),
            }
        }
    }
    use super::PoolExposure;
    impl IntoProto<proto_def::PoolExposure> for PoolExposure {
        fn into_proto(self) -> proto_def::PoolExposure {
            proto_def::PoolExposure {
                pool: self.pool.to_string(),
                total_exposure: self.total_exposure,
                max_exposure_reached: self.max_exposure_reached,
                updated_at: self.updated_at,
                bump: self.bump.into(),
            }
        }
    }
    use super::RandomnessState;
    impl IntoProto<proto_def::RandomnessState> for RandomnessState {
        fn into_proto(self) -> proto_def::RandomnessState {
            proto_def::RandomnessState {
                chain_heads: self
                    .chain_heads
                    .into_iter()
                    .map(|x| proto_def::RepeatedUint32Row {
                        rows: x.into_iter().map(|x| x as u32).collect(),
                    })
                    .collect(),
                active_queue: self
                    .active_queue
                    .into_iter()
                    .map(|x| proto_def::RepeatedUint32Row {
                        rows: x.into_iter().map(|x| x as u32).collect(),
                    })
                    .collect(),
                pending_queue: self
                    .pending_queue
                    .into_iter()
                    .map(|x| proto_def::RepeatedUint32Row {
                        rows: x.into_iter().map(|x| x as u32).collect(),
                    })
                    .collect(),
                steps_in_current_block: self.steps_in_current_block,
                max_steps_per_block: self.max_steps_per_block,
                total_steps: self.total_steps,
                last_tick_slot: self.last_tick_slot,
                admin: self.admin.to_string(),
                trusted_providers: self
                    .trusted_providers
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                authorized_readers: self
                    .authorized_readers
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                last_updated: self.last_updated,
                update_count: self.update_count,
                bump: self.bump.into(),
                mining_difficulty: self.mining_difficulty,
                randomness_chain_height: self.randomness_chain_height,
                randomness_chain_buffer: self
                    .randomness_chain_buffer
                    .into_iter()
                    .map(|x| proto_def::RepeatedUint32Row {
                        rows: x.into_iter().map(|x| x as u32).collect(),
                    })
                    .collect(),
                randomness_chain_head: self
                    .randomness_chain_head
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
                nonce: self.nonce,
            }
        }
    }

    impl IntoProto<proto_def::ProgramState> for SettlementProgramState {
        fn into_proto(self) -> proto_def::ProgramState {
            let state_oneof = match self {
                SettlementProgramState::AuthorizedPrograms(data) => {
                    proto_def::program_state::StateOneof::AuthorizedPrograms(data.into_proto())
                },
                SettlementProgramState::GameBetTracker(data) => {
                    proto_def::program_state::StateOneof::GameBetTracker(data.into_proto())
                },
                SettlementProgramState::GameRandomness(data) => {
                    proto_def::program_state::StateOneof::GameRandomness(data.into_proto())
                },
                SettlementProgramState::GameRegistry(data) => {
                    proto_def::program_state::StateOneof::GameRegistry(data.into_proto())
                },
                SettlementProgramState::GameSettlement(data) => {
                    proto_def::program_state::StateOneof::GameSettlement(data.into_proto())
                },
                SettlementProgramState::GlobalConfig(data) => {
                    proto_def::program_state::StateOneof::GlobalConfig(data.into_proto())
                },
                SettlementProgramState::LiquidityPool(data) => {
                    proto_def::program_state::StateOneof::LiquidityPool(data.into_proto())
                },
                SettlementProgramState::PoolExposure(data) => {
                    proto_def::program_state::StateOneof::PoolExposure(data.into_proto())
                },
                SettlementProgramState::RandomnessState(data) => {
                    proto_def::program_state::StateOneof::RandomnessState(data.into_proto())
                },
            };

            proto_def::ProgramState {
                state_oneof: Some(state_oneof),
            }
        }
    }

    impl ParseProto for AccountParser {
        type Message = proto_def::ProgramState;

        fn output_into_message(value: Self::Output) -> Self::Message {
            value.into_proto()
        }
    }
}
