//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use crate::accounts::BondingCurve;
use crate::accounts::FeeConfig;
use crate::accounts::Global;
use crate::accounts::GlobalVolumeAccumulator;
use crate::accounts::UserVolumeAccumulator;
use crate::ID;

use crate::deserialize_checked;

/// Pump Program State
#[allow(clippy::large_enum_variant)]
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum PumpProgramState {
    BondingCurve(BondingCurve),
    FeeConfig(FeeConfig),
    Global(Global),
    GlobalVolumeAccumulator(GlobalVolumeAccumulator),
    UserVolumeAccumulator(UserVolumeAccumulator),
}

impl PumpProgramState {
    pub fn try_unpack(data_bytes: &[u8]) -> yellowstone_vixen_core::ParseResult<Self> {
        let acc_discriminator: [u8; 8] = data_bytes[0..8].try_into()?;
        let acc = match acc_discriminator {
            [23, 183, 248, 55, 96, 216, 172, 96] => Ok(PumpProgramState::BondingCurve(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [143, 52, 146, 187, 219, 123, 76, 155] => Ok(PumpProgramState::FeeConfig(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [167, 232, 232, 177, 200, 108, 114, 127] => Ok(PumpProgramState::Global(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [202, 42, 246, 43, 142, 190, 30, 255] => Ok(PumpProgramState::GlobalVolumeAccumulator(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [86, 255, 112, 14, 102, 53, 154, 250] => Ok(PumpProgramState::UserVolumeAccumulator(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Account discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &acc {
            Ok(acc) => {
                tracing::info!(
                    name: "correctly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = acc.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = "error",
                    discriminator = ?acc_discriminator,
                    error = ?e
                );
            },
        }

        acc
    }
}

#[derive(Debug, Copy, Clone)]
pub struct AccountParser;

impl yellowstone_vixen_core::Parser for AccountParser {
    type Input = yellowstone_vixen_core::AccountUpdate;
    type Output = PumpProgramState;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "pump::AccountParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .account_owners([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        acct: &yellowstone_vixen_core::AccountUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        let inner = acct
            .account
            .as_ref()
            .ok_or(solana_program_error::ProgramError::InvalidArgument)?;
        let res = PumpProgramState::try_unpack(&inner.data);

        #[cfg(feature = "tracing")]
        if let Err(e) = &res {
            let acc_discriminator: [u8; 8] = inner.data[0..8].try_into()?;
            tracing::info!(
                name: "incorrectly_parsed_account",
                name = "account_update",
                program = ID.to_string(),
                account = "deserialization_error",
                discriminator = ?acc_discriminator,
                error = ?e
            );
        }

        res
    }
}

impl yellowstone_vixen_core::ProgramParser for AccountParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use super::{AccountParser, PumpProgramState};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    use yellowstone_vixen_core::proto::ParseProto;

    use super::BondingCurve;
    impl IntoProto<proto_def::BondingCurve> for BondingCurve {
        fn into_proto(self) -> proto_def::BondingCurve {
            proto_def::BondingCurve {
                virtual_token_reserves: self.virtual_token_reserves,
                virtual_sol_reserves: self.virtual_sol_reserves,
                real_token_reserves: self.real_token_reserves,
                real_sol_reserves: self.real_sol_reserves,
                token_total_supply: self.token_total_supply,
                complete: self.complete,
                creator: self.creator.to_string(),
                is_mayhem_mode: self.is_mayhem_mode,
            }
        }
    }
    use super::FeeConfig;
    impl IntoProto<proto_def::FeeConfig> for FeeConfig {
        fn into_proto(self) -> proto_def::FeeConfig {
            proto_def::FeeConfig {
                bump: self.bump.into(),
                admin: self.admin.to_string(),
                flat_fees: Some(self.flat_fees.into_proto()),
                fee_tiers: self.fee_tiers.into_iter().map(|x| x.into_proto()).collect(),
            }
        }
    }
    use super::Global;
    impl IntoProto<proto_def::Global> for Global {
        fn into_proto(self) -> proto_def::Global {
            proto_def::Global {
                initialized: self.initialized,
                authority: self.authority.to_string(),
                fee_recipient: self.fee_recipient.to_string(),
                initial_virtual_token_reserves: self.initial_virtual_token_reserves,
                initial_virtual_sol_reserves: self.initial_virtual_sol_reserves,
                initial_real_token_reserves: self.initial_real_token_reserves,
                token_total_supply: self.token_total_supply,
                fee_basis_points: self.fee_basis_points,
                withdraw_authority: self.withdraw_authority.to_string(),
                enable_migrate: self.enable_migrate,
                pool_migration_fee: self.pool_migration_fee,
                creator_fee_basis_points: self.creator_fee_basis_points,
                fee_recipients: self
                    .fee_recipients
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
                set_creator_authority: self.set_creator_authority.to_string(),
                admin_set_creator_authority: self.admin_set_creator_authority.to_string(),
                create_v2_enabled: self.create_v2_enabled,
                whitelist_pda: self.whitelist_pda.to_string(),
                reserved_fee_recipient: self.reserved_fee_recipient.to_string(),
                mayhem_mode_enabled: self.mayhem_mode_enabled,
                reserved_fee_recipients: self
                    .reserved_fee_recipients
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
            }
        }
    }
    use super::GlobalVolumeAccumulator;
    impl IntoProto<proto_def::GlobalVolumeAccumulator> for GlobalVolumeAccumulator {
        fn into_proto(self) -> proto_def::GlobalVolumeAccumulator {
            proto_def::GlobalVolumeAccumulator {
                start_time: self.start_time,
                end_time: self.end_time,
                seconds_in_a_day: self.seconds_in_a_day,
                mint: self.mint.to_string(),
                total_token_supply: self.total_token_supply.to_vec(),
                sol_volumes: self.sol_volumes.to_vec(),
            }
        }
    }
    use super::UserVolumeAccumulator;
    impl IntoProto<proto_def::UserVolumeAccumulator> for UserVolumeAccumulator {
        fn into_proto(self) -> proto_def::UserVolumeAccumulator {
            proto_def::UserVolumeAccumulator {
                user: self.user.to_string(),
                needs_claim: self.needs_claim,
                total_unclaimed_tokens: self.total_unclaimed_tokens,
                total_claimed_tokens: self.total_claimed_tokens,
                current_sol_volume: self.current_sol_volume,
                last_update_timestamp: self.last_update_timestamp,
                has_total_claimed_tokens: self.has_total_claimed_tokens,
            }
        }
    }

    impl IntoProto<proto_def::ProgramState> for PumpProgramState {
        fn into_proto(self) -> proto_def::ProgramState {
            let state_oneof = match self {
                PumpProgramState::BondingCurve(data) => {
                    proto_def::program_state::StateOneof::BondingCurve(data.into_proto())
                },
                PumpProgramState::FeeConfig(data) => {
                    proto_def::program_state::StateOneof::FeeConfig(data.into_proto())
                },
                PumpProgramState::Global(data) => {
                    proto_def::program_state::StateOneof::Global(data.into_proto())
                },
                PumpProgramState::GlobalVolumeAccumulator(data) => {
                    proto_def::program_state::StateOneof::GlobalVolumeAccumulator(data.into_proto())
                },
                PumpProgramState::UserVolumeAccumulator(data) => {
                    proto_def::program_state::StateOneof::UserVolumeAccumulator(data.into_proto())
                },
            };

            proto_def::ProgramState {
                state_oneof: Some(state_oneof),
            }
        }
    }

    impl ParseProto for AccountParser {
        type Message = proto_def::ProgramState;

        fn output_into_message(value: Self::Output) -> Self::Message {
            value.into_proto()
        }
    }
}
