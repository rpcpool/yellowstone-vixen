//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use crate::{
    accounts::{
        ClaimFeeOperator, Config, LockEscrow, MeteoraDammMigrationMetadata, MeteoraDammV2Metadata,
        PartnerMetadata, PoolConfig, VirtualPool, VirtualPoolMetadata,
    },
    deserialize_checked, ID,
};

/// DynamicBondingCurve Program State
#[allow(clippy::large_enum_variant)]
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum DynamicBondingCurveProgramState {
    ClaimFeeOperator(ClaimFeeOperator),
    Config(Config),
    LockEscrow(LockEscrow),
    MeteoraDammMigrationMetadata(MeteoraDammMigrationMetadata),
    MeteoraDammV2Metadata(MeteoraDammV2Metadata),
    PartnerMetadata(PartnerMetadata),
    PoolConfig(PoolConfig),
    VirtualPool(VirtualPool),
    VirtualPoolMetadata(VirtualPoolMetadata),
}

impl DynamicBondingCurveProgramState {
    pub fn try_unpack(data_bytes: &[u8]) -> yellowstone_vixen_core::ParseResult<Self> {
        let acc_discriminator: [u8; 8] = data_bytes[0..8].try_into()?;
        let acc = match acc_discriminator {
            [166, 48, 134, 86, 34, 200, 188, 150] => {
                Ok(DynamicBondingCurveProgramState::ClaimFeeOperator(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [155, 12, 170, 224, 30, 250, 204, 130] => Ok(DynamicBondingCurveProgramState::Config(
                deserialize_checked(data_bytes, &acc_discriminator)?,
            )),
            [190, 106, 121, 6, 200, 182, 21, 75] => {
                Ok(DynamicBondingCurveProgramState::LockEscrow(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [17, 155, 141, 215, 207, 4, 133, 156] => Ok(
                DynamicBondingCurveProgramState::MeteoraDammMigrationMetadata(deserialize_checked(
                    data_bytes,
                    &acc_discriminator,
                )?),
            ),
            [104, 221, 219, 203, 10, 142, 250, 163] => {
                Ok(DynamicBondingCurveProgramState::MeteoraDammV2Metadata(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [68, 68, 130, 19, 16, 209, 98, 156] => {
                Ok(DynamicBondingCurveProgramState::PartnerMetadata(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [26, 108, 14, 123, 116, 230, 129, 43] => {
                Ok(DynamicBondingCurveProgramState::PoolConfig(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [213, 224, 5, 209, 98, 69, 119, 92] => {
                Ok(DynamicBondingCurveProgramState::VirtualPool(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            [217, 37, 82, 250, 43, 47, 228, 254] => {
                Ok(DynamicBondingCurveProgramState::VirtualPoolMetadata(
                    deserialize_checked(data_bytes, &acc_discriminator)?,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Account discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &acc {
            Ok(acc) => {
                tracing::info!(
                    name: "correctly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = acc.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_account",
                    name = "account_update",
                    program = ID.to_string(),
                    account = "error",
                    discriminator = ?acc_discriminator,
                    error = ?e
                );
            },
        }

        acc
    }
}

#[derive(Debug, Copy, Clone)]
pub struct AccountParser;

impl yellowstone_vixen_core::Parser for AccountParser {
    type Input = yellowstone_vixen_core::AccountUpdate;
    type Output = DynamicBondingCurveProgramState;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "dynamic_bonding_curve::AccountParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .account_owners([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        acct: &yellowstone_vixen_core::AccountUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        let inner = acct
            .account
            .as_ref()
            .ok_or(solana_program_error::ProgramError::InvalidArgument)?;
        let res = DynamicBondingCurveProgramState::try_unpack(&inner.data);

        #[cfg(feature = "tracing")]
        if let Err(e) = &res {
            let acc_discriminator: [u8; 8] = inner.data[0..8].try_into()?;
            tracing::info!(
                name: "incorrectly_parsed_account",
                name = "account_update",
                program = ID.to_string(),
                account = "deserialization_error",
                discriminator = ?acc_discriminator,
                error = ?e
            );
        }

        res
    }
}

impl yellowstone_vixen_core::ProgramParser for AccountParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AccountParser, ClaimFeeOperator, DynamicBondingCurveProgramState};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimFeeOperator> for ClaimFeeOperator {
        fn into_proto(self) -> proto_def::ClaimFeeOperator {
            proto_def::ClaimFeeOperator {
                operator: self.operator.to_string(),
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::Config;
    impl IntoProto<proto_def::Config> for Config {
        fn into_proto(self) -> proto_def::Config {
            proto_def::Config {
                pool_fees: Some(self.pool_fees.into_proto()),
                activation_duration: self.activation_duration,
                vault_config_key: self.vault_config_key.to_string(),
                pool_creator_authority: self.pool_creator_authority.to_string(),
                activation_type: self.activation_type.into(),
                partner_fee_numerator: self.partner_fee_numerator,
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::LockEscrow;
    impl IntoProto<proto_def::LockEscrow> for LockEscrow {
        fn into_proto(self) -> proto_def::LockEscrow {
            proto_def::LockEscrow {
                pool: self.pool.to_string(),
                owner: self.owner.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                bump: self.bump.into(),
                total_locked_amount: self.total_locked_amount,
                lp_per_token: self.lp_per_token.to_string(),
                unclaimed_fee_pending: self.unclaimed_fee_pending,
                a_fee: self.a_fee,
                b_fee: self.b_fee,
            }
        }
    }
    use super::MeteoraDammMigrationMetadata;
    impl IntoProto<proto_def::MeteoraDammMigrationMetadata> for MeteoraDammMigrationMetadata {
        fn into_proto(self) -> proto_def::MeteoraDammMigrationMetadata {
            proto_def::MeteoraDammMigrationMetadata {
                virtual_pool: self.virtual_pool.to_string(),
                pool_creator: self.pool_creator.to_string(),
                partner: self.partner.to_string(),
                lp_mint: self.lp_mint.to_string(),
                partner_locked_lp: self.partner_locked_lp,
                partner_lp: self.partner_lp,
                creator_locked_lp: self.creator_locked_lp,
                creator_lp: self.creator_lp,
                padding0: self.padding0.into(),
                creator_locked_status: self.creator_locked_status.into(),
                partner_locked_status: self.partner_locked_status.into(),
                creator_claim_status: self.creator_claim_status.into(),
                partner_claim_status: self.partner_claim_status.into(),
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::MeteoraDammV2Metadata;
    impl IntoProto<proto_def::MeteoraDammV2Metadata> for MeteoraDammV2Metadata {
        fn into_proto(self) -> proto_def::MeteoraDammV2Metadata {
            proto_def::MeteoraDammV2Metadata {
                virtual_pool: self.virtual_pool.to_string(),
                pool_creator: self.pool_creator.to_string(),
                partner: self.partner.to_string(),
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::PartnerMetadata;
    impl IntoProto<proto_def::PartnerMetadata> for PartnerMetadata {
        fn into_proto(self) -> proto_def::PartnerMetadata {
            proto_def::PartnerMetadata {
                fee_claimer: self.fee_claimer.to_string(),
                padding: self.padding.into_iter().map(|x| x.to_string()).collect(),
                name: self.name,
                website: self.website,
                logo: self.logo,
            }
        }
    }
    use super::PoolConfig;
    impl IntoProto<proto_def::PoolConfig> for PoolConfig {
        fn into_proto(self) -> proto_def::PoolConfig {
            proto_def::PoolConfig {
                quote_mint: self.quote_mint.to_string(),
                fee_claimer: self.fee_claimer.to_string(),
                leftover_receiver: self.leftover_receiver.to_string(),
                pool_fees: Some(self.pool_fees.into_proto()),
                collect_fee_mode: self.collect_fee_mode.into(),
                migration_option: self.migration_option.into(),
                activation_type: self.activation_type.into(),
                token_decimal: self.token_decimal.into(),
                version: self.version.into(),
                token_type: self.token_type.into(),
                quote_token_flag: self.quote_token_flag.into(),
                partner_locked_lp_percentage: self.partner_locked_lp_percentage.into(),
                partner_lp_percentage: self.partner_lp_percentage.into(),
                creator_locked_lp_percentage: self.creator_locked_lp_percentage.into(),
                creator_lp_percentage: self.creator_lp_percentage.into(),
                migration_fee_option: self.migration_fee_option.into(),
                fixed_token_supply_flag: self.fixed_token_supply_flag.into(),
                creator_trading_fee_percentage: self.creator_trading_fee_percentage.into(),
                padding0: self.padding0.into_iter().map(|x| x.into()).collect(),
                padding1: self.padding1.into_iter().map(|x| x.into()).collect(),
                swap_base_amount: self.swap_base_amount,
                migration_quote_threshold: self.migration_quote_threshold,
                migration_base_threshold: self.migration_base_threshold,
                migration_sqrt_price: self.migration_sqrt_price.to_string(),
                locked_vesting_config: Some(self.locked_vesting_config.into_proto()),
                pre_migration_token_supply: self.pre_migration_token_supply,
                post_migration_token_supply: self.post_migration_token_supply,
                padding2: self.padding2.into_iter().map(|x| x.to_string()).collect(),
                sqrt_start_price: self.sqrt_start_price.to_string(),
                curve: self.curve.into_iter().map(|x| x.into_proto()).collect(),
            }
        }
    }
    use super::VirtualPool;
    impl IntoProto<proto_def::VirtualPool> for VirtualPool {
        fn into_proto(self) -> proto_def::VirtualPool {
            proto_def::VirtualPool {
                volatility_tracker: Some(self.volatility_tracker.into_proto()),
                config: self.config.to_string(),
                creator: self.creator.to_string(),
                base_mint: self.base_mint.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_reserve: self.base_reserve,
                quote_reserve: self.quote_reserve,
                protocol_base_fee: self.protocol_base_fee,
                protocol_quote_fee: self.protocol_quote_fee,
                partner_base_fee: self.partner_base_fee,
                partner_quote_fee: self.partner_quote_fee,
                sqrt_price: self.sqrt_price.to_string(),
                activation_point: self.activation_point,
                pool_type: self.pool_type.into(),
                is_migrated: self.is_migrated.into(),
                is_partner_withdraw_surplus: self.is_partner_withdraw_surplus.into(),
                is_protocol_withdraw_surplus: self.is_protocol_withdraw_surplus.into(),
                migration_progress: self.migration_progress.into(),
                is_withdraw_leftover: self.is_withdraw_leftover.into(),
                is_creator_withdraw_surplus: self.is_creator_withdraw_surplus.into(),
                padding0: self.padding0.into_iter().map(|x| x.into()).collect(),
                metrics: Some(self.metrics.into_proto()),
                finish_curve_timestamp: self.finish_curve_timestamp,
                creator_base_fee: self.creator_base_fee,
                creator_quote_fee: self.creator_quote_fee,
                padding1: self.padding1.to_vec(),
            }
        }
    }
    use super::VirtualPoolMetadata;
    impl IntoProto<proto_def::VirtualPoolMetadata> for VirtualPoolMetadata {
        fn into_proto(self) -> proto_def::VirtualPoolMetadata {
            proto_def::VirtualPoolMetadata {
                virtual_pool: self.virtual_pool.to_string(),
                padding: self.padding.into_iter().map(|x| x.to_string()).collect(),
                name: self.name,
                website: self.website,
                logo: self.logo,
            }
        }
    }

    impl IntoProto<proto_def::ProgramState> for DynamicBondingCurveProgramState {
        fn into_proto(self) -> proto_def::ProgramState {
            let state_oneof = match self {
                DynamicBondingCurveProgramState::ClaimFeeOperator(data) => {
                    proto_def::program_state::StateOneof::ClaimFeeOperator(data.into_proto())
                },
                DynamicBondingCurveProgramState::Config(data) => {
                    proto_def::program_state::StateOneof::Config(data.into_proto())
                },
                DynamicBondingCurveProgramState::LockEscrow(data) => {
                    proto_def::program_state::StateOneof::LockEscrow(data.into_proto())
                },
                DynamicBondingCurveProgramState::MeteoraDammMigrationMetadata(data) => {
                    proto_def::program_state::StateOneof::MeteoraDammMigrationMetadata(
                        data.into_proto(),
                    )
                },
                DynamicBondingCurveProgramState::MeteoraDammV2Metadata(data) => {
                    proto_def::program_state::StateOneof::MeteoraDammV2Metadata(data.into_proto())
                },
                DynamicBondingCurveProgramState::PartnerMetadata(data) => {
                    proto_def::program_state::StateOneof::PartnerMetadata(data.into_proto())
                },
                DynamicBondingCurveProgramState::PoolConfig(data) => {
                    proto_def::program_state::StateOneof::PoolConfig(data.into_proto())
                },
                DynamicBondingCurveProgramState::VirtualPool(data) => {
                    proto_def::program_state::StateOneof::VirtualPool(data.into_proto())
                },
                DynamicBondingCurveProgramState::VirtualPoolMetadata(data) => {
                    proto_def::program_state::StateOneof::VirtualPoolMetadata(data.into_proto())
                },
            };

            proto_def::ProgramState {
                state_oneof: Some(state_oneof),
            }
        }
    }

    impl ParseProto for AccountParser {
        type Message = proto_def::ProgramState;

        fn output_into_message(value: Self::Output) -> Self::Message {
            value.into_proto()
        }
    }
}
