//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

use yellowstone_vixen_core::constants::is_known_aggregator;
#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated::types::{EvtSwap, EvtSwap2},
    instructions::{
        ClaimCreatorTradingFee as ClaimCreatorTradingFeeIxAccounts,
        ClaimCreatorTradingFeeInstructionArgs as ClaimCreatorTradingFeeIxData,
        ClaimProtocolFee as ClaimProtocolFeeIxAccounts,
        ClaimTradingFee as ClaimTradingFeeIxAccounts,
        ClaimTradingFeeInstructionArgs as ClaimTradingFeeIxData,
        CloseClaimFeeOperator as CloseClaimFeeOperatorIxAccounts,
        CreateClaimFeeOperator as CreateClaimFeeOperatorIxAccounts,
        CreateConfig as CreateConfigIxAccounts, CreateConfigInstructionArgs as CreateConfigIxData,
        CreateLocker as CreateLockerIxAccounts,
        CreatePartnerMetadata as CreatePartnerMetadataIxAccounts,
        CreatePartnerMetadataInstructionArgs as CreatePartnerMetadataIxData,
        CreateVirtualPoolMetadata as CreateVirtualPoolMetadataIxAccounts,
        CreateVirtualPoolMetadataInstructionArgs as CreateVirtualPoolMetadataIxData,
        CreatorWithdrawSurplus as CreatorWithdrawSurplusIxAccounts,
        InitializeVirtualPoolWithSplToken as InitializeVirtualPoolWithSplTokenIxAccounts,
        InitializeVirtualPoolWithSplTokenInstructionArgs as InitializeVirtualPoolWithSplTokenIxData,
        InitializeVirtualPoolWithToken2022 as InitializeVirtualPoolWithToken2022IxAccounts,
        InitializeVirtualPoolWithToken2022InstructionArgs as InitializeVirtualPoolWithToken2022IxData,
        MigrateMeteoraDamm as MigrateMeteoraDammIxAccounts,
        MigrateMeteoraDammClaimLpToken as MigrateMeteoraDammClaimLpTokenIxAccounts,
        MigrateMeteoraDammLockLpToken as MigrateMeteoraDammLockLpTokenIxAccounts,
        MigrationDammV2 as MigrationDammV2IxAccounts,
        MigrationDammV2CreateMetadata as MigrationDammV2CreateMetadataIxAccounts,
        MigrationMeteoraDammCreateMetadata as MigrationMeteoraDammCreateMetadataIxAccounts,
        PartnerWithdrawSurplus as PartnerWithdrawSurplusIxAccounts,
        ProtocolWithdrawSurplus as ProtocolWithdrawSurplusIxAccounts, Swap as SwapIxAccounts,
        Swap2 as Swap2IxAccounts, Swap2InstructionArgs as Swap2IxData,
        SwapInstructionArgs as SwapIxData, TransferPoolCreator as TransferPoolCreatorIxAccounts,
        WithdrawLeftover as WithdrawLeftoverIxAccounts,
        WithdrawMigrationFee as WithdrawMigrationFeeIxAccounts,
        WithdrawMigrationFeeInstructionArgs as WithdrawMigrationFeeIxData,
    },
    ID,
};

/// DynamicBondingCurve Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum DynamicBondingCurveProgramIx {
    ClaimCreatorTradingFee(
        ClaimCreatorTradingFeeIxAccounts,
        ClaimCreatorTradingFeeIxData,
    ),
    ClaimProtocolFee(ClaimProtocolFeeIxAccounts),
    ClaimTradingFee(ClaimTradingFeeIxAccounts, ClaimTradingFeeIxData),
    CloseClaimFeeOperator(CloseClaimFeeOperatorIxAccounts),
    CreateClaimFeeOperator(CreateClaimFeeOperatorIxAccounts),
    CreateConfig(CreateConfigIxAccounts, CreateConfigIxData),
    CreateLocker(CreateLockerIxAccounts),
    CreatePartnerMetadata(CreatePartnerMetadataIxAccounts, CreatePartnerMetadataIxData),
    CreateVirtualPoolMetadata(
        CreateVirtualPoolMetadataIxAccounts,
        CreateVirtualPoolMetadataIxData,
    ),
    CreatorWithdrawSurplus(CreatorWithdrawSurplusIxAccounts),
    InitializeVirtualPoolWithSplToken(
        InitializeVirtualPoolWithSplTokenIxAccounts,
        InitializeVirtualPoolWithSplTokenIxData,
    ),
    InitializeVirtualPoolWithToken2022(
        InitializeVirtualPoolWithToken2022IxAccounts,
        InitializeVirtualPoolWithToken2022IxData,
    ),
    MigrateMeteoraDamm(MigrateMeteoraDammIxAccounts),
    MigrateMeteoraDammClaimLpToken(MigrateMeteoraDammClaimLpTokenIxAccounts),
    MigrateMeteoraDammLockLpToken(MigrateMeteoraDammLockLpTokenIxAccounts),
    MigrationDammV2(MigrationDammV2IxAccounts),
    MigrationDammV2CreateMetadata(MigrationDammV2CreateMetadataIxAccounts),
    MigrationMeteoraDammCreateMetadata(MigrationMeteoraDammCreateMetadataIxAccounts),
    PartnerWithdrawSurplus(PartnerWithdrawSurplusIxAccounts),
    ProtocolWithdrawSurplus(ProtocolWithdrawSurplusIxAccounts),
    Swap(SwapIxAccounts, SwapIxData, Option<EvtSwap>),
    Swap2(Swap2IxAccounts, Swap2IxData, Option<EvtSwap2>),
    TransferPoolCreator(TransferPoolCreatorIxAccounts),
    WithdrawLeftover(WithdrawLeftoverIxAccounts),
    WithdrawMigrationFee(WithdrawMigrationFeeIxAccounts, WithdrawMigrationFeeIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = DynamicBondingCurveProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<DynamicBondingCurveProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "DynamicBondingCurve::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;
        if ix.data.len() < 8 {
            return Err(yellowstone_vixen_core::ParseError::from(
                "Instruction data too short".to_owned(),
            ));
        }

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [82, 220, 250, 189, 3, 85, 107, 45] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimCreatorTradingFeeIxAccounts {
                    pool_authority: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    token_a_account: next_account(accounts)?,
                    token_b_account: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: ClaimCreatorTradingFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::ClaimCreatorTradingFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [165, 228, 133, 48, 99, 249, 255, 33] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimProtocolFeeIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    token_base_account: next_account(accounts)?,
                    token_quote_account: next_account(accounts)?,
                    claim_fee_operator: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::ClaimProtocolFee(ix_accounts))
            },
            [8, 236, 89, 49, 152, 125, 177, 81] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimTradingFeeIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    token_a_account: next_account(accounts)?,
                    token_b_account: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    fee_claimer: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: ClaimTradingFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::ClaimTradingFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [38, 134, 82, 216, 95, 124, 17, 99] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseClaimFeeOperatorIxAccounts {
                    claim_fee_operator: next_account(accounts)?,
                    rent_receiver: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::CloseClaimFeeOperator(
                    ix_accounts,
                ))
            },
            [169, 62, 207, 107, 58, 187, 162, 109] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateClaimFeeOperatorIxAccounts {
                    claim_fee_operator: next_account(accounts)?,
                    operator: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::CreateClaimFeeOperator(
                    ix_accounts,
                ))
            },
            [201, 207, 243, 114, 75, 111, 47, 189] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateConfigIxAccounts {
                    config: next_account(accounts)?,
                    fee_claimer: next_account(accounts)?,
                    leftover_receiver: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: CreateConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::CreateConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [167, 90, 137, 154, 75, 47, 17, 84] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateLockerIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    base: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    escrow: next_account(accounts)?,
                    escrow_token: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    locker_program: next_account(accounts)?,
                    locker_event_authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::CreateLocker(ix_accounts))
            },
            [192, 168, 234, 191, 188, 226, 227, 255] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatePartnerMetadataIxAccounts {
                    partner_metadata: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    fee_claimer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: CreatePartnerMetadataIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::CreatePartnerMetadata(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [45, 97, 187, 103, 254, 109, 124, 134] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateVirtualPoolMetadataIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    virtual_pool_metadata: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: CreateVirtualPoolMetadataIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::CreateVirtualPoolMetadata(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [165, 3, 137, 7, 28, 134, 76, 80] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatorWithdrawSurplusIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    virtual_pool: next_account(accounts)?,
                    token_quote_account: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::CreatorWithdrawSurplus(
                    ix_accounts,
                ))
            },
            [140, 85, 215, 176, 102, 54, 104, 79] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeVirtualPoolWithSplTokenIxAccounts {
                    config: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: InitializeVirtualPoolWithSplTokenIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(
                    DynamicBondingCurveProgramIx::InitializeVirtualPoolWithSplToken(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [169, 118, 51, 78, 145, 110, 220, 155] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeVirtualPoolWithToken2022IxAccounts {
                    config: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: InitializeVirtualPoolWithToken2022IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(
                    DynamicBondingCurveProgramIx::InitializeVirtualPoolWithToken2022(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [27, 1, 48, 22, 180, 63, 118, 217] => {
                let expected_accounts_len = 31;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrateMeteoraDammIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    damm_config: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    token_a_mint: next_account(accounts)?,
                    token_b_mint: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    virtual_pool_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    amm_program: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrateMeteoraDamm(
                    ix_accounts,
                ))
            },
            [139, 133, 2, 30, 91, 145, 127, 154] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrateMeteoraDammClaimLpTokenIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    source_token: next_account(accounts)?,
                    destination_token: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    sender: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrateMeteoraDammClaimLpToken(ix_accounts))
            },
            [177, 55, 238, 157, 251, 88, 165, 42] => {
                let expected_accounts_len = 17;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrateMeteoraDammLockLpTokenIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    lock_escrow: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    source_tokens: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    amm_program: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrateMeteoraDammLockLpToken(
                    ix_accounts,
                ))
            },
            [156, 169, 230, 103, 53, 228, 80, 64] => {
                let expected_accounts_len = 25;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrationDammV2IxAccounts {
                    virtual_pool: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool_authority: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    first_position_nft_mint: next_account(accounts)?,
                    first_position_nft_account: next_account(accounts)?,
                    first_position: next_account(accounts)?,
                    second_position_nft_mint: next_program_id_optional_account(accounts)?,
                    second_position_nft_account: next_program_id_optional_account(accounts)?,
                    second_position: next_program_id_optional_account(accounts)?,
                    damm_pool_authority: next_account(accounts)?,
                    amm_program: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    token_a_vault: next_account(accounts)?,
                    token_b_vault: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    token2022_program: next_account(accounts)?,
                    damm_event_authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrationDammV2(ix_accounts))
            },
            [109, 189, 19, 36, 195, 183, 222, 82] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrationDammV2CreateMetadataIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    config: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrationDammV2CreateMetadata(
                    ix_accounts,
                ))
            },
            [47, 94, 126, 115, 221, 226, 194, 133] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = MigrationMeteoraDammCreateMetadataIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    config: next_account(accounts)?,
                    migration_metadata: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::MigrationMeteoraDammCreateMetadata(ix_accounts))
            },
            [168, 173, 72, 100, 201, 98, 38, 92] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PartnerWithdrawSurplusIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    virtual_pool: next_account(accounts)?,
                    token_quote_account: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    fee_claimer: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::PartnerWithdrawSurplus(
                    ix_accounts,
                ))
            },
            [54, 136, 225, 138, 172, 182, 214, 167] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ProtocolWithdrawSurplusIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    virtual_pool: next_account(accounts)?,
                    token_quote_account: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::ProtocolWithdrawSurplus(
                    ix_accounts,
                ))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    referral_token_account: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = deserialize_checked(ix_data, &ix_discriminator)?;

                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }

                let evt_swap = ix
                    .inner
                    .iter()
                    .find_map(|inner_ix| EvtSwap::from_inner_instruction_data(&inner_ix.data));

                Ok(DynamicBondingCurveProgramIx::Swap(
                    ix_accounts,
                    de_ix_data,
                    evt_swap,
                ))
            },
            [65, 75, 63, 76, 235, 91, 91, 136] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = Swap2IxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    pool: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    referral_token_account: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: Swap2IxData = deserialize_checked(ix_data, &ix_discriminator)?;

                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }

                // Search for EvtSwap2 in inner instructions
                let evt_swap2 = ix
                    .inner
                    .iter()
                    .find_map(|inner_ix| EvtSwap2::from_inner_instruction_data(&inner_ix.data));

                Ok(DynamicBondingCurveProgramIx::Swap2(
                    ix_accounts,
                    de_ix_data,
                    evt_swap2,
                ))
            },
            [20, 7, 169, 33, 58, 147, 166, 33] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TransferPoolCreatorIxAccounts {
                    virtual_pool: next_account(accounts)?,
                    config: next_account(accounts)?,
                    creator: next_account(accounts)?,
                    new_creator: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::TransferPoolCreator(
                    ix_accounts,
                ))
            },
            [20, 198, 202, 237, 235, 243, 183, 66] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WithdrawLeftoverIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    virtual_pool: next_account(accounts)?,
                    token_base_account: next_account(accounts)?,
                    base_vault: next_account(accounts)?,
                    base_mint: next_account(accounts)?,
                    leftover_receiver: next_account(accounts)?,
                    token_base_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                Ok(DynamicBondingCurveProgramIx::WithdrawLeftover(ix_accounts))
            },
            [237, 142, 45, 23, 129, 6, 222, 162] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WithdrawMigrationFeeIxAccounts {
                    pool_authority: next_account(accounts)?,
                    config: next_account(accounts)?,
                    virtual_pool: next_account(accounts)?,
                    token_quote_account: next_account(accounts)?,
                    quote_vault: next_account(accounts)?,
                    quote_mint: next_account(accounts)?,
                    sender: next_account(accounts)?,
                    token_quote_program: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: WithdrawMigrationFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DynamicBondingCurveProgramIx::WithdrawMigrationFee(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{
        ClaimCreatorTradingFeeIxAccounts, DynamicBondingCurveProgramIx, InstructionParser,
    };
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimCreatorTradingFeeIxAccounts> for ClaimCreatorTradingFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimCreatorTradingFeeIxAccounts {
            proto_def::ClaimCreatorTradingFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                creator: self.creator.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimCreatorTradingFeeIxData;
    impl IntoProto<proto_def::ClaimCreatorTradingFeeIxData> for ClaimCreatorTradingFeeIxData {
        fn into_proto(self) -> proto_def::ClaimCreatorTradingFeeIxData {
            proto_def::ClaimCreatorTradingFeeIxData {
                max_base_amount: self.max_base_amount,
                max_quote_amount: self.max_quote_amount,
            }
        }
    }
    use super::ClaimProtocolFeeIxAccounts;
    impl IntoProto<proto_def::ClaimProtocolFeeIxAccounts> for ClaimProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimProtocolFeeIxAccounts {
            proto_def::ClaimProtocolFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                pool: self.pool.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                token_base_account: self.token_base_account.to_string(),
                token_quote_account: self.token_quote_account.to_string(),
                claim_fee_operator: self.claim_fee_operator.to_string(),
                operator: self.operator.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimTradingFeeIxAccounts;
    impl IntoProto<proto_def::ClaimTradingFeeIxAccounts> for ClaimTradingFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimTradingFeeIxAccounts {
            proto_def::ClaimTradingFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                pool: self.pool.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                fee_claimer: self.fee_claimer.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimTradingFeeIxData;
    impl IntoProto<proto_def::ClaimTradingFeeIxData> for ClaimTradingFeeIxData {
        fn into_proto(self) -> proto_def::ClaimTradingFeeIxData {
            proto_def::ClaimTradingFeeIxData {
                max_amount_a: self.max_amount_a,
                max_amount_b: self.max_amount_b,
            }
        }
    }
    use super::CloseClaimFeeOperatorIxAccounts;
    impl IntoProto<proto_def::CloseClaimFeeOperatorIxAccounts> for CloseClaimFeeOperatorIxAccounts {
        fn into_proto(self) -> proto_def::CloseClaimFeeOperatorIxAccounts {
            proto_def::CloseClaimFeeOperatorIxAccounts {
                claim_fee_operator: self.claim_fee_operator.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
                admin: self.admin.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateClaimFeeOperatorIxAccounts;
    impl IntoProto<proto_def::CreateClaimFeeOperatorIxAccounts> for CreateClaimFeeOperatorIxAccounts {
        fn into_proto(self) -> proto_def::CreateClaimFeeOperatorIxAccounts {
            proto_def::CreateClaimFeeOperatorIxAccounts {
                claim_fee_operator: self.claim_fee_operator.to_string(),
                operator: self.operator.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateConfigIxAccounts;
    impl IntoProto<proto_def::CreateConfigIxAccounts> for CreateConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateConfigIxAccounts {
            proto_def::CreateConfigIxAccounts {
                config: self.config.to_string(),
                fee_claimer: self.fee_claimer.to_string(),
                leftover_receiver: self.leftover_receiver.to_string(),
                quote_mint: self.quote_mint.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateConfigIxData;
    impl IntoProto<proto_def::CreateConfigIxData> for CreateConfigIxData {
        fn into_proto(self) -> proto_def::CreateConfigIxData {
            proto_def::CreateConfigIxData {
                config_parameters: Some(self.config_parameters.into_proto()),
            }
        }
    }
    use super::CreateLockerIxAccounts;
    impl IntoProto<proto_def::CreateLockerIxAccounts> for CreateLockerIxAccounts {
        fn into_proto(self) -> proto_def::CreateLockerIxAccounts {
            proto_def::CreateLockerIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                base_vault: self.base_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                base: self.base.to_string(),
                creator: self.creator.to_string(),
                escrow: self.escrow.to_string(),
                escrow_token: self.escrow_token.to_string(),
                payer: self.payer.to_string(),
                token_program: self.token_program.to_string(),
                locker_program: self.locker_program.to_string(),
                locker_event_authority: self.locker_event_authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreatePartnerMetadataIxAccounts;
    impl IntoProto<proto_def::CreatePartnerMetadataIxAccounts> for CreatePartnerMetadataIxAccounts {
        fn into_proto(self) -> proto_def::CreatePartnerMetadataIxAccounts {
            proto_def::CreatePartnerMetadataIxAccounts {
                partner_metadata: self.partner_metadata.to_string(),
                payer: self.payer.to_string(),
                fee_claimer: self.fee_claimer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreatePartnerMetadataIxData;
    impl IntoProto<proto_def::CreatePartnerMetadataIxData> for CreatePartnerMetadataIxData {
        fn into_proto(self) -> proto_def::CreatePartnerMetadataIxData {
            proto_def::CreatePartnerMetadataIxData {
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
                name: self.name,
                website: self.website,
                logo: self.logo,
            }
        }
    }
    use super::CreateVirtualPoolMetadataIxAccounts;
    impl IntoProto<proto_def::CreateVirtualPoolMetadataIxAccounts>
        for CreateVirtualPoolMetadataIxAccounts
    {
        fn into_proto(self) -> proto_def::CreateVirtualPoolMetadataIxAccounts {
            proto_def::CreateVirtualPoolMetadataIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                virtual_pool_metadata: self.virtual_pool_metadata.to_string(),
                creator: self.creator.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateVirtualPoolMetadataIxData;
    impl IntoProto<proto_def::CreateVirtualPoolMetadataIxData> for CreateVirtualPoolMetadataIxData {
        fn into_proto(self) -> proto_def::CreateVirtualPoolMetadataIxData {
            proto_def::CreateVirtualPoolMetadataIxData {
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
                name: self.name,
                website: self.website,
                logo: self.logo,
            }
        }
    }
    use super::CreatorWithdrawSurplusIxAccounts;
    impl IntoProto<proto_def::CreatorWithdrawSurplusIxAccounts> for CreatorWithdrawSurplusIxAccounts {
        fn into_proto(self) -> proto_def::CreatorWithdrawSurplusIxAccounts {
            proto_def::CreatorWithdrawSurplusIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                virtual_pool: self.virtual_pool.to_string(),
                token_quote_account: self.token_quote_account.to_string(),
                quote_vault: self.quote_vault.to_string(),
                quote_mint: self.quote_mint.to_string(),
                creator: self.creator.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeVirtualPoolWithSplTokenIxAccounts;
    impl IntoProto<proto_def::InitializeVirtualPoolWithSplTokenIxAccounts>
        for InitializeVirtualPoolWithSplTokenIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializeVirtualPoolWithSplTokenIxAccounts {
            proto_def::InitializeVirtualPoolWithSplTokenIxAccounts {
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                creator: self.creator.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                pool: self.pool.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                payer: self.payer.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeVirtualPoolWithSplTokenIxData;
    impl IntoProto<proto_def::InitializeVirtualPoolWithSplTokenIxData>
        for InitializeVirtualPoolWithSplTokenIxData
    {
        fn into_proto(self) -> proto_def::InitializeVirtualPoolWithSplTokenIxData {
            proto_def::InitializeVirtualPoolWithSplTokenIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::InitializeVirtualPoolWithToken2022IxAccounts;
    impl IntoProto<proto_def::InitializeVirtualPoolWithToken2022IxAccounts>
        for InitializeVirtualPoolWithToken2022IxAccounts
    {
        fn into_proto(self) -> proto_def::InitializeVirtualPoolWithToken2022IxAccounts {
            proto_def::InitializeVirtualPoolWithToken2022IxAccounts {
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                creator: self.creator.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                pool: self.pool.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                payer: self.payer.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeVirtualPoolWithToken2022IxData;
    impl IntoProto<proto_def::InitializeVirtualPoolWithToken2022IxData>
        for InitializeVirtualPoolWithToken2022IxData
    {
        fn into_proto(self) -> proto_def::InitializeVirtualPoolWithToken2022IxData {
            proto_def::InitializeVirtualPoolWithToken2022IxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::MigrateMeteoraDammIxAccounts;
    impl IntoProto<proto_def::MigrateMeteoraDammIxAccounts> for MigrateMeteoraDammIxAccounts {
        fn into_proto(self) -> proto_def::MigrateMeteoraDammIxAccounts {
            proto_def::MigrateMeteoraDammIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                damm_config: self.damm_config.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                virtual_pool_lp: self.virtual_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                amm_program: self.amm_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::MigrateMeteoraDammClaimLpTokenIxAccounts;
    impl IntoProto<proto_def::MigrateMeteoraDammClaimLpTokenIxAccounts>
        for MigrateMeteoraDammClaimLpTokenIxAccounts
    {
        fn into_proto(self) -> proto_def::MigrateMeteoraDammClaimLpTokenIxAccounts {
            proto_def::MigrateMeteoraDammClaimLpTokenIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                pool_authority: self.pool_authority.to_string(),
                lp_mint: self.lp_mint.to_string(),
                source_token: self.source_token.to_string(),
                destination_token: self.destination_token.to_string(),
                owner: self.owner.to_string(),
                sender: self.sender.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::MigrateMeteoraDammLockLpTokenIxAccounts;
    impl IntoProto<proto_def::MigrateMeteoraDammLockLpTokenIxAccounts>
        for MigrateMeteoraDammLockLpTokenIxAccounts
    {
        fn into_proto(self) -> proto_def::MigrateMeteoraDammLockLpTokenIxAccounts {
            proto_def::MigrateMeteoraDammLockLpTokenIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                source_tokens: self.source_tokens.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                amm_program: self.amm_program.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::MigrationDammV2IxAccounts;
    impl IntoProto<proto_def::MigrationDammV2IxAccounts> for MigrationDammV2IxAccounts {
        fn into_proto(self) -> proto_def::MigrationDammV2IxAccounts {
            proto_def::MigrationDammV2IxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                first_position_nft_mint: self.first_position_nft_mint.to_string(),
                first_position_nft_account: self.first_position_nft_account.to_string(),
                first_position: self.first_position.to_string(),
                second_position_nft_mint: self.second_position_nft_mint.map(|p| p.to_string()),
                second_position_nft_account: self
                    .second_position_nft_account
                    .map(|p| p.to_string()),
                second_position: self.second_position.map(|p| p.to_string()),
                damm_pool_authority: self.damm_pool_authority.to_string(),
                amm_program: self.amm_program.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                payer: self.payer.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                token2022_program: self.token2022_program.to_string(),
                damm_event_authority: self.damm_event_authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::MigrationDammV2CreateMetadataIxAccounts;
    impl IntoProto<proto_def::MigrationDammV2CreateMetadataIxAccounts>
        for MigrationDammV2CreateMetadataIxAccounts
    {
        fn into_proto(self) -> proto_def::MigrationDammV2CreateMetadataIxAccounts {
            proto_def::MigrationDammV2CreateMetadataIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                config: self.config.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::MigrationMeteoraDammCreateMetadataIxAccounts;
    impl IntoProto<proto_def::MigrationMeteoraDammCreateMetadataIxAccounts>
        for MigrationMeteoraDammCreateMetadataIxAccounts
    {
        fn into_proto(self) -> proto_def::MigrationMeteoraDammCreateMetadataIxAccounts {
            proto_def::MigrationMeteoraDammCreateMetadataIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                config: self.config.to_string(),
                migration_metadata: self.migration_metadata.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::PartnerWithdrawSurplusIxAccounts;
    impl IntoProto<proto_def::PartnerWithdrawSurplusIxAccounts> for PartnerWithdrawSurplusIxAccounts {
        fn into_proto(self) -> proto_def::PartnerWithdrawSurplusIxAccounts {
            proto_def::PartnerWithdrawSurplusIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                virtual_pool: self.virtual_pool.to_string(),
                token_quote_account: self.token_quote_account.to_string(),
                quote_vault: self.quote_vault.to_string(),
                quote_mint: self.quote_mint.to_string(),
                fee_claimer: self.fee_claimer.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ProtocolWithdrawSurplusIxAccounts;
    impl IntoProto<proto_def::ProtocolWithdrawSurplusIxAccounts> for ProtocolWithdrawSurplusIxAccounts {
        fn into_proto(self) -> proto_def::ProtocolWithdrawSurplusIxAccounts {
            proto_def::ProtocolWithdrawSurplusIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                virtual_pool: self.virtual_pool.to_string(),
                token_quote_account: self.token_quote_account.to_string(),
                quote_vault: self.quote_vault.to_string(),
                quote_mint: self.quote_mint.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                pool: self.pool.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                payer: self.payer.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                referral_token_account: self.referral_token_account.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::Swap2IxAccounts;
    impl IntoProto<proto_def::Swap2IxAccounts> for Swap2IxAccounts {
        fn into_proto(self) -> proto_def::Swap2IxAccounts {
            proto_def::Swap2IxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                pool: self.pool.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                base_vault: self.base_vault.to_string(),
                quote_vault: self.quote_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                quote_mint: self.quote_mint.to_string(),
                payer: self.payer.to_string(),
                token_base_program: self.token_base_program.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                referral_token_account: self.referral_token_account.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::Swap2IxData;
    impl IntoProto<proto_def::Swap2IxData> for Swap2IxData {
        fn into_proto(self) -> proto_def::Swap2IxData {
            proto_def::Swap2IxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::TransferPoolCreatorIxAccounts;
    impl IntoProto<proto_def::TransferPoolCreatorIxAccounts> for TransferPoolCreatorIxAccounts {
        fn into_proto(self) -> proto_def::TransferPoolCreatorIxAccounts {
            proto_def::TransferPoolCreatorIxAccounts {
                virtual_pool: self.virtual_pool.to_string(),
                config: self.config.to_string(),
                creator: self.creator.to_string(),
                new_creator: self.new_creator.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::WithdrawLeftoverIxAccounts;
    impl IntoProto<proto_def::WithdrawLeftoverIxAccounts> for WithdrawLeftoverIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawLeftoverIxAccounts {
            proto_def::WithdrawLeftoverIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                virtual_pool: self.virtual_pool.to_string(),
                token_base_account: self.token_base_account.to_string(),
                base_vault: self.base_vault.to_string(),
                base_mint: self.base_mint.to_string(),
                leftover_receiver: self.leftover_receiver.to_string(),
                token_base_program: self.token_base_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::WithdrawMigrationFeeIxAccounts;
    impl IntoProto<proto_def::WithdrawMigrationFeeIxAccounts> for WithdrawMigrationFeeIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawMigrationFeeIxAccounts {
            proto_def::WithdrawMigrationFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                config: self.config.to_string(),
                virtual_pool: self.virtual_pool.to_string(),
                token_quote_account: self.token_quote_account.to_string(),
                quote_vault: self.quote_vault.to_string(),
                quote_mint: self.quote_mint.to_string(),
                sender: self.sender.to_string(),
                token_quote_program: self.token_quote_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::WithdrawMigrationFeeIxData;
    impl IntoProto<proto_def::WithdrawMigrationFeeIxData> for WithdrawMigrationFeeIxData {
        fn into_proto(self) -> proto_def::WithdrawMigrationFeeIxData {
            proto_def::WithdrawMigrationFeeIxData {
                flag: self.flag.into(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for DynamicBondingCurveProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                DynamicBondingCurveProgramIx::ClaimCreatorTradingFee(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimCreatorTradingFee(
                            proto_def::ClaimCreatorTradingFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::ClaimProtocolFee(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimProtocolFee(
                        proto_def::ClaimProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::ClaimTradingFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimTradingFee(
                        proto_def::ClaimTradingFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::CloseClaimFeeOperator(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseClaimFeeOperator(
                        proto_def::CloseClaimFeeOperatorIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::CreateClaimFeeOperator(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateClaimFeeOperator(
                            proto_def::CreateClaimFeeOperatorIx {
                                accounts: Some(acc.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::CreateConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateConfig(
                        proto_def::CreateConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::CreateLocker(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateLocker(
                        proto_def::CreateLockerIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::CreatePartnerMetadata(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatePartnerMetadata(
                            proto_def::CreatePartnerMetadataIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::CreateVirtualPoolMetadata(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateVirtualPoolMetadata(
                            proto_def::CreateVirtualPoolMetadataIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::CreatorWithdrawSurplus(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatorWithdrawSurplus(
                            proto_def::CreatorWithdrawSurplusIx {
                                accounts: Some(acc.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::InitializeVirtualPoolWithSplToken(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::InitializeVirtualPoolWithSplToken(
                                proto_def::InitializeVirtualPoolWithSplTokenIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::InitializeVirtualPoolWithToken2022(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::InitializeVirtualPoolWithToken2022(
                                proto_def::InitializeVirtualPoolWithToken2022Ix {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::MigrateMeteoraDamm(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::MigrateMeteoraDamm(
                        proto_def::MigrateMeteoraDammIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::MigrateMeteoraDammClaimLpToken(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::MigrateMeteoraDammClaimLpToken(
                                proto_def::MigrateMeteoraDammClaimLpTokenIx {
                                    accounts: Some(acc.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::MigrateMeteoraDammLockLpToken(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::MigrateMeteoraDammLockLpToken(
                                proto_def::MigrateMeteoraDammLockLpTokenIx {
                                    accounts: Some(acc.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::MigrationDammV2(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::MigrationDammV2(
                        proto_def::MigrationDammV2Ix {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::MigrationDammV2CreateMetadata(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::MigrationDammV2CreateMetadata(
                                proto_def::MigrationDammV2CreateMetadataIx {
                                    accounts: Some(acc.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::MigrationMeteoraDammCreateMetadata(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::MigrationMeteoraDammCreateMetadata(
                                proto_def::MigrationMeteoraDammCreateMetadataIx {
                                    accounts: Some(acc.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DynamicBondingCurveProgramIx::PartnerWithdrawSurplus(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::PartnerWithdrawSurplus(
                            proto_def::PartnerWithdrawSurplusIx {
                                accounts: Some(acc.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::ProtocolWithdrawSurplus(acc) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::ProtocolWithdrawSurplus(
                            proto_def::ProtocolWithdrawSurplusIx {
                                accounts: Some(acc.into_proto()),
                            },
                        )),
                    }
                },
                DynamicBondingCurveProgramIx::Swap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                DynamicBondingCurveProgramIx::Swap2(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap2(proto_def::Swap2Ix {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                DynamicBondingCurveProgramIx::TransferPoolCreator(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TransferPoolCreator(
                        proto_def::TransferPoolCreatorIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::WithdrawLeftover(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawLeftover(
                        proto_def::WithdrawLeftoverIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                DynamicBondingCurveProgramIx::WithdrawMigrationFee(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawMigrationFee(
                            proto_def::WithdrawMigrationFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
