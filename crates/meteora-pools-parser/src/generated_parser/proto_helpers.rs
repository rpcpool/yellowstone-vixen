//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

// #[cfg(feature = "proto")]
pub mod proto_types_parsers {
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use crate::{proto_def, types::TokenMultiplier};
    impl IntoProto<proto_def::TokenMultiplier> for TokenMultiplier {
        fn into_proto(self) -> proto_def::TokenMultiplier {
            proto_def::TokenMultiplier {
                token_a_multiplier: self.token_a_multiplier,
                token_b_multiplier: self.token_b_multiplier,
                precision_factor: self.precision_factor.into(),
            }
        }
    }
    use crate::types::PoolFees;
    impl IntoProto<proto_def::PoolFees> for PoolFees {
        fn into_proto(self) -> proto_def::PoolFees {
            proto_def::PoolFees {
                trade_fee_numerator: self.trade_fee_numerator,
                trade_fee_denominator: self.trade_fee_denominator,
                protocol_trade_fee_numerator: self.protocol_trade_fee_numerator,
                protocol_trade_fee_denominator: self.protocol_trade_fee_denominator,
            }
        }
    }
    use crate::types::Depeg;
    impl IntoProto<proto_def::Depeg> for Depeg {
        fn into_proto(self) -> proto_def::Depeg {
            proto_def::Depeg {
                base_virtual_price: self.base_virtual_price,
                base_cache_updated: self.base_cache_updated,
                depeg_type: self.depeg_type as i32,
            }
        }
    }
    use crate::types::Padding;
    impl IntoProto<proto_def::Padding> for Padding {
        fn into_proto(self) -> proto_def::Padding {
            proto_def::Padding {
                padding0: self.padding0.into_iter().map(|x| x.into()).collect(),
                padding1: self.padding1.to_vec(),
                padding2: self.padding2.to_vec(),
            }
        }
    }
    use crate::types::PartnerInfo;
    impl IntoProto<proto_def::PartnerInfo> for PartnerInfo {
        fn into_proto(self) -> proto_def::PartnerInfo {
            proto_def::PartnerInfo {
                fee_numerator: self.fee_numerator,
                partner_authority: self.partner_authority.to_string(),
                pending_fee_a: self.pending_fee_a,
                pending_fee_b: self.pending_fee_b,
            }
        }
    }
    use crate::types::Bootstrapping;
    impl IntoProto<proto_def::Bootstrapping> for Bootstrapping {
        fn into_proto(self) -> proto_def::Bootstrapping {
            proto_def::Bootstrapping {
                activation_point: self.activation_point,
                whitelisted_vault: self.whitelisted_vault.to_string(),
                pool_creator: self.pool_creator.to_string(),
                activation_type: self.activation_type.into(),
            }
        }
    }

    use proto_def::new_curve_type::Variant;

    use crate::types::NewCurveType;
    impl IntoProto<proto_def::NewCurveType> for NewCurveType {
        fn into_proto(self) -> proto_def::NewCurveType {
            let variant = match self {
                NewCurveType::ConstantProduct => {
                    Variant::ConstantProduct(proto_def::NewCurveTypeConstantProduct {})
                },
                NewCurveType::Stable {
                    amp,
                    token_multiplier,
                    depeg,
                    last_amp_updated_timestamp,
                } => Variant::Stable(proto_def::NewCurveTypeStable {
                    amp,
                    token_multiplier: Some(token_multiplier.into_proto()),
                    depeg: Some(depeg.into_proto()),
                    last_amp_updated_timestamp,
                }),
                NewCurveType::NewCurve {
                    field_one,
                    field_two,
                } => Variant::NewCurve(proto_def::NewCurveTypeNewCurve {
                    field_one,
                    field_two,
                }),
            };

            proto_def::NewCurveType {
                variant: Some(variant),
            }
        }
    }
    use proto_def::curve_type::Variant as CurveTypeVariant;

    use crate::types::CurveType;
    impl IntoProto<proto_def::CurveType> for CurveType {
        fn into_proto(self) -> proto_def::CurveType {
            let variant = match self {
                CurveType::ConstantProduct => {
                    CurveTypeVariant::ConstantProduct(proto_def::CurveTypeConstantProduct {})
                },
                CurveType::Stable {
                    amp,
                    token_multiplier,
                    depeg,
                    last_amp_updated_timestamp,
                } => CurveTypeVariant::Stable(proto_def::CurveTypeStable {
                    amp,
                    token_multiplier: Some(token_multiplier.into_proto()),
                    depeg: Some(depeg.into_proto()),
                    last_amp_updated_timestamp,
                }),
            };

            proto_def::CurveType {
                variant: Some(variant),
            }
        }
    }
}
