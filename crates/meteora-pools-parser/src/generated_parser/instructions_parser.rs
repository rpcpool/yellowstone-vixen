//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        AddBalanceLiquidity as AddBalanceLiquidityIxAccounts,
        AddBalanceLiquidityInstructionArgs as AddBalanceLiquidityIxData,
        AddImbalanceLiquidity as AddImbalanceLiquidityIxAccounts,
        AddImbalanceLiquidityInstructionArgs as AddImbalanceLiquidityIxData,
        BootstrapLiquidity as BootstrapLiquidityIxAccounts,
        BootstrapLiquidityInstructionArgs as BootstrapLiquidityIxData,
        ClaimFee as ClaimFeeIxAccounts, ClaimFeeInstructionArgs as ClaimFeeIxData,
        CloseConfig as CloseConfigIxAccounts, CreateConfig as CreateConfigIxAccounts,
        CreateConfigInstructionArgs as CreateConfigIxData,
        CreateLockEscrow as CreateLockEscrowIxAccounts,
        CreateMintMetadata as CreateMintMetadataIxAccounts,
        EnableOrDisablePool as EnableOrDisablePoolIxAccounts,
        EnableOrDisablePoolInstructionArgs as EnableOrDisablePoolIxData,
        GetPoolInfo as GetPoolInfoIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPool as InitializeCustomizablePermissionlessConstantProductPoolIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPoolInstructionArgs as InitializeCustomizablePermissionlessConstantProductPoolIxData,
        InitializePermissionedPool as InitializePermissionedPoolIxAccounts,
        InitializePermissionedPoolInstructionArgs as InitializePermissionedPoolIxData,
        InitializePermissionlessConstantProductPoolWithConfig as InitializePermissionlessConstantProductPoolWithConfigIxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2 as InitializePermissionlessConstantProductPoolWithConfig2IxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2InstructionArgs as InitializePermissionlessConstantProductPoolWithConfig2IxData,
        InitializePermissionlessConstantProductPoolWithConfigInstructionArgs as InitializePermissionlessConstantProductPoolWithConfigIxData,
        InitializePermissionlessPool as InitializePermissionlessPoolIxAccounts,
        InitializePermissionlessPoolInstructionArgs as InitializePermissionlessPoolIxData,
        InitializePermissionlessPoolWithFeeTier as InitializePermissionlessPoolWithFeeTierIxAccounts,
        InitializePermissionlessPoolWithFeeTierInstructionArgs as InitializePermissionlessPoolWithFeeTierIxData,
        Lock as LockIxAccounts, LockInstructionArgs as LockIxData,
        OverrideCurveParam as OverrideCurveParamIxAccounts,
        OverrideCurveParamInstructionArgs as OverrideCurveParamIxData,
        PartnerClaimFee as PartnerClaimFeeIxAccounts,
        PartnerClaimFeeInstructionArgs as PartnerClaimFeeIxData,
        RemoveBalanceLiquidity as RemoveBalanceLiquidityIxAccounts,
        RemoveBalanceLiquidityInstructionArgs as RemoveBalanceLiquidityIxData,
        RemoveLiquiditySingleSide as RemoveLiquiditySingleSideIxAccounts,
        RemoveLiquiditySingleSideInstructionArgs as RemoveLiquiditySingleSideIxData,
        SetPoolFees as SetPoolFeesIxAccounts, SetPoolFeesInstructionArgs as SetPoolFeesIxData,
        SetWhitelistedVault as SetWhitelistedVaultIxAccounts,
        SetWhitelistedVaultInstructionArgs as SetWhitelistedVaultIxData, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData,
        UpdateActivationPoint as UpdateActivationPointIxAccounts,
        UpdateActivationPointInstructionArgs as UpdateActivationPointIxData,
        WithdrawProtocolFees as WithdrawProtocolFeesIxAccounts,
    },
    ID,
};

/// Amm Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum AmmProgramIx {
    InitializePermissionedPool(
        InitializePermissionedPoolIxAccounts,
        InitializePermissionedPoolIxData,
    ),
    InitializePermissionlessPool(
        InitializePermissionlessPoolIxAccounts,
        InitializePermissionlessPoolIxData,
    ),
    InitializePermissionlessPoolWithFeeTier(
        InitializePermissionlessPoolWithFeeTierIxAccounts,
        InitializePermissionlessPoolWithFeeTierIxData,
    ),
    EnableOrDisablePool(EnableOrDisablePoolIxAccounts, EnableOrDisablePoolIxData),
    Swap(SwapIxAccounts, SwapIxData),
    RemoveLiquiditySingleSide(
        RemoveLiquiditySingleSideIxAccounts,
        RemoveLiquiditySingleSideIxData,
    ),
    AddImbalanceLiquidity(AddImbalanceLiquidityIxAccounts, AddImbalanceLiquidityIxData),
    RemoveBalanceLiquidity(
        RemoveBalanceLiquidityIxAccounts,
        RemoveBalanceLiquidityIxData,
    ),
    AddBalanceLiquidity(AddBalanceLiquidityIxAccounts, AddBalanceLiquidityIxData),
    SetPoolFees(SetPoolFeesIxAccounts, SetPoolFeesIxData),
    OverrideCurveParam(OverrideCurveParamIxAccounts, OverrideCurveParamIxData),
    GetPoolInfo(GetPoolInfoIxAccounts),
    BootstrapLiquidity(BootstrapLiquidityIxAccounts, BootstrapLiquidityIxData),
    CreateMintMetadata(CreateMintMetadataIxAccounts),
    CreateLockEscrow(CreateLockEscrowIxAccounts),
    Lock(LockIxAccounts, LockIxData),
    ClaimFee(ClaimFeeIxAccounts, ClaimFeeIxData),
    CreateConfig(CreateConfigIxAccounts, CreateConfigIxData),
    CloseConfig(CloseConfigIxAccounts),
    InitializePermissionlessConstantProductPoolWithConfig(
        InitializePermissionlessConstantProductPoolWithConfigIxAccounts,
        InitializePermissionlessConstantProductPoolWithConfigIxData,
    ),
    InitializePermissionlessConstantProductPoolWithConfig2(
        InitializePermissionlessConstantProductPoolWithConfig2IxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2IxData,
    ),
    InitializeCustomizablePermissionlessConstantProductPool(
        InitializeCustomizablePermissionlessConstantProductPoolIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPoolIxData,
    ),
    UpdateActivationPoint(UpdateActivationPointIxAccounts, UpdateActivationPointIxData),
    WithdrawProtocolFees(WithdrawProtocolFeesIxAccounts),
    SetWhitelistedVault(SetWhitelistedVaultIxAccounts, SetWhitelistedVaultIxData),
    PartnerClaimFee(PartnerClaimFeeIxAccounts, PartnerClaimFeeIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = AmmProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Amm::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<AmmProgramIx> {
        let accounts_len = ix.accounts.len();

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [77, 85, 178, 157, 50, 48, 212, 126] => {
                check_min_accounts_req(accounts_len, 24)?;
                let ix_accounts = InitializePermissionedPoolIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    token_a_mint: ix.accounts[2].0.into(),
                    token_b_mint: ix.accounts[3].0.into(),
                    a_vault: ix.accounts[4].0.into(),
                    b_vault: ix.accounts[5].0.into(),
                    a_vault_lp_mint: ix.accounts[6].0.into(),
                    b_vault_lp_mint: ix.accounts[7].0.into(),
                    a_vault_lp: ix.accounts[8].0.into(),
                    b_vault_lp: ix.accounts[9].0.into(),
                    admin_token_a: ix.accounts[10].0.into(),
                    admin_token_b: ix.accounts[11].0.into(),
                    admin_pool_lp: ix.accounts[12].0.into(),
                    protocol_token_a_fee: ix.accounts[13].0.into(),
                    protocol_token_b_fee: ix.accounts[14].0.into(),
                    admin: ix.accounts[15].0.into(),
                    fee_owner: ix.accounts[16].0.into(),
                    rent: ix.accounts[17].0.into(),
                    mint_metadata: ix.accounts[18].0.into(),
                    metadata_program: ix.accounts[19].0.into(),
                    vault_program: ix.accounts[20].0.into(),
                    token_program: ix.accounts[21].0.into(),
                    associated_token_program: ix.accounts[22].0.into(),
                    system_program: ix.accounts[23].0.into(),
                };
                let de_ix_data: InitializePermissionedPoolIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::InitializePermissionedPool(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [118, 173, 41, 157, 173, 72, 97, 103] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = InitializePermissionlessPoolIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    token_a_mint: ix.accounts[2].0.into(),
                    token_b_mint: ix.accounts[3].0.into(),
                    a_vault: ix.accounts[4].0.into(),
                    b_vault: ix.accounts[5].0.into(),
                    a_token_vault: ix.accounts[6].0.into(),
                    b_token_vault: ix.accounts[7].0.into(),
                    a_vault_lp_mint: ix.accounts[8].0.into(),
                    b_vault_lp_mint: ix.accounts[9].0.into(),
                    a_vault_lp: ix.accounts[10].0.into(),
                    b_vault_lp: ix.accounts[11].0.into(),
                    payer_token_a: ix.accounts[12].0.into(),
                    payer_token_b: ix.accounts[13].0.into(),
                    payer_pool_lp: ix.accounts[14].0.into(),
                    protocol_token_a_fee: ix.accounts[15].0.into(),
                    protocol_token_b_fee: ix.accounts[16].0.into(),
                    payer: ix.accounts[17].0.into(),
                    fee_owner: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                    mint_metadata: ix.accounts[20].0.into(),
                    metadata_program: ix.accounts[21].0.into(),
                    vault_program: ix.accounts[22].0.into(),
                    token_program: ix.accounts[23].0.into(),
                    associated_token_program: ix.accounts[24].0.into(),
                    system_program: ix.accounts[25].0.into(),
                };
                let de_ix_data: InitializePermissionlessPoolIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::InitializePermissionlessPool(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [6, 135, 68, 147, 229, 82, 169, 113] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = InitializePermissionlessPoolWithFeeTierIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    token_a_mint: ix.accounts[2].0.into(),
                    token_b_mint: ix.accounts[3].0.into(),
                    a_vault: ix.accounts[4].0.into(),
                    b_vault: ix.accounts[5].0.into(),
                    a_token_vault: ix.accounts[6].0.into(),
                    b_token_vault: ix.accounts[7].0.into(),
                    a_vault_lp_mint: ix.accounts[8].0.into(),
                    b_vault_lp_mint: ix.accounts[9].0.into(),
                    a_vault_lp: ix.accounts[10].0.into(),
                    b_vault_lp: ix.accounts[11].0.into(),
                    payer_token_a: ix.accounts[12].0.into(),
                    payer_token_b: ix.accounts[13].0.into(),
                    payer_pool_lp: ix.accounts[14].0.into(),
                    protocol_token_a_fee: ix.accounts[15].0.into(),
                    protocol_token_b_fee: ix.accounts[16].0.into(),
                    payer: ix.accounts[17].0.into(),
                    fee_owner: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                    mint_metadata: ix.accounts[20].0.into(),
                    metadata_program: ix.accounts[21].0.into(),
                    vault_program: ix.accounts[22].0.into(),
                    token_program: ix.accounts[23].0.into(),
                    associated_token_program: ix.accounts[24].0.into(),
                    system_program: ix.accounts[25].0.into(),
                };
                let de_ix_data: InitializePermissionlessPoolWithFeeTierIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::InitializePermissionlessPoolWithFeeTier(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [128, 6, 228, 131, 55, 161, 52, 169] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = EnableOrDisablePoolIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: EnableOrDisablePoolIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::EnableOrDisablePool(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = SwapIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    user_source_token: ix.accounts[1].0.into(),
                    user_destination_token: ix.accounts[2].0.into(),
                    a_vault: ix.accounts[3].0.into(),
                    b_vault: ix.accounts[4].0.into(),
                    a_token_vault: ix.accounts[5].0.into(),
                    b_token_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_vault_lp: ix.accounts[9].0.into(),
                    b_vault_lp: ix.accounts[10].0.into(),
                    protocol_token_fee: ix.accounts[11].0.into(),
                    user: ix.accounts[12].0.into(),
                    vault_program: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: SwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::Swap(ix_accounts, de_ix_data))
            },
            [84, 84, 177, 66, 254, 185, 10, 251] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = RemoveLiquiditySingleSideIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    user_pool_lp: ix.accounts[2].0.into(),
                    a_vault_lp: ix.accounts[3].0.into(),
                    b_vault_lp: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_token_vault: ix.accounts[9].0.into(),
                    b_token_vault: ix.accounts[10].0.into(),
                    user_destination_token: ix.accounts[11].0.into(),
                    user: ix.accounts[12].0.into(),
                    vault_program: ix.accounts[13].0.into(),
                    token_program: ix.accounts[14].0.into(),
                };
                let de_ix_data: RemoveLiquiditySingleSideIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::RemoveLiquiditySingleSide(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [79, 35, 122, 84, 173, 15, 93, 191] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = AddImbalanceLiquidityIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    user_pool_lp: ix.accounts[2].0.into(),
                    a_vault_lp: ix.accounts[3].0.into(),
                    b_vault_lp: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_token_vault: ix.accounts[9].0.into(),
                    b_token_vault: ix.accounts[10].0.into(),
                    user_a_token: ix.accounts[11].0.into(),
                    user_b_token: ix.accounts[12].0.into(),
                    user: ix.accounts[13].0.into(),
                    vault_program: ix.accounts[14].0.into(),
                    token_program: ix.accounts[15].0.into(),
                };
                let de_ix_data: AddImbalanceLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::AddImbalanceLiquidity(ix_accounts, de_ix_data))
            },
            [133, 109, 44, 179, 56, 238, 114, 33] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = RemoveBalanceLiquidityIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    user_pool_lp: ix.accounts[2].0.into(),
                    a_vault_lp: ix.accounts[3].0.into(),
                    b_vault_lp: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_token_vault: ix.accounts[9].0.into(),
                    b_token_vault: ix.accounts[10].0.into(),
                    user_a_token: ix.accounts[11].0.into(),
                    user_b_token: ix.accounts[12].0.into(),
                    user: ix.accounts[13].0.into(),
                    vault_program: ix.accounts[14].0.into(),
                    token_program: ix.accounts[15].0.into(),
                };
                let de_ix_data: RemoveBalanceLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::RemoveBalanceLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [168, 227, 50, 62, 189, 171, 84, 176] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = AddBalanceLiquidityIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    user_pool_lp: ix.accounts[2].0.into(),
                    a_vault_lp: ix.accounts[3].0.into(),
                    b_vault_lp: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_token_vault: ix.accounts[9].0.into(),
                    b_token_vault: ix.accounts[10].0.into(),
                    user_a_token: ix.accounts[11].0.into(),
                    user_b_token: ix.accounts[12].0.into(),
                    user: ix.accounts[13].0.into(),
                    vault_program: ix.accounts[14].0.into(),
                    token_program: ix.accounts[15].0.into(),
                };
                let de_ix_data: AddBalanceLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::AddBalanceLiquidity(ix_accounts, de_ix_data))
            },
            [102, 44, 158, 54, 205, 37, 126, 78] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetPoolFeesIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    fee_operator: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetPoolFeesIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::SetPoolFees(ix_accounts, de_ix_data))
            },
            [98, 86, 204, 51, 94, 71, 69, 187] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = OverrideCurveParamIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: OverrideCurveParamIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::OverrideCurveParam(ix_accounts, de_ix_data))
            },
            [9, 48, 220, 101, 22, 240, 78, 200] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = GetPoolInfoIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    a_vault_lp: ix.accounts[2].0.into(),
                    b_vault_lp: ix.accounts[3].0.into(),
                    a_vault: ix.accounts[4].0.into(),
                    b_vault: ix.accounts[5].0.into(),
                    a_vault_lp_mint: ix.accounts[6].0.into(),
                    b_vault_lp_mint: ix.accounts[7].0.into(),
                };
                Ok(AmmProgramIx::GetPoolInfo(ix_accounts))
            },
            [4, 228, 215, 71, 225, 253, 119, 206] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = BootstrapLiquidityIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    user_pool_lp: ix.accounts[2].0.into(),
                    a_vault_lp: ix.accounts[3].0.into(),
                    b_vault_lp: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_vault_lp_mint: ix.accounts[7].0.into(),
                    b_vault_lp_mint: ix.accounts[8].0.into(),
                    a_token_vault: ix.accounts[9].0.into(),
                    b_token_vault: ix.accounts[10].0.into(),
                    user_a_token: ix.accounts[11].0.into(),
                    user_b_token: ix.accounts[12].0.into(),
                    user: ix.accounts[13].0.into(),
                    vault_program: ix.accounts[14].0.into(),
                    token_program: ix.accounts[15].0.into(),
                };
                let de_ix_data: BootstrapLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::BootstrapLiquidity(ix_accounts, de_ix_data))
            },
            [13, 70, 168, 41, 250, 100, 148, 90] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CreateMintMetadataIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    a_vault_lp: ix.accounts[2].0.into(),
                    mint_metadata: ix.accounts[3].0.into(),
                    metadata_program: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                    payer: ix.accounts[6].0.into(),
                };
                Ok(AmmProgramIx::CreateMintMetadata(ix_accounts))
            },
            [54, 87, 165, 19, 69, 227, 218, 224] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CreateLockEscrowIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lock_escrow: ix.accounts[1].0.into(),
                    owner: ix.accounts[2].0.into(),
                    lp_mint: ix.accounts[3].0.into(),
                    payer: ix.accounts[4].0.into(),
                    system_program: ix.accounts[5].0.into(),
                };
                Ok(AmmProgramIx::CreateLockEscrow(ix_accounts))
            },
            [21, 19, 208, 43, 237, 62, 255, 87] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = LockIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    lock_escrow: ix.accounts[2].0.into(),
                    owner: ix.accounts[3].0.into(),
                    source_tokens: ix.accounts[4].0.into(),
                    escrow_vault: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    a_vault: ix.accounts[7].0.into(),
                    b_vault: ix.accounts[8].0.into(),
                    a_vault_lp: ix.accounts[9].0.into(),
                    b_vault_lp: ix.accounts[10].0.into(),
                    a_vault_lp_mint: ix.accounts[11].0.into(),
                    b_vault_lp_mint: ix.accounts[12].0.into(),
                };
                let de_ix_data: LockIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::Lock(ix_accounts, de_ix_data))
            },
            [169, 32, 79, 137, 136, 232, 70, 137] => {
                check_min_accounts_req(accounts_len, 18)?;
                let ix_accounts = ClaimFeeIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    lp_mint: ix.accounts[1].0.into(),
                    lock_escrow: ix.accounts[2].0.into(),
                    owner: ix.accounts[3].0.into(),
                    source_tokens: ix.accounts[4].0.into(),
                    escrow_vault: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    a_token_vault: ix.accounts[7].0.into(),
                    b_token_vault: ix.accounts[8].0.into(),
                    a_vault: ix.accounts[9].0.into(),
                    b_vault: ix.accounts[10].0.into(),
                    a_vault_lp: ix.accounts[11].0.into(),
                    b_vault_lp: ix.accounts[12].0.into(),
                    a_vault_lp_mint: ix.accounts[13].0.into(),
                    b_vault_lp_mint: ix.accounts[14].0.into(),
                    user_a_token: ix.accounts[15].0.into(),
                    user_b_token: ix.accounts[16].0.into(),
                    vault_program: ix.accounts[17].0.into(),
                };
                let de_ix_data: ClaimFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::ClaimFee(ix_accounts, de_ix_data))
            },
            [201, 207, 243, 114, 75, 111, 47, 189] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: CreateConfigIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::CreateConfig(ix_accounts, de_ix_data))
            },
            [145, 9, 72, 157, 95, 125, 61, 85] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CloseConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    rent_receiver: ix.accounts[2].0.into(),
                };
                Ok(AmmProgramIx::CloseConfig(ix_accounts))
            },
            [7, 166, 138, 171, 206, 171, 236, 244] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts = InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    config: ix.accounts[1].0.into(),
                    lp_mint: ix.accounts[2].0.into(),
                    token_a_mint: ix.accounts[3].0.into(),
                    token_b_mint: ix.accounts[4].0.into(),
                    a_vault: ix.accounts[5].0.into(),
                    b_vault: ix.accounts[6].0.into(),
                    a_token_vault: ix.accounts[7].0.into(),
                    b_token_vault: ix.accounts[8].0.into(),
                    a_vault_lp_mint: ix.accounts[9].0.into(),
                    b_vault_lp_mint: ix.accounts[10].0.into(),
                    a_vault_lp: ix.accounts[11].0.into(),
                    b_vault_lp: ix.accounts[12].0.into(),
                    payer_token_a: ix.accounts[13].0.into(),
                    payer_token_b: ix.accounts[14].0.into(),
                    payer_pool_lp: ix.accounts[15].0.into(),
                    protocol_token_a_fee: ix.accounts[16].0.into(),
                    protocol_token_b_fee: ix.accounts[17].0.into(),
                    payer: ix.accounts[18].0.into(),
                    rent: ix.accounts[19].0.into(),
                    mint_metadata: ix.accounts[20].0.into(),
                    metadata_program: ix.accounts[21].0.into(),
                    vault_program: ix.accounts[22].0.into(),
                    token_program: ix.accounts[23].0.into(),
                    associated_token_program: ix.accounts[24].0.into(),
                    system_program: ix.accounts[25].0.into(),
                };
                let de_ix_data: InitializePermissionlessConstantProductPoolWithConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(
                    AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [48, 149, 220, 130, 61, 11, 9, 178] => {
                check_min_accounts_req(accounts_len, 26)?;
                let ix_accounts =
                    InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
                        pool: ix.accounts[0].0.into(),
                        config: ix.accounts[1].0.into(),
                        lp_mint: ix.accounts[2].0.into(),
                        token_a_mint: ix.accounts[3].0.into(),
                        token_b_mint: ix.accounts[4].0.into(),
                        a_vault: ix.accounts[5].0.into(),
                        b_vault: ix.accounts[6].0.into(),
                        a_token_vault: ix.accounts[7].0.into(),
                        b_token_vault: ix.accounts[8].0.into(),
                        a_vault_lp_mint: ix.accounts[9].0.into(),
                        b_vault_lp_mint: ix.accounts[10].0.into(),
                        a_vault_lp: ix.accounts[11].0.into(),
                        b_vault_lp: ix.accounts[12].0.into(),
                        payer_token_a: ix.accounts[13].0.into(),
                        payer_token_b: ix.accounts[14].0.into(),
                        payer_pool_lp: ix.accounts[15].0.into(),
                        protocol_token_a_fee: ix.accounts[16].0.into(),
                        protocol_token_b_fee: ix.accounts[17].0.into(),
                        payer: ix.accounts[18].0.into(),
                        rent: ix.accounts[19].0.into(),
                        mint_metadata: ix.accounts[20].0.into(),
                        metadata_program: ix.accounts[21].0.into(),
                        vault_program: ix.accounts[22].0.into(),
                        token_program: ix.accounts[23].0.into(),
                        associated_token_program: ix.accounts[24].0.into(),
                        system_program: ix.accounts[25].0.into(),
                    };
                let de_ix_data: InitializePermissionlessConstantProductPoolWithConfig2IxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(
                    AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig2(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [145, 24, 172, 194, 219, 125, 3, 190] => {
                check_min_accounts_req(accounts_len, 25)?;
                let ix_accounts =
                    InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
                        pool: ix.accounts[0].0.into(),
                        lp_mint: ix.accounts[1].0.into(),
                        token_a_mint: ix.accounts[2].0.into(),
                        token_b_mint: ix.accounts[3].0.into(),
                        a_vault: ix.accounts[4].0.into(),
                        b_vault: ix.accounts[5].0.into(),
                        a_token_vault: ix.accounts[6].0.into(),
                        b_token_vault: ix.accounts[7].0.into(),
                        a_vault_lp_mint: ix.accounts[8].0.into(),
                        b_vault_lp_mint: ix.accounts[9].0.into(),
                        a_vault_lp: ix.accounts[10].0.into(),
                        b_vault_lp: ix.accounts[11].0.into(),
                        payer_token_a: ix.accounts[12].0.into(),
                        payer_token_b: ix.accounts[13].0.into(),
                        payer_pool_lp: ix.accounts[14].0.into(),
                        protocol_token_a_fee: ix.accounts[15].0.into(),
                        protocol_token_b_fee: ix.accounts[16].0.into(),
                        payer: ix.accounts[17].0.into(),
                        rent: ix.accounts[18].0.into(),
                        mint_metadata: ix.accounts[19].0.into(),
                        metadata_program: ix.accounts[20].0.into(),
                        vault_program: ix.accounts[21].0.into(),
                        token_program: ix.accounts[22].0.into(),
                        associated_token_program: ix.accounts[23].0.into(),
                        system_program: ix.accounts[24].0.into(),
                    };
                let de_ix_data: InitializeCustomizablePermissionlessConstantProductPoolIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(
                    AmmProgramIx::InitializeCustomizablePermissionlessConstantProductPool(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [150, 62, 125, 219, 171, 220, 26, 237] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = UpdateActivationPointIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: UpdateActivationPointIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::UpdateActivationPoint(ix_accounts, de_ix_data))
            },
            [11, 68, 165, 98, 18, 208, 134, 73] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = WithdrawProtocolFeesIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    a_vault_lp: ix.accounts[1].0.into(),
                    protocol_token_a_fee: ix.accounts[2].0.into(),
                    protocol_token_b_fee: ix.accounts[3].0.into(),
                    treasury_token_a: ix.accounts[4].0.into(),
                    treasury_token_b: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                };
                Ok(AmmProgramIx::WithdrawProtocolFees(ix_accounts))
            },
            [12, 148, 94, 42, 55, 57, 83, 247] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetWhitelistedVaultIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                };
                let de_ix_data: SetWhitelistedVaultIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::SetWhitelistedVault(ix_accounts, de_ix_data))
            },
            [57, 53, 176, 30, 123, 70, 52, 64] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = PartnerClaimFeeIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    a_vault_lp: ix.accounts[1].0.into(),
                    protocol_token_a_fee: ix.accounts[2].0.into(),
                    protocol_token_b_fee: ix.accounts[3].0.into(),
                    partner_token_a: ix.accounts[4].0.into(),
                    partner_token_b: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    partner_authority: ix.accounts[7].0.into(),
                };
                let de_ix_data: PartnerClaimFeeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(AmmProgramIx::PartnerClaimFee(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        ix
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AmmProgramIx, InitializePermissionedPoolIxAccounts, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::InitializePermissionedPoolIxAccounts>
        for InitializePermissionedPoolIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionedPoolIxAccounts {
            proto_def::InitializePermissionedPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                admin_token_a: self.admin_token_a.to_string(),
                admin_token_b: self.admin_token_b.to_string(),
                admin_pool_lp: self.admin_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                admin: self.admin.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionedPoolIxData;
    impl IntoProto<proto_def::InitializePermissionedPoolIxData> for InitializePermissionedPoolIxData {
        fn into_proto(self) -> proto_def::InitializePermissionedPoolIxData {
            proto_def::InitializePermissionedPoolIxData {
                curve_type: Some(self.curve_type.into_proto()),
            }
        }
    }
    use super::InitializePermissionlessPoolIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessPoolIxAccounts>
        for InitializePermissionlessPoolIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolIxAccounts {
            proto_def::InitializePermissionlessPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessPoolIxData;
    impl IntoProto<proto_def::InitializePermissionlessPoolIxData>
        for InitializePermissionlessPoolIxData
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolIxData {
            proto_def::InitializePermissionlessPoolIxData {
                curve_type: Some(self.curve_type.into_proto()),
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::InitializePermissionlessPoolWithFeeTierIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts>
        for InitializePermissionlessPoolWithFeeTierIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts {
            proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessPoolWithFeeTierIxData;
    impl IntoProto<proto_def::InitializePermissionlessPoolWithFeeTierIxData>
        for InitializePermissionlessPoolWithFeeTierIxData
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolWithFeeTierIxData {
            proto_def::InitializePermissionlessPoolWithFeeTierIxData {
                curve_type: Some(self.curve_type.into_proto()),
                trade_fee_bps: self.trade_fee_bps,
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::EnableOrDisablePoolIxAccounts;
    impl IntoProto<proto_def::EnableOrDisablePoolIxAccounts> for EnableOrDisablePoolIxAccounts {
        fn into_proto(self) -> proto_def::EnableOrDisablePoolIxAccounts {
            proto_def::EnableOrDisablePoolIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::EnableOrDisablePoolIxData;
    impl IntoProto<proto_def::EnableOrDisablePoolIxData> for EnableOrDisablePoolIxData {
        fn into_proto(self) -> proto_def::EnableOrDisablePoolIxData {
            proto_def::EnableOrDisablePoolIxData {
                enable: self.enable,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                pool: self.pool.to_string(),
                user_source_token: self.user_source_token.to_string(),
                user_destination_token: self.user_destination_token.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                protocol_token_fee: self.protocol_token_fee.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                in_amount: self.in_amount,
                minimum_out_amount: self.minimum_out_amount,
            }
        }
    }
    use super::RemoveLiquiditySingleSideIxAccounts;
    impl IntoProto<proto_def::RemoveLiquiditySingleSideIxAccounts>
        for RemoveLiquiditySingleSideIxAccounts
    {
        fn into_proto(self) -> proto_def::RemoveLiquiditySingleSideIxAccounts {
            proto_def::RemoveLiquiditySingleSideIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_destination_token: self.user_destination_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::RemoveLiquiditySingleSideIxData;
    impl IntoProto<proto_def::RemoveLiquiditySingleSideIxData> for RemoveLiquiditySingleSideIxData {
        fn into_proto(self) -> proto_def::RemoveLiquiditySingleSideIxData {
            proto_def::RemoveLiquiditySingleSideIxData {
                pool_token_amount: self.pool_token_amount,
                minimum_out_amount: self.minimum_out_amount,
            }
        }
    }
    use super::AddImbalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::AddImbalanceLiquidityIxAccounts> for AddImbalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::AddImbalanceLiquidityIxAccounts {
            proto_def::AddImbalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::AddImbalanceLiquidityIxData;
    impl IntoProto<proto_def::AddImbalanceLiquidityIxData> for AddImbalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::AddImbalanceLiquidityIxData {
            proto_def::AddImbalanceLiquidityIxData {
                minimum_pool_token_amount: self.minimum_pool_token_amount,
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::RemoveBalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::RemoveBalanceLiquidityIxAccounts> for RemoveBalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::RemoveBalanceLiquidityIxAccounts {
            proto_def::RemoveBalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::RemoveBalanceLiquidityIxData;
    impl IntoProto<proto_def::RemoveBalanceLiquidityIxData> for RemoveBalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::RemoveBalanceLiquidityIxData {
            proto_def::RemoveBalanceLiquidityIxData {
                pool_token_amount: self.pool_token_amount,
                minimum_a_token_out: self.minimum_a_token_out,
                minimum_b_token_out: self.minimum_b_token_out,
            }
        }
    }
    use super::AddBalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::AddBalanceLiquidityIxAccounts> for AddBalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::AddBalanceLiquidityIxAccounts {
            proto_def::AddBalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::AddBalanceLiquidityIxData;
    impl IntoProto<proto_def::AddBalanceLiquidityIxData> for AddBalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::AddBalanceLiquidityIxData {
            proto_def::AddBalanceLiquidityIxData {
                pool_token_amount: self.pool_token_amount,
                maximum_token_a_amount: self.maximum_token_a_amount,
                maximum_token_b_amount: self.maximum_token_b_amount,
            }
        }
    }
    use super::SetPoolFeesIxAccounts;
    impl IntoProto<proto_def::SetPoolFeesIxAccounts> for SetPoolFeesIxAccounts {
        fn into_proto(self) -> proto_def::SetPoolFeesIxAccounts {
            proto_def::SetPoolFeesIxAccounts {
                pool: self.pool.to_string(),
                fee_operator: self.fee_operator.to_string(),
            }
        }
    }
    use super::SetPoolFeesIxData;
    impl IntoProto<proto_def::SetPoolFeesIxData> for SetPoolFeesIxData {
        fn into_proto(self) -> proto_def::SetPoolFeesIxData {
            proto_def::SetPoolFeesIxData {
                fees: Some(self.fees.into_proto()),
                new_partner_fee_numerator: self.new_partner_fee_numerator,
            }
        }
    }
    use super::OverrideCurveParamIxAccounts;
    impl IntoProto<proto_def::OverrideCurveParamIxAccounts> for OverrideCurveParamIxAccounts {
        fn into_proto(self) -> proto_def::OverrideCurveParamIxAccounts {
            proto_def::OverrideCurveParamIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::OverrideCurveParamIxData;
    impl IntoProto<proto_def::OverrideCurveParamIxData> for OverrideCurveParamIxData {
        fn into_proto(self) -> proto_def::OverrideCurveParamIxData {
            proto_def::OverrideCurveParamIxData {
                curve_type: Some(self.curve_type.into_proto()),
            }
        }
    }
    use super::GetPoolInfoIxAccounts;
    impl IntoProto<proto_def::GetPoolInfoIxAccounts> for GetPoolInfoIxAccounts {
        fn into_proto(self) -> proto_def::GetPoolInfoIxAccounts {
            proto_def::GetPoolInfoIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
            }
        }
    }
    use super::BootstrapLiquidityIxAccounts;
    impl IntoProto<proto_def::BootstrapLiquidityIxAccounts> for BootstrapLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::BootstrapLiquidityIxAccounts {
            proto_def::BootstrapLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::BootstrapLiquidityIxData;
    impl IntoProto<proto_def::BootstrapLiquidityIxData> for BootstrapLiquidityIxData {
        fn into_proto(self) -> proto_def::BootstrapLiquidityIxData {
            proto_def::BootstrapLiquidityIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::CreateMintMetadataIxAccounts;
    impl IntoProto<proto_def::CreateMintMetadataIxAccounts> for CreateMintMetadataIxAccounts {
        fn into_proto(self) -> proto_def::CreateMintMetadataIxAccounts {
            proto_def::CreateMintMetadataIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                system_program: self.system_program.to_string(),
                payer: self.payer.to_string(),
            }
        }
    }
    use super::CreateLockEscrowIxAccounts;
    impl IntoProto<proto_def::CreateLockEscrowIxAccounts> for CreateLockEscrowIxAccounts {
        fn into_proto(self) -> proto_def::CreateLockEscrowIxAccounts {
            proto_def::CreateLockEscrowIxAccounts {
                pool: self.pool.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                lp_mint: self.lp_mint.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::LockIxAccounts;
    impl IntoProto<proto_def::LockIxAccounts> for LockIxAccounts {
        fn into_proto(self) -> proto_def::LockIxAccounts {
            proto_def::LockIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                source_tokens: self.source_tokens.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_program: self.token_program.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
            }
        }
    }
    use super::LockIxData;
    impl IntoProto<proto_def::LockIxData> for LockIxData {
        fn into_proto(self) -> proto_def::LockIxData {
            proto_def::LockIxData {
                max_amount: self.max_amount,
            }
        }
    }
    use super::ClaimFeeIxAccounts;
    impl IntoProto<proto_def::ClaimFeeIxAccounts> for ClaimFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimFeeIxAccounts {
            proto_def::ClaimFeeIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                source_tokens: self.source_tokens.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_program: self.token_program.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                vault_program: self.vault_program.to_string(),
            }
        }
    }
    use super::ClaimFeeIxData;
    impl IntoProto<proto_def::ClaimFeeIxData> for ClaimFeeIxData {
        fn into_proto(self) -> proto_def::ClaimFeeIxData {
            proto_def::ClaimFeeIxData {
                max_amount: self.max_amount,
            }
        }
    }
    use super::CreateConfigIxAccounts;
    impl IntoProto<proto_def::CreateConfigIxAccounts> for CreateConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateConfigIxAccounts {
            proto_def::CreateConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateConfigIxData;
    impl IntoProto<proto_def::CreateConfigIxData> for CreateConfigIxData {
        fn into_proto(self) -> proto_def::CreateConfigIxData {
            proto_def::CreateConfigIxData {
                trade_fee_numerator: self.trade_fee_numerator,
                protocol_trade_fee_numerator: self.protocol_trade_fee_numerator,
                activation_duration: self.activation_duration,
                vault_config_key: self.vault_config_key.to_string(),
                pool_creator_authority: self.pool_creator_authority.to_string(),
                activation_type: self.activation_type.into(),
                index: self.index,
                partner_fee_numerator: self.partner_fee_numerator,
            }
        }
    }
    use super::CloseConfigIxAccounts;
    impl IntoProto<proto_def::CloseConfigIxAccounts> for CloseConfigIxAccounts {
        fn into_proto(self) -> proto_def::CloseConfigIxAccounts {
            proto_def::CloseConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfigIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts>
        for InitializePermissionlessConstantProductPoolWithConfigIxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
            proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
                pool: self.pool.to_string(),
                config: self.config.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfigIxData;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData>
        for InitializePermissionlessConstantProductPoolWithConfigIxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData {
            proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts>
        for InitializePermissionlessConstantProductPoolWithConfig2IxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
            proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
                pool: self.pool.to_string(),
                config: self.config.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfig2IxData;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData>
        for InitializePermissionlessConstantProductPoolWithConfig2IxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData {
            proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
                activation_point: self.activation_point,
            }
        }
    }
    use super::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts;
    impl IntoProto<proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts>
        for InitializeCustomizablePermissionlessConstantProductPoolIxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
            proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeCustomizablePermissionlessConstantProductPoolIxData;
    impl IntoProto<proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData>
        for InitializeCustomizablePermissionlessConstantProductPoolIxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData {
            proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
                trade_fee_numerator: self.trade_fee_numerator,
                activation_point: self.activation_point,
                has_alpha_vault: self.has_alpha_vault,
                activation_type: self.activation_type.into(),
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::UpdateActivationPointIxAccounts;
    impl IntoProto<proto_def::UpdateActivationPointIxAccounts> for UpdateActivationPointIxAccounts {
        fn into_proto(self) -> proto_def::UpdateActivationPointIxAccounts {
            proto_def::UpdateActivationPointIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::UpdateActivationPointIxData;
    impl IntoProto<proto_def::UpdateActivationPointIxData> for UpdateActivationPointIxData {
        fn into_proto(self) -> proto_def::UpdateActivationPointIxData {
            proto_def::UpdateActivationPointIxData {
                new_activation_point: self.new_activation_point,
            }
        }
    }
    use super::WithdrawProtocolFeesIxAccounts;
    impl IntoProto<proto_def::WithdrawProtocolFeesIxAccounts> for WithdrawProtocolFeesIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawProtocolFeesIxAccounts {
            proto_def::WithdrawProtocolFeesIxAccounts {
                pool: self.pool.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                treasury_token_a: self.treasury_token_a.to_string(),
                treasury_token_b: self.treasury_token_b.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::SetWhitelistedVaultIxAccounts;
    impl IntoProto<proto_def::SetWhitelistedVaultIxAccounts> for SetWhitelistedVaultIxAccounts {
        fn into_proto(self) -> proto_def::SetWhitelistedVaultIxAccounts {
            proto_def::SetWhitelistedVaultIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::SetWhitelistedVaultIxData;
    impl IntoProto<proto_def::SetWhitelistedVaultIxData> for SetWhitelistedVaultIxData {
        fn into_proto(self) -> proto_def::SetWhitelistedVaultIxData {
            proto_def::SetWhitelistedVaultIxData {
                whitelisted_vault: self.whitelisted_vault.to_string(),
            }
        }
    }
    use super::PartnerClaimFeeIxAccounts;
    impl IntoProto<proto_def::PartnerClaimFeeIxAccounts> for PartnerClaimFeeIxAccounts {
        fn into_proto(self) -> proto_def::PartnerClaimFeeIxAccounts {
            proto_def::PartnerClaimFeeIxAccounts {
                pool: self.pool.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                partner_token_a: self.partner_token_a.to_string(),
                partner_token_b: self.partner_token_b.to_string(),
                token_program: self.token_program.to_string(),
                partner_authority: self.partner_authority.to_string(),
            }
        }
    }
    use super::PartnerClaimFeeIxData;
    impl IntoProto<proto_def::PartnerClaimFeeIxData> for PartnerClaimFeeIxData {
        fn into_proto(self) -> proto_def::PartnerClaimFeeIxData {
            proto_def::PartnerClaimFeeIxData {
                max_amount_a: self.max_amount_a,
                max_amount_b: self.max_amount_b,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for AmmProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                                                            AmmProgramIx::InitializePermissionedPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionedPool(proto_def::InitializePermissionedPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessPool(proto_def::InitializePermissionlessPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessPoolWithFeeTier(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessPoolWithFeeTier(proto_def::InitializePermissionlessPoolWithFeeTierIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::EnableOrDisablePool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::EnableOrDisablePool(proto_def::EnableOrDisablePoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::Swap(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::RemoveLiquiditySingleSide(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveLiquiditySingleSide(proto_def::RemoveLiquiditySingleSideIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::AddImbalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::AddImbalanceLiquidity(proto_def::AddImbalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::RemoveBalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveBalanceLiquidity(proto_def::RemoveBalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::AddBalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::AddBalanceLiquidity(proto_def::AddBalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::SetPoolFees(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::SetPoolFees(proto_def::SetPoolFeesIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::OverrideCurveParam(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::OverrideCurveParam(proto_def::OverrideCurveParamIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::GetPoolInfo(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::GetPoolInfo(proto_def::GetPoolInfoIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::BootstrapLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::BootstrapLiquidity(proto_def::BootstrapLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateMintMetadata(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateMintMetadata(proto_def::CreateMintMetadataIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateLockEscrow(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateLockEscrow(proto_def::CreateLockEscrowIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::Lock(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::Lock(proto_def::LockIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::ClaimFee(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimFee(proto_def::ClaimFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateConfig(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateConfig(proto_def::CreateConfigIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CloseConfig(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseConfig(proto_def::CloseConfigIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessConstantProductPoolWithConfig(proto_def::InitializePermissionlessConstantProductPoolWithConfigIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig2(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessConstantProductPoolWithConfig2(proto_def::InitializePermissionlessConstantProductPoolWithConfig2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializeCustomizablePermissionlessConstantProductPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeCustomizablePermissionlessConstantProductPool(proto_def::InitializeCustomizablePermissionlessConstantProductPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::UpdateActivationPoint(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateActivationPoint(proto_def::UpdateActivationPointIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::WithdrawProtocolFees(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawProtocolFees(proto_def::WithdrawProtocolFeesIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::SetWhitelistedVault(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::SetWhitelistedVault(proto_def::SetWhitelistedVaultIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::PartnerClaimFee(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::PartnerClaimFee(proto_def::PartnerClaimFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
