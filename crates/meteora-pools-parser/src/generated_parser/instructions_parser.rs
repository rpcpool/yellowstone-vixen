//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

use yellowstone_vixen_core::constants::is_known_aggregator;
#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated::types::SwapEvent,
    instructions::{
        AddBalanceLiquidity as AddBalanceLiquidityIxAccounts,
        AddBalanceLiquidityInstructionArgs as AddBalanceLiquidityIxData,
        AddImbalanceLiquidity as AddImbalanceLiquidityIxAccounts,
        AddImbalanceLiquidityInstructionArgs as AddImbalanceLiquidityIxData,
        BootstrapLiquidity as BootstrapLiquidityIxAccounts,
        BootstrapLiquidityInstructionArgs as BootstrapLiquidityIxData,
        ClaimFee as ClaimFeeIxAccounts, ClaimFeeInstructionArgs as ClaimFeeIxData,
        CloseConfig as CloseConfigIxAccounts, CreateConfig as CreateConfigIxAccounts,
        CreateConfigInstructionArgs as CreateConfigIxData,
        CreateLockEscrow as CreateLockEscrowIxAccounts,
        CreateMintMetadata as CreateMintMetadataIxAccounts,
        EnableOrDisablePool as EnableOrDisablePoolIxAccounts,
        EnableOrDisablePoolInstructionArgs as EnableOrDisablePoolIxData,
        GetPoolInfo as GetPoolInfoIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPool as InitializeCustomizablePermissionlessConstantProductPoolIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPoolInstructionArgs as InitializeCustomizablePermissionlessConstantProductPoolIxData,
        InitializePermissionedPool as InitializePermissionedPoolIxAccounts,
        InitializePermissionedPoolInstructionArgs as InitializePermissionedPoolIxData,
        InitializePermissionlessConstantProductPoolWithConfig as InitializePermissionlessConstantProductPoolWithConfigIxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2 as InitializePermissionlessConstantProductPoolWithConfig2IxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2InstructionArgs as InitializePermissionlessConstantProductPoolWithConfig2IxData,
        InitializePermissionlessConstantProductPoolWithConfigInstructionArgs as InitializePermissionlessConstantProductPoolWithConfigIxData,
        InitializePermissionlessPool as InitializePermissionlessPoolIxAccounts,
        InitializePermissionlessPoolInstructionArgs as InitializePermissionlessPoolIxData,
        InitializePermissionlessPoolWithFeeTier as InitializePermissionlessPoolWithFeeTierIxAccounts,
        InitializePermissionlessPoolWithFeeTierInstructionArgs as InitializePermissionlessPoolWithFeeTierIxData,
        Lock as LockIxAccounts, LockInstructionArgs as LockIxData,
        OverrideCurveParam as OverrideCurveParamIxAccounts,
        OverrideCurveParamInstructionArgs as OverrideCurveParamIxData,
        PartnerClaimFee as PartnerClaimFeeIxAccounts,
        PartnerClaimFeeInstructionArgs as PartnerClaimFeeIxData,
        RemoveBalanceLiquidity as RemoveBalanceLiquidityIxAccounts,
        RemoveBalanceLiquidityInstructionArgs as RemoveBalanceLiquidityIxData,
        RemoveLiquiditySingleSide as RemoveLiquiditySingleSideIxAccounts,
        RemoveLiquiditySingleSideInstructionArgs as RemoveLiquiditySingleSideIxData,
        SetPoolFees as SetPoolFeesIxAccounts, SetPoolFeesInstructionArgs as SetPoolFeesIxData,
        SetWhitelistedVault as SetWhitelistedVaultIxAccounts,
        SetWhitelistedVaultInstructionArgs as SetWhitelistedVaultIxData, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData,
        UpdateActivationPoint as UpdateActivationPointIxAccounts,
        UpdateActivationPointInstructionArgs as UpdateActivationPointIxData,
        WithdrawProtocolFees as WithdrawProtocolFeesIxAccounts,
    },
    ID,
};

/// Amm Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum AmmProgramIx {
    InitializePermissionedPool(
        InitializePermissionedPoolIxAccounts,
        InitializePermissionedPoolIxData,
    ),
    InitializePermissionlessPool(
        InitializePermissionlessPoolIxAccounts,
        InitializePermissionlessPoolIxData,
    ),
    InitializePermissionlessPoolWithFeeTier(
        InitializePermissionlessPoolWithFeeTierIxAccounts,
        InitializePermissionlessPoolWithFeeTierIxData,
    ),
    EnableOrDisablePool(EnableOrDisablePoolIxAccounts, EnableOrDisablePoolIxData),
    Swap(SwapIxAccounts, SwapIxData, Option<SwapEvent>),
    RemoveLiquiditySingleSide(
        RemoveLiquiditySingleSideIxAccounts,
        RemoveLiquiditySingleSideIxData,
    ),
    AddImbalanceLiquidity(AddImbalanceLiquidityIxAccounts, AddImbalanceLiquidityIxData),
    RemoveBalanceLiquidity(
        RemoveBalanceLiquidityIxAccounts,
        RemoveBalanceLiquidityIxData,
    ),
    AddBalanceLiquidity(AddBalanceLiquidityIxAccounts, AddBalanceLiquidityIxData),
    SetPoolFees(SetPoolFeesIxAccounts, SetPoolFeesIxData),
    OverrideCurveParam(OverrideCurveParamIxAccounts, OverrideCurveParamIxData),
    GetPoolInfo(GetPoolInfoIxAccounts),
    BootstrapLiquidity(BootstrapLiquidityIxAccounts, BootstrapLiquidityIxData),
    CreateMintMetadata(CreateMintMetadataIxAccounts),
    CreateLockEscrow(CreateLockEscrowIxAccounts),
    Lock(LockIxAccounts, LockIxData),
    ClaimFee(ClaimFeeIxAccounts, ClaimFeeIxData),
    CreateConfig(CreateConfigIxAccounts, CreateConfigIxData),
    CloseConfig(CloseConfigIxAccounts),
    InitializePermissionlessConstantProductPoolWithConfig(
        InitializePermissionlessConstantProductPoolWithConfigIxAccounts,
        InitializePermissionlessConstantProductPoolWithConfigIxData,
    ),
    InitializePermissionlessConstantProductPoolWithConfig2(
        InitializePermissionlessConstantProductPoolWithConfig2IxAccounts,
        InitializePermissionlessConstantProductPoolWithConfig2IxData,
    ),
    InitializeCustomizablePermissionlessConstantProductPool(
        InitializeCustomizablePermissionlessConstantProductPoolIxAccounts,
        InitializeCustomizablePermissionlessConstantProductPoolIxData,
    ),
    UpdateActivationPoint(UpdateActivationPointIxAccounts, UpdateActivationPointIxData),
    WithdrawProtocolFees(WithdrawProtocolFeesIxAccounts),
    SetWhitelistedVault(SetWhitelistedVaultIxAccounts, SetWhitelistedVaultIxData),
    PartnerClaimFee(PartnerClaimFeeIxAccounts, PartnerClaimFeeIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = AmmProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<AmmProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> { "Amm::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;
        if ix.data.len() < 8 {
            return Err(yellowstone_vixen_core::ParseError::from(
                "Instruction data too short".to_owned(),
            ));
        }

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [77, 85, 178, 157, 50, 48, 212, 126] => {
                let expected_accounts_len = 24;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializePermissionedPoolIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    token_a_mint: next_account(accounts)?,
                    token_b_mint: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    admin_token_a: next_account(accounts)?,
                    admin_token_b: next_account(accounts)?,
                    admin_pool_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    fee_owner: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializePermissionedPoolIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::InitializePermissionedPool(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [118, 173, 41, 157, 173, 72, 97, 103] => {
                let expected_accounts_len = 26;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializePermissionlessPoolIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    token_a_mint: next_account(accounts)?,
                    token_b_mint: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    payer_token_a: next_account(accounts)?,
                    payer_token_b: next_account(accounts)?,
                    payer_pool_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    fee_owner: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializePermissionlessPoolIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::InitializePermissionlessPool(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [6, 135, 68, 147, 229, 82, 169, 113] => {
                let expected_accounts_len = 26;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializePermissionlessPoolWithFeeTierIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    token_a_mint: next_account(accounts)?,
                    token_b_mint: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    payer_token_a: next_account(accounts)?,
                    payer_token_b: next_account(accounts)?,
                    payer_pool_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    fee_owner: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializePermissionlessPoolWithFeeTierIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::InitializePermissionlessPoolWithFeeTier(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [128, 6, 228, 131, 55, 161, 52, 169] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = EnableOrDisablePoolIxAccounts {
                    pool: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: EnableOrDisablePoolIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::EnableOrDisablePool(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    pool: next_account(accounts)?,
                    user_source_token: next_account(accounts)?,
                    user_destination_token: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    protocol_token_fee: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = yellowstone_vixen_core::deserialize_checked_swap(
                    ix_data,
                    &ix_discriminator,
                    "Swap",
                    deserialize_checked,
                )?;

                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }

                // Parse SwapEvent from logs
                let swap_event = SwapEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );

                Ok(AmmProgramIx::Swap(ix_accounts, de_ix_data, swap_event))
            },
            [84, 84, 177, 66, 254, 185, 10, 251] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveLiquiditySingleSideIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    user_pool_lp: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    user_destination_token: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: RemoveLiquiditySingleSideIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::RemoveLiquiditySingleSide(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [79, 35, 122, 84, 173, 15, 93, 191] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddImbalanceLiquidityIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    user_pool_lp: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    user_a_token: next_account(accounts)?,
                    user_b_token: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: AddImbalanceLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::AddImbalanceLiquidity(ix_accounts, de_ix_data))
            },
            [133, 109, 44, 179, 56, 238, 114, 33] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RemoveBalanceLiquidityIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    user_pool_lp: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    user_a_token: next_account(accounts)?,
                    user_b_token: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: RemoveBalanceLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::RemoveBalanceLiquidity(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [168, 227, 50, 62, 189, 171, 84, 176] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = AddBalanceLiquidityIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    user_pool_lp: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    user_a_token: next_account(accounts)?,
                    user_b_token: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: AddBalanceLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::AddBalanceLiquidity(ix_accounts, de_ix_data))
            },
            [102, 44, 158, 54, 205, 37, 126, 78] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SetPoolFeesIxAccounts {
                    pool: next_account(accounts)?,
                    fee_operator: next_account(accounts)?,
                };
                let de_ix_data: SetPoolFeesIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::SetPoolFees(ix_accounts, de_ix_data))
            },
            [98, 86, 204, 51, 94, 71, 69, 187] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OverrideCurveParamIxAccounts {
                    pool: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: OverrideCurveParamIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::OverrideCurveParam(ix_accounts, de_ix_data))
            },
            [9, 48, 220, 101, 22, 240, 78, 200] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GetPoolInfoIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                };
                Ok(AmmProgramIx::GetPoolInfo(ix_accounts))
            },
            [4, 228, 215, 71, 225, 253, 119, 206] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = BootstrapLiquidityIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    user_pool_lp: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    user_a_token: next_account(accounts)?,
                    user_b_token: next_account(accounts)?,
                    user: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: BootstrapLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::BootstrapLiquidity(ix_accounts, de_ix_data))
            },
            [13, 70, 168, 41, 250, 100, 148, 90] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateMintMetadataIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    payer: next_account(accounts)?,
                };
                Ok(AmmProgramIx::CreateMintMetadata(ix_accounts))
            },
            [54, 87, 165, 19, 69, 227, 218, 224] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateLockEscrowIxAccounts {
                    pool: next_account(accounts)?,
                    lock_escrow: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(AmmProgramIx::CreateLockEscrow(ix_accounts))
            },
            [21, 19, 208, 43, 237, 62, 255, 87] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = LockIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    lock_escrow: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    source_tokens: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                };
                let de_ix_data: LockIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::Lock(ix_accounts, de_ix_data))
            },
            [169, 32, 79, 137, 136, 232, 70, 137] => {
                let expected_accounts_len = 18;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimFeeIxAccounts {
                    pool: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    lock_escrow: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    source_tokens: next_account(accounts)?,
                    escrow_vault: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    user_a_token: next_account(accounts)?,
                    user_b_token: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                };
                let de_ix_data: ClaimFeeIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::ClaimFee(ix_accounts, de_ix_data))
            },
            [201, 207, 243, 114, 75, 111, 47, 189] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateConfigIxAccounts {
                    config: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::CreateConfig(ix_accounts, de_ix_data))
            },
            [145, 9, 72, 157, 95, 125, 61, 85] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseConfigIxAccounts {
                    config: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    rent_receiver: next_account(accounts)?,
                };
                Ok(AmmProgramIx::CloseConfig(ix_accounts))
            },
            [7, 166, 138, 171, 206, 171, 236, 244] => {
                let expected_accounts_len = 26;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
                    pool: next_account(accounts)?,
                    config: next_account(accounts)?,
                    lp_mint: next_account(accounts)?,
                    token_a_mint: next_account(accounts)?,
                    token_b_mint: next_account(accounts)?,
                    a_vault: next_account(accounts)?,
                    b_vault: next_account(accounts)?,
                    a_token_vault: next_account(accounts)?,
                    b_token_vault: next_account(accounts)?,
                    a_vault_lp_mint: next_account(accounts)?,
                    b_vault_lp_mint: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    b_vault_lp: next_account(accounts)?,
                    payer_token_a: next_account(accounts)?,
                    payer_token_b: next_account(accounts)?,
                    payer_pool_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    mint_metadata: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    vault_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializePermissionlessConstantProductPoolWithConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(
                    AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [48, 149, 220, 130, 61, 11, 9, 178] => {
                let expected_accounts_len = 26;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts =
                    InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
                        pool: next_account(accounts)?,
                        config: next_account(accounts)?,
                        lp_mint: next_account(accounts)?,
                        token_a_mint: next_account(accounts)?,
                        token_b_mint: next_account(accounts)?,
                        a_vault: next_account(accounts)?,
                        b_vault: next_account(accounts)?,
                        a_token_vault: next_account(accounts)?,
                        b_token_vault: next_account(accounts)?,
                        a_vault_lp_mint: next_account(accounts)?,
                        b_vault_lp_mint: next_account(accounts)?,
                        a_vault_lp: next_account(accounts)?,
                        b_vault_lp: next_account(accounts)?,
                        payer_token_a: next_account(accounts)?,
                        payer_token_b: next_account(accounts)?,
                        payer_pool_lp: next_account(accounts)?,
                        protocol_token_a_fee: next_account(accounts)?,
                        protocol_token_b_fee: next_account(accounts)?,
                        payer: next_account(accounts)?,
                        rent: next_account(accounts)?,
                        mint_metadata: next_account(accounts)?,
                        metadata_program: next_account(accounts)?,
                        vault_program: next_account(accounts)?,
                        token_program: next_account(accounts)?,
                        associated_token_program: next_account(accounts)?,
                        system_program: next_account(accounts)?,
                    };
                let de_ix_data: InitializePermissionlessConstantProductPoolWithConfig2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(
                    AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig2(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [145, 24, 172, 194, 219, 125, 3, 190] => {
                let expected_accounts_len = 25;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts =
                    InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
                        pool: next_account(accounts)?,
                        lp_mint: next_account(accounts)?,
                        token_a_mint: next_account(accounts)?,
                        token_b_mint: next_account(accounts)?,
                        a_vault: next_account(accounts)?,
                        b_vault: next_account(accounts)?,
                        a_token_vault: next_account(accounts)?,
                        b_token_vault: next_account(accounts)?,
                        a_vault_lp_mint: next_account(accounts)?,
                        b_vault_lp_mint: next_account(accounts)?,
                        a_vault_lp: next_account(accounts)?,
                        b_vault_lp: next_account(accounts)?,
                        payer_token_a: next_account(accounts)?,
                        payer_token_b: next_account(accounts)?,
                        payer_pool_lp: next_account(accounts)?,
                        protocol_token_a_fee: next_account(accounts)?,
                        protocol_token_b_fee: next_account(accounts)?,
                        payer: next_account(accounts)?,
                        rent: next_account(accounts)?,
                        mint_metadata: next_account(accounts)?,
                        metadata_program: next_account(accounts)?,
                        vault_program: next_account(accounts)?,
                        token_program: next_account(accounts)?,
                        associated_token_program: next_account(accounts)?,
                        system_program: next_account(accounts)?,
                    };
                let de_ix_data: InitializeCustomizablePermissionlessConstantProductPoolIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(
                    AmmProgramIx::InitializeCustomizablePermissionlessConstantProductPool(
                        ix_accounts,
                        de_ix_data,
                    ),
                )
            },
            [150, 62, 125, 219, 171, 220, 26, 237] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateActivationPointIxAccounts {
                    pool: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: UpdateActivationPointIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::UpdateActivationPoint(ix_accounts, de_ix_data))
            },
            [11, 68, 165, 98, 18, 208, 134, 73] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WithdrawProtocolFeesIxAccounts {
                    pool: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    treasury_token_a: next_account(accounts)?,
                    treasury_token_b: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                Ok(AmmProgramIx::WithdrawProtocolFees(ix_accounts))
            },
            [12, 148, 94, 42, 55, 57, 83, 247] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SetWhitelistedVaultIxAccounts {
                    pool: next_account(accounts)?,
                    admin: next_account(accounts)?,
                };
                let de_ix_data: SetWhitelistedVaultIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::SetWhitelistedVault(ix_accounts, de_ix_data))
            },
            [57, 53, 176, 30, 123, 70, 52, 64] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PartnerClaimFeeIxAccounts {
                    pool: next_account(accounts)?,
                    a_vault_lp: next_account(accounts)?,
                    protocol_token_a_fee: next_account(accounts)?,
                    protocol_token_b_fee: next_account(accounts)?,
                    partner_token_a: next_account(accounts)?,
                    partner_token_b: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    partner_authority: next_account(accounts)?,
                };
                let de_ix_data: PartnerClaimFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmProgramIx::PartnerClaimFee(ix_accounts, de_ix_data))
            },
            // self cpi log
            [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d] => {
                Err(yellowstone_vixen_core::ParseError::Filtered)
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AmmProgramIx, InitializePermissionedPoolIxAccounts, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::InitializePermissionedPoolIxAccounts>
        for InitializePermissionedPoolIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionedPoolIxAccounts {
            proto_def::InitializePermissionedPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                admin_token_a: self.admin_token_a.to_string(),
                admin_token_b: self.admin_token_b.to_string(),
                admin_pool_lp: self.admin_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                admin: self.admin.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionedPoolIxData;
    impl IntoProto<proto_def::InitializePermissionedPoolIxData> for InitializePermissionedPoolIxData {
        fn into_proto(self) -> proto_def::InitializePermissionedPoolIxData {
            proto_def::InitializePermissionedPoolIxData {
                curve_type: Some(self.curve_type.into_proto()),
            }
        }
    }
    use super::InitializePermissionlessPoolIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessPoolIxAccounts>
        for InitializePermissionlessPoolIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolIxAccounts {
            proto_def::InitializePermissionlessPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessPoolIxData;
    impl IntoProto<proto_def::InitializePermissionlessPoolIxData>
        for InitializePermissionlessPoolIxData
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolIxData {
            proto_def::InitializePermissionlessPoolIxData {
                curve_type: Some(self.curve_type.into_proto()),
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::InitializePermissionlessPoolWithFeeTierIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts>
        for InitializePermissionlessPoolWithFeeTierIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts {
            proto_def::InitializePermissionlessPoolWithFeeTierIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                fee_owner: self.fee_owner.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessPoolWithFeeTierIxData;
    impl IntoProto<proto_def::InitializePermissionlessPoolWithFeeTierIxData>
        for InitializePermissionlessPoolWithFeeTierIxData
    {
        fn into_proto(self) -> proto_def::InitializePermissionlessPoolWithFeeTierIxData {
            proto_def::InitializePermissionlessPoolWithFeeTierIxData {
                curve_type: Some(self.curve_type.into_proto()),
                trade_fee_bps: self.trade_fee_bps,
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::EnableOrDisablePoolIxAccounts;
    impl IntoProto<proto_def::EnableOrDisablePoolIxAccounts> for EnableOrDisablePoolIxAccounts {
        fn into_proto(self) -> proto_def::EnableOrDisablePoolIxAccounts {
            proto_def::EnableOrDisablePoolIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::EnableOrDisablePoolIxData;
    impl IntoProto<proto_def::EnableOrDisablePoolIxData> for EnableOrDisablePoolIxData {
        fn into_proto(self) -> proto_def::EnableOrDisablePoolIxData {
            proto_def::EnableOrDisablePoolIxData {
                enable: self.enable,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                pool: self.pool.to_string(),
                user_source_token: self.user_source_token.to_string(),
                user_destination_token: self.user_destination_token.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                protocol_token_fee: self.protocol_token_fee.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                in_amount: self.in_amount,
                minimum_out_amount: self.minimum_out_amount,
            }
        }
    }
    use super::RemoveLiquiditySingleSideIxAccounts;
    impl IntoProto<proto_def::RemoveLiquiditySingleSideIxAccounts>
        for RemoveLiquiditySingleSideIxAccounts
    {
        fn into_proto(self) -> proto_def::RemoveLiquiditySingleSideIxAccounts {
            proto_def::RemoveLiquiditySingleSideIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_destination_token: self.user_destination_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::RemoveLiquiditySingleSideIxData;
    impl IntoProto<proto_def::RemoveLiquiditySingleSideIxData> for RemoveLiquiditySingleSideIxData {
        fn into_proto(self) -> proto_def::RemoveLiquiditySingleSideIxData {
            proto_def::RemoveLiquiditySingleSideIxData {
                pool_token_amount: self.pool_token_amount,
                minimum_out_amount: self.minimum_out_amount,
            }
        }
    }
    use super::AddImbalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::AddImbalanceLiquidityIxAccounts> for AddImbalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::AddImbalanceLiquidityIxAccounts {
            proto_def::AddImbalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::AddImbalanceLiquidityIxData;
    impl IntoProto<proto_def::AddImbalanceLiquidityIxData> for AddImbalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::AddImbalanceLiquidityIxData {
            proto_def::AddImbalanceLiquidityIxData {
                minimum_pool_token_amount: self.minimum_pool_token_amount,
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::RemoveBalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::RemoveBalanceLiquidityIxAccounts> for RemoveBalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::RemoveBalanceLiquidityIxAccounts {
            proto_def::RemoveBalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::RemoveBalanceLiquidityIxData;
    impl IntoProto<proto_def::RemoveBalanceLiquidityIxData> for RemoveBalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::RemoveBalanceLiquidityIxData {
            proto_def::RemoveBalanceLiquidityIxData {
                pool_token_amount: self.pool_token_amount,
                minimum_a_token_out: self.minimum_a_token_out,
                minimum_b_token_out: self.minimum_b_token_out,
            }
        }
    }
    use super::AddBalanceLiquidityIxAccounts;
    impl IntoProto<proto_def::AddBalanceLiquidityIxAccounts> for AddBalanceLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::AddBalanceLiquidityIxAccounts {
            proto_def::AddBalanceLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::AddBalanceLiquidityIxData;
    impl IntoProto<proto_def::AddBalanceLiquidityIxData> for AddBalanceLiquidityIxData {
        fn into_proto(self) -> proto_def::AddBalanceLiquidityIxData {
            proto_def::AddBalanceLiquidityIxData {
                pool_token_amount: self.pool_token_amount,
                maximum_token_a_amount: self.maximum_token_a_amount,
                maximum_token_b_amount: self.maximum_token_b_amount,
            }
        }
    }
    use super::SetPoolFeesIxAccounts;
    impl IntoProto<proto_def::SetPoolFeesIxAccounts> for SetPoolFeesIxAccounts {
        fn into_proto(self) -> proto_def::SetPoolFeesIxAccounts {
            proto_def::SetPoolFeesIxAccounts {
                pool: self.pool.to_string(),
                fee_operator: self.fee_operator.to_string(),
            }
        }
    }
    use super::SetPoolFeesIxData;
    impl IntoProto<proto_def::SetPoolFeesIxData> for SetPoolFeesIxData {
        fn into_proto(self) -> proto_def::SetPoolFeesIxData {
            proto_def::SetPoolFeesIxData {
                fees: Some(self.fees.into_proto()),
                new_partner_fee_numerator: self.new_partner_fee_numerator,
            }
        }
    }
    use super::OverrideCurveParamIxAccounts;
    impl IntoProto<proto_def::OverrideCurveParamIxAccounts> for OverrideCurveParamIxAccounts {
        fn into_proto(self) -> proto_def::OverrideCurveParamIxAccounts {
            proto_def::OverrideCurveParamIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::OverrideCurveParamIxData;
    impl IntoProto<proto_def::OverrideCurveParamIxData> for OverrideCurveParamIxData {
        fn into_proto(self) -> proto_def::OverrideCurveParamIxData {
            proto_def::OverrideCurveParamIxData {
                curve_type: Some(self.curve_type.into_proto()),
            }
        }
    }
    use super::GetPoolInfoIxAccounts;
    impl IntoProto<proto_def::GetPoolInfoIxAccounts> for GetPoolInfoIxAccounts {
        fn into_proto(self) -> proto_def::GetPoolInfoIxAccounts {
            proto_def::GetPoolInfoIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
            }
        }
    }
    use super::BootstrapLiquidityIxAccounts;
    impl IntoProto<proto_def::BootstrapLiquidityIxAccounts> for BootstrapLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::BootstrapLiquidityIxAccounts {
            proto_def::BootstrapLiquidityIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                user_pool_lp: self.user_pool_lp.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                user: self.user.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::BootstrapLiquidityIxData;
    impl IntoProto<proto_def::BootstrapLiquidityIxData> for BootstrapLiquidityIxData {
        fn into_proto(self) -> proto_def::BootstrapLiquidityIxData {
            proto_def::BootstrapLiquidityIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::CreateMintMetadataIxAccounts;
    impl IntoProto<proto_def::CreateMintMetadataIxAccounts> for CreateMintMetadataIxAccounts {
        fn into_proto(self) -> proto_def::CreateMintMetadataIxAccounts {
            proto_def::CreateMintMetadataIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                system_program: self.system_program.to_string(),
                payer: self.payer.to_string(),
            }
        }
    }
    use super::CreateLockEscrowIxAccounts;
    impl IntoProto<proto_def::CreateLockEscrowIxAccounts> for CreateLockEscrowIxAccounts {
        fn into_proto(self) -> proto_def::CreateLockEscrowIxAccounts {
            proto_def::CreateLockEscrowIxAccounts {
                pool: self.pool.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                lp_mint: self.lp_mint.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::LockIxAccounts;
    impl IntoProto<proto_def::LockIxAccounts> for LockIxAccounts {
        fn into_proto(self) -> proto_def::LockIxAccounts {
            proto_def::LockIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                source_tokens: self.source_tokens.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_program: self.token_program.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
            }
        }
    }
    use super::LockIxData;
    impl IntoProto<proto_def::LockIxData> for LockIxData {
        fn into_proto(self) -> proto_def::LockIxData {
            proto_def::LockIxData {
                max_amount: self.max_amount,
            }
        }
    }
    use super::ClaimFeeIxAccounts;
    impl IntoProto<proto_def::ClaimFeeIxAccounts> for ClaimFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimFeeIxAccounts {
            proto_def::ClaimFeeIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                lock_escrow: self.lock_escrow.to_string(),
                owner: self.owner.to_string(),
                source_tokens: self.source_tokens.to_string(),
                escrow_vault: self.escrow_vault.to_string(),
                token_program: self.token_program.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                user_a_token: self.user_a_token.to_string(),
                user_b_token: self.user_b_token.to_string(),
                vault_program: self.vault_program.to_string(),
            }
        }
    }
    use super::ClaimFeeIxData;
    impl IntoProto<proto_def::ClaimFeeIxData> for ClaimFeeIxData {
        fn into_proto(self) -> proto_def::ClaimFeeIxData {
            proto_def::ClaimFeeIxData {
                max_amount: self.max_amount,
            }
        }
    }
    use super::CreateConfigIxAccounts;
    impl IntoProto<proto_def::CreateConfigIxAccounts> for CreateConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateConfigIxAccounts {
            proto_def::CreateConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateConfigIxData;
    impl IntoProto<proto_def::CreateConfigIxData> for CreateConfigIxData {
        fn into_proto(self) -> proto_def::CreateConfigIxData {
            proto_def::CreateConfigIxData {
                trade_fee_numerator: self.trade_fee_numerator,
                protocol_trade_fee_numerator: self.protocol_trade_fee_numerator,
                activation_duration: self.activation_duration,
                vault_config_key: self.vault_config_key.to_string(),
                pool_creator_authority: self.pool_creator_authority.to_string(),
                activation_type: self.activation_type.into(),
                index: self.index,
                partner_fee_numerator: self.partner_fee_numerator,
            }
        }
    }
    use super::CloseConfigIxAccounts;
    impl IntoProto<proto_def::CloseConfigIxAccounts> for CloseConfigIxAccounts {
        fn into_proto(self) -> proto_def::CloseConfigIxAccounts {
            proto_def::CloseConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfigIxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts>
        for InitializePermissionlessConstantProductPoolWithConfigIxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
            proto_def::InitializePermissionlessConstantProductPoolWithConfigIxAccounts {
                pool: self.pool.to_string(),
                config: self.config.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfigIxData;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData>
        for InitializePermissionlessConstantProductPoolWithConfigIxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData {
            proto_def::InitializePermissionlessConstantProductPoolWithConfigIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts>
        for InitializePermissionlessConstantProductPoolWithConfig2IxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
            proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxAccounts {
                pool: self.pool.to_string(),
                config: self.config.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializePermissionlessConstantProductPoolWithConfig2IxData;
    impl IntoProto<proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData>
        for InitializePermissionlessConstantProductPoolWithConfig2IxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData {
            proto_def::InitializePermissionlessConstantProductPoolWithConfig2IxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
                activation_point: self.activation_point,
            }
        }
    }
    use super::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts;
    impl IntoProto<proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts>
        for InitializeCustomizablePermissionlessConstantProductPoolIxAccounts
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
            proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxAccounts {
                pool: self.pool.to_string(),
                lp_mint: self.lp_mint.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                a_vault: self.a_vault.to_string(),
                b_vault: self.b_vault.to_string(),
                a_token_vault: self.a_token_vault.to_string(),
                b_token_vault: self.b_token_vault.to_string(),
                a_vault_lp_mint: self.a_vault_lp_mint.to_string(),
                b_vault_lp_mint: self.b_vault_lp_mint.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                b_vault_lp: self.b_vault_lp.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                payer_pool_lp: self.payer_pool_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                payer: self.payer.to_string(),
                rent: self.rent.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                metadata_program: self.metadata_program.to_string(),
                vault_program: self.vault_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeCustomizablePermissionlessConstantProductPoolIxData;
    impl IntoProto<proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData>
        for InitializeCustomizablePermissionlessConstantProductPoolIxData
    {
        fn into_proto(
            self,
        ) -> proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData {
            proto_def::InitializeCustomizablePermissionlessConstantProductPoolIxData {
                token_a_amount: self.token_a_amount,
                token_b_amount: self.token_b_amount,
                trade_fee_numerator: self.trade_fee_numerator,
                activation_point: self.activation_point,
                has_alpha_vault: self.has_alpha_vault,
                activation_type: self.activation_type.into(),
                padding: self.padding.into_iter().map(|x| x.into()).collect(),
            }
        }
    }
    use super::UpdateActivationPointIxAccounts;
    impl IntoProto<proto_def::UpdateActivationPointIxAccounts> for UpdateActivationPointIxAccounts {
        fn into_proto(self) -> proto_def::UpdateActivationPointIxAccounts {
            proto_def::UpdateActivationPointIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::UpdateActivationPointIxData;
    impl IntoProto<proto_def::UpdateActivationPointIxData> for UpdateActivationPointIxData {
        fn into_proto(self) -> proto_def::UpdateActivationPointIxData {
            proto_def::UpdateActivationPointIxData {
                new_activation_point: self.new_activation_point,
            }
        }
    }
    use super::WithdrawProtocolFeesIxAccounts;
    impl IntoProto<proto_def::WithdrawProtocolFeesIxAccounts> for WithdrawProtocolFeesIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawProtocolFeesIxAccounts {
            proto_def::WithdrawProtocolFeesIxAccounts {
                pool: self.pool.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                treasury_token_a: self.treasury_token_a.to_string(),
                treasury_token_b: self.treasury_token_b.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::SetWhitelistedVaultIxAccounts;
    impl IntoProto<proto_def::SetWhitelistedVaultIxAccounts> for SetWhitelistedVaultIxAccounts {
        fn into_proto(self) -> proto_def::SetWhitelistedVaultIxAccounts {
            proto_def::SetWhitelistedVaultIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
            }
        }
    }
    use super::SetWhitelistedVaultIxData;
    impl IntoProto<proto_def::SetWhitelistedVaultIxData> for SetWhitelistedVaultIxData {
        fn into_proto(self) -> proto_def::SetWhitelistedVaultIxData {
            proto_def::SetWhitelistedVaultIxData {
                whitelisted_vault: self.whitelisted_vault.to_string(),
            }
        }
    }
    use super::PartnerClaimFeeIxAccounts;
    impl IntoProto<proto_def::PartnerClaimFeeIxAccounts> for PartnerClaimFeeIxAccounts {
        fn into_proto(self) -> proto_def::PartnerClaimFeeIxAccounts {
            proto_def::PartnerClaimFeeIxAccounts {
                pool: self.pool.to_string(),
                a_vault_lp: self.a_vault_lp.to_string(),
                protocol_token_a_fee: self.protocol_token_a_fee.to_string(),
                protocol_token_b_fee: self.protocol_token_b_fee.to_string(),
                partner_token_a: self.partner_token_a.to_string(),
                partner_token_b: self.partner_token_b.to_string(),
                token_program: self.token_program.to_string(),
                partner_authority: self.partner_authority.to_string(),
            }
        }
    }
    use super::PartnerClaimFeeIxData;
    impl IntoProto<proto_def::PartnerClaimFeeIxData> for PartnerClaimFeeIxData {
        fn into_proto(self) -> proto_def::PartnerClaimFeeIxData {
            proto_def::PartnerClaimFeeIxData {
                max_amount_a: self.max_amount_a,
                max_amount_b: self.max_amount_b,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for AmmProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                                                            AmmProgramIx::InitializePermissionedPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionedPool(proto_def::InitializePermissionedPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessPool(proto_def::InitializePermissionlessPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessPoolWithFeeTier(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessPoolWithFeeTier(proto_def::InitializePermissionlessPoolWithFeeTierIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::EnableOrDisablePool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::EnableOrDisablePool(proto_def::EnableOrDisablePoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::Swap(acc, data, _) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::RemoveLiquiditySingleSide(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveLiquiditySingleSide(proto_def::RemoveLiquiditySingleSideIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::AddImbalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::AddImbalanceLiquidity(proto_def::AddImbalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::RemoveBalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveBalanceLiquidity(proto_def::RemoveBalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::AddBalanceLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::AddBalanceLiquidity(proto_def::AddBalanceLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::SetPoolFees(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::SetPoolFees(proto_def::SetPoolFeesIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::OverrideCurveParam(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::OverrideCurveParam(proto_def::OverrideCurveParamIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::GetPoolInfo(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::GetPoolInfo(proto_def::GetPoolInfoIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::BootstrapLiquidity(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::BootstrapLiquidity(proto_def::BootstrapLiquidityIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateMintMetadata(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateMintMetadata(proto_def::CreateMintMetadataIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateLockEscrow(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateLockEscrow(proto_def::CreateLockEscrowIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::Lock(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::Lock(proto_def::LockIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::ClaimFee(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimFee(proto_def::ClaimFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CreateConfig(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateConfig(proto_def::CreateConfigIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::CloseConfig(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseConfig(proto_def::CloseConfigIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessConstantProductPoolWithConfig(proto_def::InitializePermissionlessConstantProductPoolWithConfigIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializePermissionlessConstantProductPoolWithConfig2(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePermissionlessConstantProductPoolWithConfig2(proto_def::InitializePermissionlessConstantProductPoolWithConfig2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::InitializeCustomizablePermissionlessConstantProductPool(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeCustomizablePermissionlessConstantProductPool(proto_def::InitializeCustomizablePermissionlessConstantProductPoolIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::UpdateActivationPoint(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateActivationPoint(proto_def::UpdateActivationPointIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::WithdrawProtocolFees(acc) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawProtocolFees(proto_def::WithdrawProtocolFeesIx {
                                accounts: Some(acc.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::SetWhitelistedVault(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::SetWhitelistedVault(proto_def::SetWhitelistedVaultIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                                                AmmProgramIx::PartnerClaimFee(acc, data) => proto_def::ProgramIxs {
                            ix_oneof: Some(proto_def::program_ixs::IxOneof::PartnerClaimFee(proto_def::PartnerClaimFeeIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            })),
                        },
                                                }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
