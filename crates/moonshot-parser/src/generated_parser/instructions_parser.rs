//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        Buy as BuyIxAccounts, BuyInstructionArgs as BuyIxData, ConfigInit as ConfigInitIxAccounts,
        ConfigInitInstructionArgs as ConfigInitIxData, ConfigUpdate as ConfigUpdateIxAccounts,
        ConfigUpdateInstructionArgs as ConfigUpdateIxData, MigrateFunds as MigrateFundsIxAccounts,
        Sell as SellIxAccounts, SellInstructionArgs as SellIxData,
        TokenMint as TokenMintIxAccounts, TokenMintInstructionArgs as TokenMintIxData,
    },
    ID,
};

/// TokenLaunchpad Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum TokenLaunchpadProgramIx {
    TokenMint(TokenMintIxAccounts, TokenMintIxData),
    Buy(BuyIxAccounts, BuyIxData),
    Sell(SellIxAccounts, SellIxData),
    MigrateFunds(MigrateFundsIxAccounts),
    ConfigInit(ConfigInitIxAccounts, ConfigInitIxData),
    ConfigUpdate(ConfigUpdateIxAccounts, ConfigUpdateIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = TokenLaunchpadProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "TokenLaunchpad::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<TokenLaunchpadProgramIx> {
        let accounts_len = ix.accounts.len();

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [3, 44, 164, 184, 123, 13, 245, 179] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = TokenMintIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    backend_authority: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    mint: ix.accounts[3].0.into(),
                    mint_metadata: ix.accounts[4].0.into(),
                    curve_token_account: ix.accounts[5].0.into(),
                    config_account: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    associated_token_program: ix.accounts[8].0.into(),
                    mpl_token_metadata: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: TokenMintIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::TokenMint(ix_accounts, de_ix_data))
            },
            [102, 6, 61, 18, 1, 218, 235, 234] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = BuyIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    sender_token_account: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    dex_fee: ix.accounts[4].0.into(),
                    helio_fee: ix.accounts[5].0.into(),
                    mint: ix.accounts[6].0.into(),
                    config_account: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: BuyIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::Buy(ix_accounts, de_ix_data))
            },
            [51, 230, 133, 164, 1, 127, 131, 173] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = SellIxAccounts {
                    sender: ix.accounts[0].0.into(),
                    sender_token_account: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    dex_fee: ix.accounts[4].0.into(),
                    helio_fee: ix.accounts[5].0.into(),
                    mint: ix.accounts[6].0.into(),
                    config_account: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    associated_token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                };
                let de_ix_data: SellIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::Sell(ix_accounts, de_ix_data))
            },
            [42, 229, 10, 231, 189, 62, 193, 174] => {
                check_min_accounts_req(accounts_len, 12)?;
                let ix_accounts = MigrateFundsIxAccounts {
                    backend_authority: ix.accounts[0].0.into(),
                    migration_authority: ix.accounts[1].0.into(),
                    curve_account: ix.accounts[2].0.into(),
                    curve_token_account: ix.accounts[3].0.into(),
                    migration_authority_token_account: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                    dex_fee_account: ix.accounts[6].0.into(),
                    helio_fee_account: ix.accounts[7].0.into(),
                    config_account: ix.accounts[8].0.into(),
                    system_program: ix.accounts[9].0.into(),
                    token_program: ix.accounts[10].0.into(),
                    associated_token_program: ix.accounts[11].0.into(),
                };
                Ok(TokenLaunchpadProgramIx::MigrateFunds(ix_accounts))
            },
            [13, 236, 164, 173, 106, 253, 164, 185] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ConfigInitIxAccounts {
                    config_authority: ix.accounts[0].0.into(),
                    config_account: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: ConfigInitIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::ConfigInit(ix_accounts, de_ix_data))
            },
            [80, 37, 109, 136, 82, 135, 89, 241] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = ConfigUpdateIxAccounts {
                    config_authority: ix.accounts[0].0.into(),
                    config_account: ix.accounts[1].0.into(),
                };
                let de_ix_data: ConfigUpdateIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(TokenLaunchpadProgramIx::ConfigUpdate(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        ix
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{InstructionParser, TokenLaunchpadProgramIx, TokenMintIxAccounts};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::TokenMintIxAccounts> for TokenMintIxAccounts {
        fn into_proto(self) -> proto_def::TokenMintIxAccounts {
            proto_def::TokenMintIxAccounts {
                sender: self.sender.to_string(),
                backend_authority: self.backend_authority.to_string(),
                curve_account: self.curve_account.to_string(),
                mint: self.mint.to_string(),
                mint_metadata: self.mint_metadata.to_string(),
                curve_token_account: self.curve_token_account.to_string(),
                config_account: self.config_account.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                mpl_token_metadata: self.mpl_token_metadata.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::TokenMintIxData;
    impl IntoProto<proto_def::TokenMintIxData> for TokenMintIxData {
        fn into_proto(self) -> proto_def::TokenMintIxData {
            proto_def::TokenMintIxData {
                name: self.name,
                symbol: self.symbol,
                uri: self.uri,
                decimals: self.decimals.into(),
                collateral_currency: self.collateral_currency.into(),
                amount: self.amount,
                curve_type: self.curve_type.into(),
                migration_target: self.migration_target.into(),
            }
        }
    }
    use super::BuyIxAccounts;
    impl IntoProto<proto_def::BuyIxAccounts> for BuyIxAccounts {
        fn into_proto(self) -> proto_def::BuyIxAccounts {
            proto_def::BuyIxAccounts {
                sender: self.sender.to_string(),
                sender_token_account: self.sender_token_account.to_string(),
                curve_account: self.curve_account.to_string(),
                curve_token_account: self.curve_token_account.to_string(),
                dex_fee: self.dex_fee.to_string(),
                helio_fee: self.helio_fee.to_string(),
                mint: self.mint.to_string(),
                config_account: self.config_account.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::BuyIxData;
    impl IntoProto<proto_def::BuyIxData> for BuyIxData {
        fn into_proto(self) -> proto_def::BuyIxData {
            proto_def::BuyIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }
    use super::SellIxAccounts;
    impl IntoProto<proto_def::SellIxAccounts> for SellIxAccounts {
        fn into_proto(self) -> proto_def::SellIxAccounts {
            proto_def::SellIxAccounts {
                sender: self.sender.to_string(),
                sender_token_account: self.sender_token_account.to_string(),
                curve_account: self.curve_account.to_string(),
                curve_token_account: self.curve_token_account.to_string(),
                dex_fee: self.dex_fee.to_string(),
                helio_fee: self.helio_fee.to_string(),
                mint: self.mint.to_string(),
                config_account: self.config_account.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::SellIxData;
    impl IntoProto<proto_def::SellIxData> for SellIxData {
        fn into_proto(self) -> proto_def::SellIxData {
            proto_def::SellIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }
    use super::MigrateFundsIxAccounts;
    impl IntoProto<proto_def::MigrateFundsIxAccounts> for MigrateFundsIxAccounts {
        fn into_proto(self) -> proto_def::MigrateFundsIxAccounts {
            proto_def::MigrateFundsIxAccounts {
                backend_authority: self.backend_authority.to_string(),
                migration_authority: self.migration_authority.to_string(),
                curve_account: self.curve_account.to_string(),
                curve_token_account: self.curve_token_account.to_string(),
                migration_authority_token_account: self
                    .migration_authority_token_account
                    .to_string(),
                mint: self.mint.to_string(),
                dex_fee_account: self.dex_fee_account.to_string(),
                helio_fee_account: self.helio_fee_account.to_string(),
                config_account: self.config_account.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
            }
        }
    }
    use super::ConfigInitIxAccounts;
    impl IntoProto<proto_def::ConfigInitIxAccounts> for ConfigInitIxAccounts {
        fn into_proto(self) -> proto_def::ConfigInitIxAccounts {
            proto_def::ConfigInitIxAccounts {
                config_authority: self.config_authority.to_string(),
                config_account: self.config_account.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ConfigInitIxData;
    impl IntoProto<proto_def::ConfigInitIxData> for ConfigInitIxData {
        fn into_proto(self) -> proto_def::ConfigInitIxData {
            proto_def::ConfigInitIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }
    use super::ConfigUpdateIxAccounts;
    impl IntoProto<proto_def::ConfigUpdateIxAccounts> for ConfigUpdateIxAccounts {
        fn into_proto(self) -> proto_def::ConfigUpdateIxAccounts {
            proto_def::ConfigUpdateIxAccounts {
                config_authority: self.config_authority.to_string(),
                config_account: self.config_account.to_string(),
            }
        }
    }
    use super::ConfigUpdateIxData;
    impl IntoProto<proto_def::ConfigUpdateIxData> for ConfigUpdateIxData {
        fn into_proto(self) -> proto_def::ConfigUpdateIxData {
            proto_def::ConfigUpdateIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for TokenLaunchpadProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                TokenLaunchpadProgramIx::TokenMint(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TokenMint(
                        proto_def::TokenMintIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                TokenLaunchpadProgramIx::Buy(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Buy(proto_def::BuyIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                TokenLaunchpadProgramIx::Sell(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Sell(proto_def::SellIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                TokenLaunchpadProgramIx::MigrateFunds(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::MigrateFunds(
                        proto_def::MigrateFundsIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                TokenLaunchpadProgramIx::ConfigInit(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ConfigInit(
                        proto_def::ConfigInitIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                TokenLaunchpadProgramIx::ConfigUpdate(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ConfigUpdate(
                        proto_def::ConfigUpdateIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
