//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        AddLiquidity as AddLiquidityIxAccounts, AddLiquidityInstructionArgs as AddLiquidityIxData,
        ClaimPartnerFee as ClaimPartnerFeeIxAccounts,
        ClaimPartnerFeeInstructionArgs as ClaimPartnerFeeIxData,
        ClaimPositionFee as ClaimPositionFeeIxAccounts,
        ClaimProtocolFee as ClaimProtocolFeeIxAccounts, ClaimReward as ClaimRewardIxAccounts,
        ClaimRewardInstructionArgs as ClaimRewardIxData,
        CloseClaimFeeOperator as CloseClaimFeeOperatorIxAccounts,
        CloseConfig as CloseConfigIxAccounts, ClosePosition as ClosePositionIxAccounts,
        CreateClaimFeeOperator as CreateClaimFeeOperatorIxAccounts,
        CreateConfig as CreateConfigIxAccounts, CreateConfigInstructionArgs as CreateConfigIxData,
        CreateDynamicConfig as CreateDynamicConfigIxAccounts,
        CreateDynamicConfigInstructionArgs as CreateDynamicConfigIxData,
        CreatePosition as CreatePositionIxAccounts, CreateTokenBadge as CreateTokenBadgeIxAccounts,
        FundReward as FundRewardIxAccounts, FundRewardInstructionArgs as FundRewardIxData,
        InitializeCustomizablePool as InitializeCustomizablePoolIxAccounts,
        InitializeCustomizablePoolInstructionArgs as InitializeCustomizablePoolIxData,
        InitializePool as InitializePoolIxAccounts,
        InitializePoolInstructionArgs as InitializePoolIxData,
        InitializePoolWithDynamicConfig as InitializePoolWithDynamicConfigIxAccounts,
        InitializePoolWithDynamicConfigInstructionArgs as InitializePoolWithDynamicConfigIxData,
        InitializeReward as InitializeRewardIxAccounts,
        InitializeRewardInstructionArgs as InitializeRewardIxData,
        LockPosition as LockPositionIxAccounts, LockPositionInstructionArgs as LockPositionIxData,
        PermanentLockPosition as PermanentLockPositionIxAccounts,
        PermanentLockPositionInstructionArgs as PermanentLockPositionIxData,
        RefreshVesting as RefreshVestingIxAccounts,
        RemoveAllLiquidity as RemoveAllLiquidityIxAccounts,
        RemoveAllLiquidityInstructionArgs as RemoveAllLiquidityIxData,
        RemoveLiquidity as RemoveLiquidityIxAccounts,
        RemoveLiquidityInstructionArgs as RemoveLiquidityIxData,
        SetPoolStatus as SetPoolStatusIxAccounts,
        SetPoolStatusInstructionArgs as SetPoolStatusIxData, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData, UpdateRewardDuration as UpdateRewardDurationIxAccounts,
        UpdateRewardDurationInstructionArgs as UpdateRewardDurationIxData,
        UpdateRewardFunder as UpdateRewardFunderIxAccounts,
        UpdateRewardFunderInstructionArgs as UpdateRewardFunderIxData,
        WithdrawIneligibleReward as WithdrawIneligibleRewardIxAccounts,
        WithdrawIneligibleRewardInstructionArgs as WithdrawIneligibleRewardIxData,
    },
    ID,
};

/// CpAmm Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum CpAmmProgramIx {
    AddLiquidity(AddLiquidityIxAccounts, AddLiquidityIxData),
    ClaimPartnerFee(ClaimPartnerFeeIxAccounts, ClaimPartnerFeeIxData),
    ClaimPositionFee(ClaimPositionFeeIxAccounts),
    ClaimProtocolFee(ClaimProtocolFeeIxAccounts),
    ClaimReward(ClaimRewardIxAccounts, ClaimRewardIxData),
    CloseClaimFeeOperator(CloseClaimFeeOperatorIxAccounts),
    CloseConfig(CloseConfigIxAccounts),
    ClosePosition(ClosePositionIxAccounts),
    CreateClaimFeeOperator(CreateClaimFeeOperatorIxAccounts),
    CreateConfig(CreateConfigIxAccounts, CreateConfigIxData),
    CreateDynamicConfig(CreateDynamicConfigIxAccounts, CreateDynamicConfigIxData),
    CreatePosition(CreatePositionIxAccounts),
    CreateTokenBadge(CreateTokenBadgeIxAccounts),
    FundReward(FundRewardIxAccounts, FundRewardIxData),
    InitializeCustomizablePool(
        InitializeCustomizablePoolIxAccounts,
        InitializeCustomizablePoolIxData,
    ),
    InitializePool(InitializePoolIxAccounts, InitializePoolIxData),
    InitializePoolWithDynamicConfig(
        InitializePoolWithDynamicConfigIxAccounts,
        InitializePoolWithDynamicConfigIxData,
    ),
    InitializeReward(InitializeRewardIxAccounts, InitializeRewardIxData),
    LockPosition(LockPositionIxAccounts, LockPositionIxData),
    PermanentLockPosition(PermanentLockPositionIxAccounts, PermanentLockPositionIxData),
    RefreshVesting(RefreshVestingIxAccounts),
    RemoveAllLiquidity(RemoveAllLiquidityIxAccounts, RemoveAllLiquidityIxData),
    RemoveLiquidity(RemoveLiquidityIxAccounts, RemoveLiquidityIxData),
    SetPoolStatus(SetPoolStatusIxAccounts, SetPoolStatusIxData),
    Swap(SwapIxAccounts, SwapIxData),
    UpdateRewardDuration(UpdateRewardDurationIxAccounts, UpdateRewardDurationIxData),
    UpdateRewardFunder(UpdateRewardFunderIxAccounts, UpdateRewardFunderIxData),
    WithdrawIneligibleReward(
        WithdrawIneligibleRewardIxAccounts,
        WithdrawIneligibleRewardIxData,
    ),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = CpAmmProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "CpAmm::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<CpAmmProgramIx> {
        let accounts_len = ix.accounts.len();

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [181, 157, 89, 67, 143, 182, 52, 72] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = AddLiquidityIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    position: ix.accounts[1].0.into(),
                    token_a_account: ix.accounts[2].0.into(),
                    token_b_account: ix.accounts[3].0.into(),
                    token_a_vault: ix.accounts[4].0.into(),
                    token_b_vault: ix.accounts[5].0.into(),
                    token_a_mint: ix.accounts[6].0.into(),
                    token_b_mint: ix.accounts[7].0.into(),
                    position_nft_account: ix.accounts[8].0.into(),
                    owner: ix.accounts[9].0.into(),
                    token_a_program: ix.accounts[10].0.into(),
                    token_b_program: ix.accounts[11].0.into(),
                    event_authority: ix.accounts[12].0.into(),
                    program: ix.accounts[13].0.into(),
                };
                let de_ix_data: AddLiquidityIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::AddLiquidity(ix_accounts, de_ix_data))
            },
            [97, 206, 39, 105, 94, 94, 126, 148] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = ClaimPartnerFeeIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    token_a_account: ix.accounts[2].0.into(),
                    token_b_account: ix.accounts[3].0.into(),
                    token_a_vault: ix.accounts[4].0.into(),
                    token_b_vault: ix.accounts[5].0.into(),
                    token_a_mint: ix.accounts[6].0.into(),
                    token_b_mint: ix.accounts[7].0.into(),
                    partner: ix.accounts[8].0.into(),
                    token_a_program: ix.accounts[9].0.into(),
                    token_b_program: ix.accounts[10].0.into(),
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                let de_ix_data: ClaimPartnerFeeIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::ClaimPartnerFee(ix_accounts, de_ix_data))
            },
            [180, 38, 154, 17, 133, 33, 162, 211] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = ClaimPositionFeeIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    token_a_account: ix.accounts[3].0.into(),
                    token_b_account: ix.accounts[4].0.into(),
                    token_a_vault: ix.accounts[5].0.into(),
                    token_b_vault: ix.accounts[6].0.into(),
                    token_a_mint: ix.accounts[7].0.into(),
                    token_b_mint: ix.accounts[8].0.into(),
                    position_nft_account: ix.accounts[9].0.into(),
                    owner: ix.accounts[10].0.into(),
                    token_a_program: ix.accounts[11].0.into(),
                    token_b_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                Ok(CpAmmProgramIx::ClaimPositionFee(ix_accounts))
            },
            [165, 228, 133, 48, 99, 249, 255, 33] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = ClaimProtocolFeeIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    token_a_vault: ix.accounts[2].0.into(),
                    token_b_vault: ix.accounts[3].0.into(),
                    token_a_mint: ix.accounts[4].0.into(),
                    token_b_mint: ix.accounts[5].0.into(),
                    token_a_account: ix.accounts[6].0.into(),
                    token_b_account: ix.accounts[7].0.into(),
                    claim_fee_operator: ix.accounts[8].0.into(),
                    operator: ix.accounts[9].0.into(),
                    token_a_program: ix.accounts[10].0.into(),
                    token_b_program: ix.accounts[11].0.into(),
                    event_authority: ix.accounts[12].0.into(),
                    program: ix.accounts[13].0.into(),
                };
                Ok(CpAmmProgramIx::ClaimProtocolFee(ix_accounts))
            },
            [149, 95, 181, 242, 94, 90, 158, 162] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = ClaimRewardIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    reward_vault: ix.accounts[3].0.into(),
                    reward_mint: ix.accounts[4].0.into(),
                    user_token_account: ix.accounts[5].0.into(),
                    position_nft_account: ix.accounts[6].0.into(),
                    owner: ix.accounts[7].0.into(),
                    token_program: ix.accounts[8].0.into(),
                    event_authority: ix.accounts[9].0.into(),
                    program: ix.accounts[10].0.into(),
                };
                let de_ix_data: ClaimRewardIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::ClaimReward(ix_accounts, de_ix_data))
            },
            [38, 134, 82, 216, 95, 124, 17, 99] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CloseClaimFeeOperatorIxAccounts {
                    claim_fee_operator: ix.accounts[0].0.into(),
                    rent_receiver: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    event_authority: ix.accounts[3].0.into(),
                    program: ix.accounts[4].0.into(),
                };
                Ok(CpAmmProgramIx::CloseClaimFeeOperator(ix_accounts))
            },
            [145, 9, 72, 157, 95, 125, 61, 85] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CloseConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    rent_receiver: ix.accounts[2].0.into(),
                    event_authority: ix.accounts[3].0.into(),
                    program: ix.accounts[4].0.into(),
                };
                Ok(CpAmmProgramIx::CloseConfig(ix_accounts))
            },
            [123, 134, 81, 0, 49, 68, 98, 98] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = ClosePositionIxAccounts {
                    position_nft_mint: ix.accounts[0].0.into(),
                    position_nft_account: ix.accounts[1].0.into(),
                    pool: ix.accounts[2].0.into(),
                    position: ix.accounts[3].0.into(),
                    pool_authority: ix.accounts[4].0.into(),
                    rent_receiver: ix.accounts[5].0.into(),
                    owner: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    event_authority: ix.accounts[8].0.into(),
                    program: ix.accounts[9].0.into(),
                };
                Ok(CpAmmProgramIx::ClosePosition(ix_accounts))
            },
            [169, 62, 207, 107, 58, 187, 162, 109] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CreateClaimFeeOperatorIxAccounts {
                    claim_fee_operator: ix.accounts[0].0.into(),
                    operator: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    event_authority: ix.accounts[4].0.into(),
                    program: ix.accounts[5].0.into(),
                };
                Ok(CpAmmProgramIx::CreateClaimFeeOperator(ix_accounts))
            },
            [201, 207, 243, 114, 75, 111, 47, 189] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CreateConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    event_authority: ix.accounts[3].0.into(),
                    program: ix.accounts[4].0.into(),
                };
                let de_ix_data: CreateConfigIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::CreateConfig(ix_accounts, de_ix_data))
            },
            [81, 251, 122, 78, 66, 57, 208, 82] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CreateDynamicConfigIxAccounts {
                    config: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                    event_authority: ix.accounts[3].0.into(),
                    program: ix.accounts[4].0.into(),
                };
                let de_ix_data: CreateDynamicConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::CreateDynamicConfig(ix_accounts, de_ix_data))
            },
            [48, 215, 197, 153, 96, 203, 180, 133] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = CreatePositionIxAccounts {
                    owner: ix.accounts[0].0.into(),
                    position_nft_mint: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    pool: ix.accounts[3].0.into(),
                    position: ix.accounts[4].0.into(),
                    pool_authority: ix.accounts[5].0.into(),
                    payer: ix.accounts[6].0.into(),
                    token_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                    event_authority: ix.accounts[9].0.into(),
                    program: ix.accounts[10].0.into(),
                };
                Ok(CpAmmProgramIx::CreatePosition(ix_accounts))
            },
            [88, 206, 0, 91, 60, 175, 151, 118] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CreateTokenBadgeIxAccounts {
                    token_badge: ix.accounts[0].0.into(),
                    token_mint: ix.accounts[1].0.into(),
                    admin: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    event_authority: ix.accounts[4].0.into(),
                    program: ix.accounts[5].0.into(),
                };
                Ok(CpAmmProgramIx::CreateTokenBadge(ix_accounts))
            },
            [188, 50, 249, 165, 93, 151, 38, 63] => {
                check_min_accounts_req(accounts_len, 8)?;
                let ix_accounts = FundRewardIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    reward_vault: ix.accounts[1].0.into(),
                    reward_mint: ix.accounts[2].0.into(),
                    funder_token_account: ix.accounts[3].0.into(),
                    funder: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    event_authority: ix.accounts[6].0.into(),
                    program: ix.accounts[7].0.into(),
                };
                let de_ix_data: FundRewardIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::FundReward(ix_accounts, de_ix_data))
            },
            [20, 161, 241, 24, 189, 221, 180, 2] => {
                check_min_accounts_req(accounts_len, 19)?;
                let ix_accounts = InitializeCustomizablePoolIxAccounts {
                    creator: ix.accounts[0].0.into(),
                    position_nft_mint: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    pool_authority: ix.accounts[4].0.into(),
                    pool: ix.accounts[5].0.into(),
                    position: ix.accounts[6].0.into(),
                    token_a_mint: ix.accounts[7].0.into(),
                    token_b_mint: ix.accounts[8].0.into(),
                    token_a_vault: ix.accounts[9].0.into(),
                    token_b_vault: ix.accounts[10].0.into(),
                    payer_token_a: ix.accounts[11].0.into(),
                    payer_token_b: ix.accounts[12].0.into(),
                    token_a_program: ix.accounts[13].0.into(),
                    token_b_program: ix.accounts[14].0.into(),
                    token2022_program: ix.accounts[15].0.into(),
                    system_program: ix.accounts[16].0.into(),
                    event_authority: ix.accounts[17].0.into(),
                    program: ix.accounts[18].0.into(),
                };
                let de_ix_data: InitializeCustomizablePoolIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::InitializeCustomizablePool(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [95, 180, 10, 172, 84, 174, 232, 40] => {
                check_min_accounts_req(accounts_len, 20)?;
                let ix_accounts = InitializePoolIxAccounts {
                    creator: ix.accounts[0].0.into(),
                    position_nft_mint: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    config: ix.accounts[4].0.into(),
                    pool_authority: ix.accounts[5].0.into(),
                    pool: ix.accounts[6].0.into(),
                    position: ix.accounts[7].0.into(),
                    token_a_mint: ix.accounts[8].0.into(),
                    token_b_mint: ix.accounts[9].0.into(),
                    token_a_vault: ix.accounts[10].0.into(),
                    token_b_vault: ix.accounts[11].0.into(),
                    payer_token_a: ix.accounts[12].0.into(),
                    payer_token_b: ix.accounts[13].0.into(),
                    token_a_program: ix.accounts[14].0.into(),
                    token_b_program: ix.accounts[15].0.into(),
                    token2022_program: ix.accounts[16].0.into(),
                    system_program: ix.accounts[17].0.into(),
                    event_authority: ix.accounts[18].0.into(),
                    program: ix.accounts[19].0.into(),
                };
                let de_ix_data: InitializePoolIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::InitializePool(ix_accounts, de_ix_data))
            },
            [149, 82, 72, 197, 253, 252, 68, 15] => {
                check_min_accounts_req(accounts_len, 21)?;
                let ix_accounts = InitializePoolWithDynamicConfigIxAccounts {
                    creator: ix.accounts[0].0.into(),
                    position_nft_mint: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    payer: ix.accounts[3].0.into(),
                    pool_creator_authority: ix.accounts[4].0.into(),
                    config: ix.accounts[5].0.into(),
                    pool_authority: ix.accounts[6].0.into(),
                    pool: ix.accounts[7].0.into(),
                    position: ix.accounts[8].0.into(),
                    token_a_mint: ix.accounts[9].0.into(),
                    token_b_mint: ix.accounts[10].0.into(),
                    token_a_vault: ix.accounts[11].0.into(),
                    token_b_vault: ix.accounts[12].0.into(),
                    payer_token_a: ix.accounts[13].0.into(),
                    payer_token_b: ix.accounts[14].0.into(),
                    token_a_program: ix.accounts[15].0.into(),
                    token_b_program: ix.accounts[16].0.into(),
                    token2022_program: ix.accounts[17].0.into(),
                    system_program: ix.accounts[18].0.into(),
                    event_authority: ix.accounts[19].0.into(),
                    program: ix.accounts[20].0.into(),
                };
                let de_ix_data: InitializePoolWithDynamicConfigIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::InitializePoolWithDynamicConfig(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [95, 135, 192, 196, 242, 129, 230, 68] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = InitializeRewardIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    reward_vault: ix.accounts[2].0.into(),
                    reward_mint: ix.accounts[3].0.into(),
                    admin: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    event_authority: ix.accounts[7].0.into(),
                    program: ix.accounts[8].0.into(),
                };
                let de_ix_data: InitializeRewardIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::InitializeReward(ix_accounts, de_ix_data))
            },
            [227, 62, 2, 252, 247, 10, 171, 185] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = LockPositionIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    position: ix.accounts[1].0.into(),
                    vesting: ix.accounts[2].0.into(),
                    position_nft_account: ix.accounts[3].0.into(),
                    owner: ix.accounts[4].0.into(),
                    payer: ix.accounts[5].0.into(),
                    system_program: ix.accounts[6].0.into(),
                    event_authority: ix.accounts[7].0.into(),
                    program: ix.accounts[8].0.into(),
                };
                let de_ix_data: LockPositionIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::LockPosition(ix_accounts, de_ix_data))
            },
            [165, 176, 125, 6, 231, 171, 186, 213] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = PermanentLockPositionIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    position: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    owner: ix.accounts[3].0.into(),
                    event_authority: ix.accounts[4].0.into(),
                    program: ix.accounts[5].0.into(),
                };
                let de_ix_data: PermanentLockPositionIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::PermanentLockPosition(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [9, 94, 216, 14, 116, 204, 247, 0] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = RefreshVestingIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    position: ix.accounts[1].0.into(),
                    position_nft_account: ix.accounts[2].0.into(),
                    owner: ix.accounts[3].0.into(),
                };
                Ok(CpAmmProgramIx::RefreshVesting(ix_accounts))
            },
            [10, 51, 61, 35, 112, 105, 24, 85] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = RemoveAllLiquidityIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    token_a_account: ix.accounts[3].0.into(),
                    token_b_account: ix.accounts[4].0.into(),
                    token_a_vault: ix.accounts[5].0.into(),
                    token_b_vault: ix.accounts[6].0.into(),
                    token_a_mint: ix.accounts[7].0.into(),
                    token_b_mint: ix.accounts[8].0.into(),
                    position_nft_account: ix.accounts[9].0.into(),
                    owner: ix.accounts[10].0.into(),
                    token_a_program: ix.accounts[11].0.into(),
                    token_b_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                let de_ix_data: RemoveAllLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::RemoveAllLiquidity(ix_accounts, de_ix_data))
            },
            [80, 85, 209, 72, 24, 206, 177, 108] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = RemoveLiquidityIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    position: ix.accounts[2].0.into(),
                    token_a_account: ix.accounts[3].0.into(),
                    token_b_account: ix.accounts[4].0.into(),
                    token_a_vault: ix.accounts[5].0.into(),
                    token_b_vault: ix.accounts[6].0.into(),
                    token_a_mint: ix.accounts[7].0.into(),
                    token_b_mint: ix.accounts[8].0.into(),
                    position_nft_account: ix.accounts[9].0.into(),
                    owner: ix.accounts[10].0.into(),
                    token_a_program: ix.accounts[11].0.into(),
                    token_b_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                let de_ix_data: RemoveLiquidityIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::RemoveLiquidity(ix_accounts, de_ix_data))
            },
            [112, 87, 135, 223, 83, 204, 132, 53] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = SetPoolStatusIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    event_authority: ix.accounts[2].0.into(),
                    program: ix.accounts[3].0.into(),
                };
                let de_ix_data: SetPoolStatusIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::SetPoolStatus(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = SwapIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    input_token_account: ix.accounts[2].0.into(),
                    output_token_account: ix.accounts[3].0.into(),
                    token_a_vault: ix.accounts[4].0.into(),
                    token_b_vault: ix.accounts[5].0.into(),
                    token_a_mint: ix.accounts[6].0.into(),
                    token_b_mint: ix.accounts[7].0.into(),
                    payer: ix.accounts[8].0.into(),
                    token_a_program: ix.accounts[9].0.into(),
                    token_b_program: ix.accounts[10].0.into(),
                    referral_token_account: if ix.accounts[11]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[11].0.into())
                    },
                    event_authority: ix.accounts[12].0.into(),
                    program: ix.accounts[13].0.into(),
                };
                let de_ix_data: SwapIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::Swap(ix_accounts, de_ix_data))
            },
            [138, 174, 196, 169, 213, 235, 254, 107] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateRewardDurationIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    event_authority: ix.accounts[2].0.into(),
                    program: ix.accounts[3].0.into(),
                };
                let de_ix_data: UpdateRewardDurationIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::UpdateRewardDuration(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [211, 28, 48, 32, 215, 160, 35, 23] => {
                check_min_accounts_req(accounts_len, 4)?;
                let ix_accounts = UpdateRewardFunderIxAccounts {
                    pool: ix.accounts[0].0.into(),
                    admin: ix.accounts[1].0.into(),
                    event_authority: ix.accounts[2].0.into(),
                    program: ix.accounts[3].0.into(),
                };
                let de_ix_data: UpdateRewardFunderIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::UpdateRewardFunder(ix_accounts, de_ix_data))
            },
            [148, 206, 42, 195, 247, 49, 103, 8] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = WithdrawIneligibleRewardIxAccounts {
                    pool_authority: ix.accounts[0].0.into(),
                    pool: ix.accounts[1].0.into(),
                    reward_vault: ix.accounts[2].0.into(),
                    reward_mint: ix.accounts[3].0.into(),
                    funder_token_account: ix.accounts[4].0.into(),
                    funder: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    event_authority: ix.accounts[7].0.into(),
                    program: ix.accounts[8].0.into(),
                };
                let de_ix_data: WithdrawIneligibleRewardIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(CpAmmProgramIx::WithdrawIneligibleReward(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        ix
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AddLiquidityIxAccounts, CpAmmProgramIx, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::AddLiquidityIxAccounts> for AddLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::AddLiquidityIxAccounts {
            proto_def::AddLiquidityIxAccounts {
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::AddLiquidityIxData;
    impl IntoProto<proto_def::AddLiquidityIxData> for AddLiquidityIxData {
        fn into_proto(self) -> proto_def::AddLiquidityIxData {
            proto_def::AddLiquidityIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::ClaimPartnerFeeIxAccounts;
    impl IntoProto<proto_def::ClaimPartnerFeeIxAccounts> for ClaimPartnerFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimPartnerFeeIxAccounts {
            proto_def::ClaimPartnerFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                partner: self.partner.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimPartnerFeeIxData;
    impl IntoProto<proto_def::ClaimPartnerFeeIxData> for ClaimPartnerFeeIxData {
        fn into_proto(self) -> proto_def::ClaimPartnerFeeIxData {
            proto_def::ClaimPartnerFeeIxData {
                max_amount_a: self.max_amount_a,
                max_amount_b: self.max_amount_b,
            }
        }
    }
    use super::ClaimPositionFeeIxAccounts;
    impl IntoProto<proto_def::ClaimPositionFeeIxAccounts> for ClaimPositionFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimPositionFeeIxAccounts {
            proto_def::ClaimPositionFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimProtocolFeeIxAccounts;
    impl IntoProto<proto_def::ClaimProtocolFeeIxAccounts> for ClaimProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::ClaimProtocolFeeIxAccounts {
            proto_def::ClaimProtocolFeeIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                claim_fee_operator: self.claim_fee_operator.to_string(),
                operator: self.operator.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimRewardIxAccounts;
    impl IntoProto<proto_def::ClaimRewardIxAccounts> for ClaimRewardIxAccounts {
        fn into_proto(self) -> proto_def::ClaimRewardIxAccounts {
            proto_def::ClaimRewardIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                reward_vault: self.reward_vault.to_string(),
                reward_mint: self.reward_mint.to_string(),
                user_token_account: self.user_token_account.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                token_program: self.token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClaimRewardIxData;
    impl IntoProto<proto_def::ClaimRewardIxData> for ClaimRewardIxData {
        fn into_proto(self) -> proto_def::ClaimRewardIxData {
            proto_def::ClaimRewardIxData {
                reward_index: self.reward_index.into(),
            }
        }
    }
    use super::CloseClaimFeeOperatorIxAccounts;
    impl IntoProto<proto_def::CloseClaimFeeOperatorIxAccounts> for CloseClaimFeeOperatorIxAccounts {
        fn into_proto(self) -> proto_def::CloseClaimFeeOperatorIxAccounts {
            proto_def::CloseClaimFeeOperatorIxAccounts {
                claim_fee_operator: self.claim_fee_operator.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
                admin: self.admin.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CloseConfigIxAccounts;
    impl IntoProto<proto_def::CloseConfigIxAccounts> for CloseConfigIxAccounts {
        fn into_proto(self) -> proto_def::CloseConfigIxAccounts {
            proto_def::CloseConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ClosePositionIxAccounts;
    impl IntoProto<proto_def::ClosePositionIxAccounts> for ClosePositionIxAccounts {
        fn into_proto(self) -> proto_def::ClosePositionIxAccounts {
            proto_def::ClosePositionIxAccounts {
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                pool_authority: self.pool_authority.to_string(),
                rent_receiver: self.rent_receiver.to_string(),
                owner: self.owner.to_string(),
                token_program: self.token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateClaimFeeOperatorIxAccounts;
    impl IntoProto<proto_def::CreateClaimFeeOperatorIxAccounts> for CreateClaimFeeOperatorIxAccounts {
        fn into_proto(self) -> proto_def::CreateClaimFeeOperatorIxAccounts {
            proto_def::CreateClaimFeeOperatorIxAccounts {
                claim_fee_operator: self.claim_fee_operator.to_string(),
                operator: self.operator.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateConfigIxAccounts;
    impl IntoProto<proto_def::CreateConfigIxAccounts> for CreateConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateConfigIxAccounts {
            proto_def::CreateConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateConfigIxData;
    impl IntoProto<proto_def::CreateConfigIxData> for CreateConfigIxData {
        fn into_proto(self) -> proto_def::CreateConfigIxData {
            proto_def::CreateConfigIxData {
                index: self.index,
                pool_fees: Some(self.pool_fees.into_proto()),
                sqrt_min_price: self.sqrt_min_price.to_string(),
                sqrt_max_price: self.sqrt_max_price.to_string(),
                vault_config_key: self.vault_config_key.to_string(),
                pool_creator_authority: self.pool_creator_authority.to_string(),
                activation_type: self.activation_type.into(),
                collect_fee_mode: self.collect_fee_mode.into(),
            }
        }
    }
    use super::CreateDynamicConfigIxAccounts;
    impl IntoProto<proto_def::CreateDynamicConfigIxAccounts> for CreateDynamicConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateDynamicConfigIxAccounts {
            proto_def::CreateDynamicConfigIxAccounts {
                config: self.config.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateDynamicConfigIxData;
    impl IntoProto<proto_def::CreateDynamicConfigIxData> for CreateDynamicConfigIxData {
        fn into_proto(self) -> proto_def::CreateDynamicConfigIxData {
            proto_def::CreateDynamicConfigIxData {
                index: self.index,
                pool_creator_authority: self.pool_creator_authority.to_string(),
            }
        }
    }
    use super::CreatePositionIxAccounts;
    impl IntoProto<proto_def::CreatePositionIxAccounts> for CreatePositionIxAccounts {
        fn into_proto(self) -> proto_def::CreatePositionIxAccounts {
            proto_def::CreatePositionIxAccounts {
                owner: self.owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                pool_authority: self.pool_authority.to_string(),
                payer: self.payer.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CreateTokenBadgeIxAccounts;
    impl IntoProto<proto_def::CreateTokenBadgeIxAccounts> for CreateTokenBadgeIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenBadgeIxAccounts {
            proto_def::CreateTokenBadgeIxAccounts {
                token_badge: self.token_badge.to_string(),
                token_mint: self.token_mint.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::FundRewardIxAccounts;
    impl IntoProto<proto_def::FundRewardIxAccounts> for FundRewardIxAccounts {
        fn into_proto(self) -> proto_def::FundRewardIxAccounts {
            proto_def::FundRewardIxAccounts {
                pool: self.pool.to_string(),
                reward_vault: self.reward_vault.to_string(),
                reward_mint: self.reward_mint.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                funder: self.funder.to_string(),
                token_program: self.token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::FundRewardIxData;
    impl IntoProto<proto_def::FundRewardIxData> for FundRewardIxData {
        fn into_proto(self) -> proto_def::FundRewardIxData {
            proto_def::FundRewardIxData {
                reward_index: self.reward_index.into(),
                amount: self.amount,
                carry_forward: self.carry_forward,
            }
        }
    }
    use super::InitializeCustomizablePoolIxAccounts;
    impl IntoProto<proto_def::InitializeCustomizablePoolIxAccounts>
        for InitializeCustomizablePoolIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializeCustomizablePoolIxAccounts {
            proto_def::InitializeCustomizablePoolIxAccounts {
                creator: self.creator.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                payer: self.payer.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                token2022_program: self.token2022_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeCustomizablePoolIxData;
    impl IntoProto<proto_def::InitializeCustomizablePoolIxData> for InitializeCustomizablePoolIxData {
        fn into_proto(self) -> proto_def::InitializeCustomizablePoolIxData {
            proto_def::InitializeCustomizablePoolIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::InitializePoolIxAccounts;
    impl IntoProto<proto_def::InitializePoolIxAccounts> for InitializePoolIxAccounts {
        fn into_proto(self) -> proto_def::InitializePoolIxAccounts {
            proto_def::InitializePoolIxAccounts {
                creator: self.creator.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                payer: self.payer.to_string(),
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                token2022_program: self.token2022_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializePoolIxData;
    impl IntoProto<proto_def::InitializePoolIxData> for InitializePoolIxData {
        fn into_proto(self) -> proto_def::InitializePoolIxData {
            proto_def::InitializePoolIxData {
                liquidity: self.liquidity.to_string(),
                sqrt_price: self.sqrt_price.to_string(),
                activation_point: self.activation_point,
            }
        }
    }
    use super::InitializePoolWithDynamicConfigIxAccounts;
    impl IntoProto<proto_def::InitializePoolWithDynamicConfigIxAccounts>
        for InitializePoolWithDynamicConfigIxAccounts
    {
        fn into_proto(self) -> proto_def::InitializePoolWithDynamicConfigIxAccounts {
            proto_def::InitializePoolWithDynamicConfigIxAccounts {
                creator: self.creator.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                payer: self.payer.to_string(),
                pool_creator_authority: self.pool_creator_authority.to_string(),
                config: self.config.to_string(),
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                payer_token_a: self.payer_token_a.to_string(),
                payer_token_b: self.payer_token_b.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                token2022_program: self.token2022_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializePoolWithDynamicConfigIxData;
    impl IntoProto<proto_def::InitializePoolWithDynamicConfigIxData>
        for InitializePoolWithDynamicConfigIxData
    {
        fn into_proto(self) -> proto_def::InitializePoolWithDynamicConfigIxData {
            proto_def::InitializePoolWithDynamicConfigIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::InitializeRewardIxAccounts;
    impl IntoProto<proto_def::InitializeRewardIxAccounts> for InitializeRewardIxAccounts {
        fn into_proto(self) -> proto_def::InitializeRewardIxAccounts {
            proto_def::InitializeRewardIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                reward_vault: self.reward_vault.to_string(),
                reward_mint: self.reward_mint.to_string(),
                admin: self.admin.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeRewardIxData;
    impl IntoProto<proto_def::InitializeRewardIxData> for InitializeRewardIxData {
        fn into_proto(self) -> proto_def::InitializeRewardIxData {
            proto_def::InitializeRewardIxData {
                reward_index: self.reward_index.into(),
                reward_duration: self.reward_duration,
                funder: self.funder.to_string(),
            }
        }
    }
    use super::LockPositionIxAccounts;
    impl IntoProto<proto_def::LockPositionIxAccounts> for LockPositionIxAccounts {
        fn into_proto(self) -> proto_def::LockPositionIxAccounts {
            proto_def::LockPositionIxAccounts {
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                vesting: self.vesting.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::LockPositionIxData;
    impl IntoProto<proto_def::LockPositionIxData> for LockPositionIxData {
        fn into_proto(self) -> proto_def::LockPositionIxData {
            proto_def::LockPositionIxData {
                cliff_point: self.cliff_point,
                period_frequency: self.period_frequency,
                cliff_unlock_liquidity: self.cliff_unlock_liquidity.to_string(),
                liquidity_per_period: self.liquidity_per_period.to_string(),
                number_of_period: self.number_of_period.into(),
            }
        }
    }
    use super::PermanentLockPositionIxAccounts;
    impl IntoProto<proto_def::PermanentLockPositionIxAccounts> for PermanentLockPositionIxAccounts {
        fn into_proto(self) -> proto_def::PermanentLockPositionIxAccounts {
            proto_def::PermanentLockPositionIxAccounts {
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::PermanentLockPositionIxData;
    impl IntoProto<proto_def::PermanentLockPositionIxData> for PermanentLockPositionIxData {
        fn into_proto(self) -> proto_def::PermanentLockPositionIxData {
            proto_def::PermanentLockPositionIxData {
                permanent_lock_liquidity: self.permanent_lock_liquidity.to_string(),
            }
        }
    }
    use super::RefreshVestingIxAccounts;
    impl IntoProto<proto_def::RefreshVestingIxAccounts> for RefreshVestingIxAccounts {
        fn into_proto(self) -> proto_def::RefreshVestingIxAccounts {
            proto_def::RefreshVestingIxAccounts {
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
            }
        }
    }
    use super::RemoveAllLiquidityIxAccounts;
    impl IntoProto<proto_def::RemoveAllLiquidityIxAccounts> for RemoveAllLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::RemoveAllLiquidityIxAccounts {
            proto_def::RemoveAllLiquidityIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RemoveAllLiquidityIxData;
    impl IntoProto<proto_def::RemoveAllLiquidityIxData> for RemoveAllLiquidityIxData {
        fn into_proto(self) -> proto_def::RemoveAllLiquidityIxData {
            proto_def::RemoveAllLiquidityIxData {
                token_a_amount_threshold: self.token_a_amount_threshold,
                token_b_amount_threshold: self.token_b_amount_threshold,
            }
        }
    }
    use super::RemoveLiquidityIxAccounts;
    impl IntoProto<proto_def::RemoveLiquidityIxAccounts> for RemoveLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::RemoveLiquidityIxAccounts {
            proto_def::RemoveLiquidityIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                position: self.position.to_string(),
                token_a_account: self.token_a_account.to_string(),
                token_b_account: self.token_b_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                owner: self.owner.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RemoveLiquidityIxData;
    impl IntoProto<proto_def::RemoveLiquidityIxData> for RemoveLiquidityIxData {
        fn into_proto(self) -> proto_def::RemoveLiquidityIxData {
            proto_def::RemoveLiquidityIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::SetPoolStatusIxAccounts;
    impl IntoProto<proto_def::SetPoolStatusIxAccounts> for SetPoolStatusIxAccounts {
        fn into_proto(self) -> proto_def::SetPoolStatusIxAccounts {
            proto_def::SetPoolStatusIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SetPoolStatusIxData;
    impl IntoProto<proto_def::SetPoolStatusIxData> for SetPoolStatusIxData {
        fn into_proto(self) -> proto_def::SetPoolStatusIxData {
            proto_def::SetPoolStatusIxData {
                status: self.status.into(),
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                token_a_vault: self.token_a_vault.to_string(),
                token_b_vault: self.token_b_vault.to_string(),
                token_a_mint: self.token_a_mint.to_string(),
                token_b_mint: self.token_b_mint.to_string(),
                payer: self.payer.to_string(),
                token_a_program: self.token_a_program.to_string(),
                token_b_program: self.token_b_program.to_string(),
                referral_token_account: self.referral_token_account.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                params: Some(self.params.into_proto()),
            }
        }
    }
    use super::UpdateRewardDurationIxAccounts;
    impl IntoProto<proto_def::UpdateRewardDurationIxAccounts> for UpdateRewardDurationIxAccounts {
        fn into_proto(self) -> proto_def::UpdateRewardDurationIxAccounts {
            proto_def::UpdateRewardDurationIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::UpdateRewardDurationIxData;
    impl IntoProto<proto_def::UpdateRewardDurationIxData> for UpdateRewardDurationIxData {
        fn into_proto(self) -> proto_def::UpdateRewardDurationIxData {
            proto_def::UpdateRewardDurationIxData {
                reward_index: self.reward_index.into(),
                new_duration: self.new_duration,
            }
        }
    }
    use super::UpdateRewardFunderIxAccounts;
    impl IntoProto<proto_def::UpdateRewardFunderIxAccounts> for UpdateRewardFunderIxAccounts {
        fn into_proto(self) -> proto_def::UpdateRewardFunderIxAccounts {
            proto_def::UpdateRewardFunderIxAccounts {
                pool: self.pool.to_string(),
                admin: self.admin.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::UpdateRewardFunderIxData;
    impl IntoProto<proto_def::UpdateRewardFunderIxData> for UpdateRewardFunderIxData {
        fn into_proto(self) -> proto_def::UpdateRewardFunderIxData {
            proto_def::UpdateRewardFunderIxData {
                reward_index: self.reward_index.into(),
                new_funder: self.new_funder.to_string(),
            }
        }
    }
    use super::WithdrawIneligibleRewardIxAccounts;
    impl IntoProto<proto_def::WithdrawIneligibleRewardIxAccounts>
        for WithdrawIneligibleRewardIxAccounts
    {
        fn into_proto(self) -> proto_def::WithdrawIneligibleRewardIxAccounts {
            proto_def::WithdrawIneligibleRewardIxAccounts {
                pool_authority: self.pool_authority.to_string(),
                pool: self.pool.to_string(),
                reward_vault: self.reward_vault.to_string(),
                reward_mint: self.reward_mint.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                funder: self.funder.to_string(),
                token_program: self.token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::WithdrawIneligibleRewardIxData;
    impl IntoProto<proto_def::WithdrawIneligibleRewardIxData> for WithdrawIneligibleRewardIxData {
        fn into_proto(self) -> proto_def::WithdrawIneligibleRewardIxData {
            proto_def::WithdrawIneligibleRewardIxData {
                reward_index: self.reward_index.into(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for CpAmmProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                CpAmmProgramIx::AddLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::AddLiquidity(
                        proto_def::AddLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::ClaimPartnerFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimPartnerFee(
                        proto_def::ClaimPartnerFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::ClaimPositionFee(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimPositionFee(
                        proto_def::ClaimPositionFeeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::ClaimProtocolFee(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimProtocolFee(
                        proto_def::ClaimProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::ClaimReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimReward(
                        proto_def::ClaimRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CloseClaimFeeOperator(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseClaimFeeOperator(
                        proto_def::CloseClaimFeeOperatorIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CloseConfig(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseConfig(
                        proto_def::CloseConfigIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::ClosePosition(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClosePosition(
                        proto_def::ClosePositionIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CreateClaimFeeOperator(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateClaimFeeOperator(
                        proto_def::CreateClaimFeeOperatorIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CreateConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateConfig(
                        proto_def::CreateConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CreateDynamicConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateDynamicConfig(
                        proto_def::CreateDynamicConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CreatePosition(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatePosition(
                        proto_def::CreatePositionIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::CreateTokenBadge(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenBadge(
                        proto_def::CreateTokenBadgeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::FundReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::FundReward(
                        proto_def::FundRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::InitializeCustomizablePool(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeCustomizablePool(
                        proto_def::InitializeCustomizablePoolIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::InitializePool(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializePool(
                        proto_def::InitializePoolIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::InitializePoolWithDynamicConfig(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::InitializePoolWithDynamicConfig(
                                proto_def::InitializePoolWithDynamicConfigIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                CpAmmProgramIx::InitializeReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeReward(
                        proto_def::InitializeRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::LockPosition(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::LockPosition(
                        proto_def::LockPositionIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::PermanentLockPosition(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::PermanentLockPosition(
                        proto_def::PermanentLockPositionIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::RefreshVesting(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RefreshVesting(
                        proto_def::RefreshVestingIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::RemoveAllLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveAllLiquidity(
                        proto_def::RemoveAllLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::RemoveLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RemoveLiquidity(
                        proto_def::RemoveLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::SetPoolStatus(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SetPoolStatus(
                        proto_def::SetPoolStatusIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::Swap(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                CpAmmProgramIx::UpdateRewardDuration(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateRewardDuration(
                        proto_def::UpdateRewardDurationIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::UpdateRewardFunder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateRewardFunder(
                        proto_def::UpdateRewardFunderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                CpAmmProgramIx::WithdrawIneligibleReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawIneligibleReward(
                        proto_def::WithdrawIneligibleRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
