//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

// #[cfg(feature = "proto")]
pub mod proto_types_parsers {
    use yellowstone_vixen_core::proto_helper_traits;
    proto_helper_traits!();
    use crate::proto_def;

    use crate::types::BetCancelled;
    impl IntoProto<proto_def::BetCancelled> for BetCancelled {
        fn into_proto(self) -> proto_def::BetCancelled {
            proto_def::BetCancelled {
                game_id: self.game_id,
                bet_id: self.bet_id,
                player: self.player.to_string(),
                refund_amount: self.refund_amount,
                remaining_players: self.remaining_players.into(),
            }
        }
    }
    use crate::types::BetPlaced;
    impl IntoProto<proto_def::BetPlaced> for BetPlaced {
        fn into_proto(self) -> proto_def::BetPlaced {
            proto_def::BetPlaced {
                game_id: self.game_id,
                bet_id: self.bet_id,
                player: self.player.to_string(),
                choice: self.choice.map(|x| x as i32),
                bet_amount: self.bet_amount,
                total_players: self.total_players.into(),
            }
        }
    }
    use crate::types::FlipBetInfo;
    impl IntoProto<proto_def::FlipBetInfo> for FlipBetInfo {
        fn into_proto(self) -> proto_def::FlipBetInfo {
            proto_def::FlipBetInfo {
                bet_id: self.bet_id,
                player: self.player.to_string(),
                amount: self.amount,
                choice: self.choice.map(|x| x as i32),
                placed_at: self.placed_at,
                status: self.status as i32,
                odds: Some(self.odds.into_proto()),
                is_winner: self.is_winner,
            }
        }
    }
    use crate::types::FlipBetOdds;
    impl IntoProto<proto_def::FlipBetOdds> for FlipBetOdds {
        fn into_proto(self) -> proto_def::FlipBetOdds {
            proto_def::FlipBetOdds {
                odds_factor: self.odds_factor,
                bet_type: self.bet_type,
            }
        }
    }
    use crate::types::FlipBetPlacementResult;
    impl IntoProto<proto_def::FlipBetPlacementResult> for FlipBetPlacementResult {
        fn into_proto(self) -> proto_def::FlipBetPlacementResult {
            proto_def::FlipBetPlacementResult {
                success: self.success,
                bet_id: self.bet_id,
                odds: Some(self.odds.into_proto()),
            }
        }
    }
    use crate::types::FlipBetValidation;
    impl IntoProto<proto_def::FlipBetValidation> for FlipBetValidation {
        fn into_proto(self) -> proto_def::FlipBetValidation {
            proto_def::FlipBetValidation {
                allowed: self.allowed,
                rejection_reason: self.rejection_reason,
                odds: Some(self.odds.into_proto()),
            }
        }
    }
    use crate::types::FlipCancellationResult;
    impl IntoProto<proto_def::FlipCancellationResult> for FlipCancellationResult {
        fn into_proto(self) -> proto_def::FlipCancellationResult {
            proto_def::FlipCancellationResult {
                cancelled_at: self.cancelled_at,
            }
        }
    }
    use crate::types::FlipCancellationValidation;
    impl IntoProto<proto_def::FlipCancellationValidation> for FlipCancellationValidation {
        fn into_proto(self) -> proto_def::FlipCancellationValidation {
            proto_def::FlipCancellationValidation {
                allowed: self.allowed,
                reason: self.reason,
                refund_amount: self.refund_amount,
            }
        }
    }
    use crate::types::FlipPayoutDistribution;
    impl IntoProto<proto_def::FlipPayoutDistribution> for FlipPayoutDistribution {
        fn into_proto(self) -> proto_def::FlipPayoutDistribution {
            proto_def::FlipPayoutDistribution {
                payouts: self.payouts.into_iter().map(|x| x.into_proto()).collect(),
                house_amount: self.house_amount,
            }
        }
    }
    use crate::types::FlipPayoutEntry;
    impl IntoProto<proto_def::FlipPayoutEntry> for FlipPayoutEntry {
        fn into_proto(self) -> proto_def::FlipPayoutEntry {
            proto_def::FlipPayoutEntry {
                recipient: self.recipient.to_string(),
                amount: self.amount,
            }
        }
    }
    use crate::types::GameActivated;
    impl IntoProto<proto_def::GameActivated> for GameActivated {
        fn into_proto(self) -> proto_def::GameActivated {
            proto_def::GameActivated {
                game_id: self.game_id,
                activated_at: self.activated_at,
                settlement_program: self.settlement_program.to_string(),
            }
        }
    }
    use crate::types::GameBettingClosed;
    impl IntoProto<proto_def::GameBettingClosed> for GameBettingClosed {
        fn into_proto(self) -> proto_def::GameBettingClosed {
            proto_def::GameBettingClosed {
                game_id: self.game_id,
                settling_started_at: self.settling_started_at,
                settling_started_slot: self.settling_started_slot,
                settlement_program: self.settlement_program.to_string(),
            }
        }
    }
    use crate::types::GameCancelled;
    impl IntoProto<proto_def::GameCancelled> for GameCancelled {
        fn into_proto(self) -> proto_def::GameCancelled {
            proto_def::GameCancelled {
                game_id: self.game_id,
                cancelled_at: self.cancelled_at,
            }
        }
    }
    use crate::types::GameConfig;
    impl IntoProto<proto_def::GameConfig> for GameConfig {
        fn into_proto(self) -> proto_def::GameConfig {
            proto_def::GameConfig {
                game_type: self.game_type as i32,
                authorization: self.authorization as i32,
                min_players: self.min_players.into(),
                max_players: self.max_players.into(),
                bet_amount: self.bet_amount,
                trigger_type: self.trigger_type as i32,
                join_window_seconds: self.join_window_seconds,
                authorized_players: self
                    .authorized_players
                    .into_iter()
                    .map(|x| x.to_string())
                    .collect(),
            }
        }
    }
    use crate::types::GameSettled;
    impl IntoProto<proto_def::GameSettled> for GameSettled {
        fn into_proto(self) -> proto_def::GameSettled {
            proto_def::GameSettled {
                game_id: self.game_id,
                final_randomness: self
                    .final_randomness
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
                payout_distribution: Some(self.payout_distribution.into_proto()),
                settled_at: self.settled_at,
            }
        }
    }
    use crate::types::FlipStateGameBetData;
    impl IntoProto<proto_def::FlipStateGameBetData> for FlipStateGameBetData {
        fn into_proto(self) -> proto_def::FlipStateGameBetData {
            proto_def::FlipStateGameBetData {
                bet_id: self.bet_id,
                player: self.player.to_string(),
                amount: self.amount,
                choice: self.choice.map(|x| x as i32),
                placed_at: self.placed_at,
                status: self.status as i32,
            }
        }
    }
    use crate::types::GameInterfaceBetData;
    impl IntoProto<proto_def::GameInterfaceBetData> for GameInterfaceBetData {
        fn into_proto(self) -> proto_def::GameInterfaceBetData {
            proto_def::GameInterfaceBetData {
                player: self.player.to_string(),
                bet_amount: self.bet_amount,
                bet_data: self.bet_data.into_iter().map(|x| x.into()).collect(),
                bet_id: self.bet_id,
            }
        }
    }
}
