//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::deserialize_checked;

use crate::instructions::{
    ActivateGameInternal as ActivateGameInternalIxAccounts,
    CancelBetInternal as CancelBetInternalIxAccounts,
    CancelBetInternalInstructionArgs as CancelBetInternalIxData,
    CancelGameInternal as CancelGameInternalIxAccounts,
    CloseBettingInternal as CloseBettingInternalIxAccounts,
    CreateGameInternal as CreateGameInternalIxAccounts,
    CreateGameInternalInstructionArgs as CreateGameInternalIxData,
    GetBetInfo as GetBetInfoIxAccounts, GetBetInfoInstructionArgs as GetBetInfoIxData,
    GetBetOdds as GetBetOddsIxAccounts, GetBetOddsInstructionArgs as GetBetOddsIxData,
    GetPayoutDistribution as GetPayoutDistributionIxAccounts,
    GetPayoutDistributionInstructionArgs as GetPayoutDistributionIxData,
    Initialize as InitializeIxAccounts, InitializeInstructionArgs as InitializeIxData,
    PlaceBetInternal as PlaceBetInternalIxAccounts,
    PlaceBetInternalInstructionArgs as PlaceBetInternalIxData,
    SettleGameInternal as SettleGameInternalIxAccounts,
    SettleGameInternalInstructionArgs as SettleGameInternalIxData,
    ValidateBet as ValidateBetIxAccounts, ValidateBetInstructionArgs as ValidateBetIxData,
    ValidateCancellation as ValidateCancellationIxAccounts,
    ValidateCancellationInstructionArgs as ValidateCancellationIxData,
};
use crate::ID;

/// Flip Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum FlipProgramIx {
    ActivateGameInternal(ActivateGameInternalIxAccounts),
    CancelBetInternal(CancelBetInternalIxAccounts, CancelBetInternalIxData),
    CancelGameInternal(CancelGameInternalIxAccounts),
    CloseBettingInternal(CloseBettingInternalIxAccounts),
    CreateGameInternal(CreateGameInternalIxAccounts, CreateGameInternalIxData),
    GetBetInfo(GetBetInfoIxAccounts, GetBetInfoIxData),
    GetBetOdds(GetBetOddsIxAccounts, GetBetOddsIxData),
    GetPayoutDistribution(GetPayoutDistributionIxAccounts, GetPayoutDistributionIxData),
    Initialize(InitializeIxAccounts, InitializeIxData),
    PlaceBetInternal(PlaceBetInternalIxAccounts, PlaceBetInternalIxData),
    SettleGameInternal(SettleGameInternalIxAccounts, SettleGameInternalIxData),
    ValidateBet(ValidateBetIxAccounts, ValidateBetIxData),
    ValidateCancellation(ValidateCancellationIxAccounts, ValidateCancellationIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;

    #[cfg(not(feature = "shared-data"))]
    type Output = FlipProgramIx;

    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<FlipProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        "Flip::InstructionParser".into()
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [18, 52, 86, 120, 154, 188, 222, 241] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ActivateGameInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(FlipProgramIx::ActivateGameInternal(ix_accounts))
            }
            [18, 52, 86, 120, 154, 188, 222, 243] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CancelBetInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CancelBetInternalIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::CancelBetInternal(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 245] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CancelGameInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(FlipProgramIx::CancelGameInternal(ix_accounts))
            }
            [18, 52, 86, 120, 154, 188, 222, 246] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseBettingInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(FlipProgramIx::CloseBettingInternal(ix_accounts))
            }
            [18, 52, 86, 120, 154, 188, 222, 240] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateGameInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateGameInternalIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::CreateGameInternal(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 251] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GetBetInfoIxAccounts {
                    game: next_account(accounts)?,
                };
                let de_ix_data: GetBetInfoIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::GetBetInfo(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 250] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GetBetOddsIxAccounts {
                    game: next_account(accounts)?,
                };
                let de_ix_data: GetBetOddsIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::GetBetOdds(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 249] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = GetPayoutDistributionIxAccounts {
                    game: next_account(accounts)?,
                };
                let de_ix_data: GetPayoutDistributionIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::GetPayoutDistribution(
                    ix_accounts,
                    de_ix_data,
                ))
            }
            [175, 175, 109, 31, 13, 152, 155, 237] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeIxAccounts {
                    global_config: next_account(accounts)?,
                    admin: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: InitializeIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::Initialize(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 242] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlaceBetInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: PlaceBetInternalIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::PlaceBetInternal(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 244] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SettleGameInternalIxAccounts {
                    game: next_account(accounts)?,
                    global_config: next_account(accounts)?,
                    settlement_authority: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: SettleGameInternalIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::SettleGameInternal(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 247] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ValidateBetIxAccounts {
                    game: next_account(accounts)?,
                };
                let de_ix_data: ValidateBetIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::ValidateBet(ix_accounts, de_ix_data))
            }
            [18, 52, 86, 120, 154, 188, 222, 248] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ValidateCancellationIxAccounts {
                    game: next_account(accounts)?,
                };
                let de_ix_data: ValidateCancellationIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(FlipProgramIx::ValidateCancellation(ix_accounts, de_ix_data))
            }
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            }
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use super::{FlipProgramIx, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    use yellowstone_vixen_core::proto::ParseProto;

    use super::ActivateGameInternalIxAccounts;
    impl IntoProto<proto_def::ActivateGameInternalIxAccounts> for ActivateGameInternalIxAccounts {
        fn into_proto(self) -> proto_def::ActivateGameInternalIxAccounts {
            proto_def::ActivateGameInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CancelBetInternalIxAccounts;
    impl IntoProto<proto_def::CancelBetInternalIxAccounts> for CancelBetInternalIxAccounts {
        fn into_proto(self) -> proto_def::CancelBetInternalIxAccounts {
            proto_def::CancelBetInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CancelBetInternalIxData;
    impl IntoProto<proto_def::CancelBetInternalIxData> for CancelBetInternalIxData {
        fn into_proto(self) -> proto_def::CancelBetInternalIxData {
            proto_def::CancelBetInternalIxData {
                bet_id: self.bet_id,
                player: self.player.to_string(),
            }
        }
    }
    use super::CancelGameInternalIxAccounts;
    impl IntoProto<proto_def::CancelGameInternalIxAccounts> for CancelGameInternalIxAccounts {
        fn into_proto(self) -> proto_def::CancelGameInternalIxAccounts {
            proto_def::CancelGameInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CloseBettingInternalIxAccounts;
    impl IntoProto<proto_def::CloseBettingInternalIxAccounts> for CloseBettingInternalIxAccounts {
        fn into_proto(self) -> proto_def::CloseBettingInternalIxAccounts {
            proto_def::CloseBettingInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateGameInternalIxAccounts;
    impl IntoProto<proto_def::CreateGameInternalIxAccounts> for CreateGameInternalIxAccounts {
        fn into_proto(self) -> proto_def::CreateGameInternalIxAccounts {
            proto_def::CreateGameInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateGameInternalIxData;
    impl IntoProto<proto_def::CreateGameInternalIxData> for CreateGameInternalIxData {
        fn into_proto(self) -> proto_def::CreateGameInternalIxData {
            proto_def::CreateGameInternalIxData {
                game_id: self.game_id,
                creator: self.creator.to_string(),
                game_config_data: self
                    .game_config_data
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
            }
        }
    }
    use super::GetBetInfoIxAccounts;
    impl IntoProto<proto_def::GetBetInfoIxAccounts> for GetBetInfoIxAccounts {
        fn into_proto(self) -> proto_def::GetBetInfoIxAccounts {
            proto_def::GetBetInfoIxAccounts {
                game: self.game.to_string(),
            }
        }
    }
    use super::GetBetInfoIxData;
    impl IntoProto<proto_def::GetBetInfoIxData> for GetBetInfoIxData {
        fn into_proto(self) -> proto_def::GetBetInfoIxData {
            proto_def::GetBetInfoIxData {
                bet_id: self.bet_id,
            }
        }
    }
    use super::GetBetOddsIxAccounts;
    impl IntoProto<proto_def::GetBetOddsIxAccounts> for GetBetOddsIxAccounts {
        fn into_proto(self) -> proto_def::GetBetOddsIxAccounts {
            proto_def::GetBetOddsIxAccounts {
                game: self.game.to_string(),
            }
        }
    }
    use super::GetBetOddsIxData;
    impl IntoProto<proto_def::GetBetOddsIxData> for GetBetOddsIxData {
        fn into_proto(self) -> proto_def::GetBetOddsIxData {
            proto_def::GetBetOddsIxData {
                player: self.player.to_string(),
                bet_data: self.bet_data.into_iter().map(|x| x.into()).collect(),
                bet_amount: self.bet_amount,
            }
        }
    }
    use super::GetPayoutDistributionIxAccounts;
    impl IntoProto<proto_def::GetPayoutDistributionIxAccounts> for GetPayoutDistributionIxAccounts {
        fn into_proto(self) -> proto_def::GetPayoutDistributionIxAccounts {
            proto_def::GetPayoutDistributionIxAccounts {
                game: self.game.to_string(),
            }
        }
    }
    use super::GetPayoutDistributionIxData;
    impl IntoProto<proto_def::GetPayoutDistributionIxData> for GetPayoutDistributionIxData {
        fn into_proto(self) -> proto_def::GetPayoutDistributionIxData {
            proto_def::GetPayoutDistributionIxData {
                final_randomness: self
                    .final_randomness
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
            }
        }
    }
    use super::InitializeIxAccounts;
    impl IntoProto<proto_def::InitializeIxAccounts> for InitializeIxAccounts {
        fn into_proto(self) -> proto_def::InitializeIxAccounts {
            proto_def::InitializeIxAccounts {
                global_config: self.global_config.to_string(),
                admin: self.admin.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::InitializeIxData;
    impl IntoProto<proto_def::InitializeIxData> for InitializeIxData {
        fn into_proto(self) -> proto_def::InitializeIxData {
            proto_def::InitializeIxData {
                settlement_program: self.settlement_program.to_string(),
            }
        }
    }
    use super::PlaceBetInternalIxAccounts;
    impl IntoProto<proto_def::PlaceBetInternalIxAccounts> for PlaceBetInternalIxAccounts {
        fn into_proto(self) -> proto_def::PlaceBetInternalIxAccounts {
            proto_def::PlaceBetInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::PlaceBetInternalIxData;
    impl IntoProto<proto_def::PlaceBetInternalIxData> for PlaceBetInternalIxData {
        fn into_proto(self) -> proto_def::PlaceBetInternalIxData {
            proto_def::PlaceBetInternalIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }
    use super::SettleGameInternalIxAccounts;
    impl IntoProto<proto_def::SettleGameInternalIxAccounts> for SettleGameInternalIxAccounts {
        fn into_proto(self) -> proto_def::SettleGameInternalIxAccounts {
            proto_def::SettleGameInternalIxAccounts {
                game: self.game.to_string(),
                global_config: self.global_config.to_string(),
                settlement_authority: self.settlement_authority.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::SettleGameInternalIxData;
    impl IntoProto<proto_def::SettleGameInternalIxData> for SettleGameInternalIxData {
        fn into_proto(self) -> proto_def::SettleGameInternalIxData {
            proto_def::SettleGameInternalIxData {
                final_randomness: self
                    .final_randomness
                    .into_iter()
                    .map(|x| x.into())
                    .collect(),
            }
        }
    }
    use super::ValidateBetIxAccounts;
    impl IntoProto<proto_def::ValidateBetIxAccounts> for ValidateBetIxAccounts {
        fn into_proto(self) -> proto_def::ValidateBetIxAccounts {
            proto_def::ValidateBetIxAccounts {
                game: self.game.to_string(),
            }
        }
    }
    use super::ValidateBetIxData;
    impl IntoProto<proto_def::ValidateBetIxData> for ValidateBetIxData {
        fn into_proto(self) -> proto_def::ValidateBetIxData {
            proto_def::ValidateBetIxData {
                data: Some(self.data.into_proto()),
            }
        }
    }
    use super::ValidateCancellationIxAccounts;
    impl IntoProto<proto_def::ValidateCancellationIxAccounts> for ValidateCancellationIxAccounts {
        fn into_proto(self) -> proto_def::ValidateCancellationIxAccounts {
            proto_def::ValidateCancellationIxAccounts {
                game: self.game.to_string(),
            }
        }
    }
    use super::ValidateCancellationIxData;
    impl IntoProto<proto_def::ValidateCancellationIxData> for ValidateCancellationIxData {
        fn into_proto(self) -> proto_def::ValidateCancellationIxData {
            proto_def::ValidateCancellationIxData {
                bet_id: self.bet_id,
                player: self.player.to_string(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for FlipProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                FlipProgramIx::ActivateGameInternal(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ActivateGameInternal(
                        proto_def::ActivateGameInternalIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::CancelBetInternal(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelBetInternal(
                        proto_def::CancelBetInternalIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::CancelGameInternal(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelGameInternal(
                        proto_def::CancelGameInternalIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::CloseBettingInternal(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseBettingInternal(
                        proto_def::CloseBettingInternalIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::CreateGameInternal(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateGameInternal(
                        proto_def::CreateGameInternalIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::GetBetInfo(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::GetBetInfo(
                        proto_def::GetBetInfoIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::GetBetOdds(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::GetBetOdds(
                        proto_def::GetBetOddsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::GetPayoutDistribution(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::GetPayoutDistribution(
                        proto_def::GetPayoutDistributionIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::Initialize(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Initialize(
                        proto_def::InitializeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::PlaceBetInternal(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::PlaceBetInternal(
                        proto_def::PlaceBetInternalIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::SettleGameInternal(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SettleGameInternal(
                        proto_def::SettleGameInternalIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::ValidateBet(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ValidateBet(
                        proto_def::ValidateBetIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                FlipProgramIx::ValidateCancellation(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ValidateCancellation(
                        proto_def::ValidateCancellationIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
