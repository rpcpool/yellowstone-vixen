//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated::types::SwapEvent,
    instructions::{
        Claim as ClaimIxAccounts, ClaimInstructionArgs as ClaimIxData,
        ClaimToken as ClaimTokenIxAccounts, ClaimTokenInstructionArgs as ClaimTokenIxData,
        CloseToken as CloseTokenIxAccounts, CloseTokenInstructionArgs as CloseTokenIxData,
        CreateOpenOrders as CreateOpenOrdersIxAccounts,
        CreateProgramOpenOrders as CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersInstructionArgs as CreateProgramOpenOrdersIxData,
        CreateTokenAccount as CreateTokenAccountIxAccounts,
        CreateTokenAccountInstructionArgs as CreateTokenAccountIxData,
        CreateTokenLedger as CreateTokenLedgerIxAccounts, ExactOutRoute as ExactOutRouteIxAccounts,
        ExactOutRouteInstructionArgs as ExactOutRouteIxData, Route as RouteIxAccounts,
        RouteInstructionArgs as RouteIxData,
        RouteWithTokenLedger as RouteWithTokenLedgerIxAccounts,
        RouteWithTokenLedgerInstructionArgs as RouteWithTokenLedgerIxData,
        SetTokenLedger as SetTokenLedgerIxAccounts,
        SharedAccountsExactOutRoute as SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteInstructionArgs as SharedAccountsExactOutRouteIxData,
        SharedAccountsRoute as SharedAccountsRouteIxAccounts,
        SharedAccountsRouteInstructionArgs as SharedAccountsRouteIxData,
        SharedAccountsRouteWithTokenLedger as SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerInstructionArgs as SharedAccountsRouteWithTokenLedgerIxData,
    },
    ID,
};

/// Jupiter Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum JupiterProgramIx {
    Claim(ClaimIxAccounts, ClaimIxData),
    ClaimToken(ClaimTokenIxAccounts, ClaimTokenIxData),
    CloseToken(CloseTokenIxAccounts, CloseTokenIxData),
    CreateOpenOrders(CreateOpenOrdersIxAccounts),
    CreateProgramOpenOrders(
        CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersIxData,
    ),
    CreateTokenLedger(CreateTokenLedgerIxAccounts),
    CreateTokenAccount(CreateTokenAccountIxAccounts, CreateTokenAccountIxData),
    ExactOutRoute(ExactOutRouteIxAccounts, ExactOutRouteIxData),
    Route(RouteIxAccounts, RouteIxData, Vec<SwapEvent>),
    RouteWithTokenLedger(RouteWithTokenLedgerIxAccounts, RouteWithTokenLedgerIxData),
    SetTokenLedger(SetTokenLedgerIxAccounts),
    SharedAccountsExactOutRoute(
        SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteIxData,
    ),
    SharedAccountsRoute(
        SharedAccountsRouteIxAccounts,
        SharedAccountsRouteIxData,
        Vec<SwapEvent>,
    ),
    SharedAccountsRouteWithTokenLedger(
        SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerIxData,
    ),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = JupiterProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<JupiterProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> { "Jupiter::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);

        if ix.data.len() < 8 {
            return Err(yellowstone_vixen_core::ParseError::from(
                "Instruction data too short".to_owned(),
            ));
        }

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimIxAccounts {
                    wallet: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: ClaimIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::Claim(ix_accounts, de_ix_data))
            },
            [116, 206, 27, 191, 166, 19, 0, 73] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimTokenIxAccounts {
                    payer: next_account(accounts)?,
                    wallet: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    program_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: ClaimTokenIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::ClaimToken(ix_accounts, de_ix_data))
            },
            [26, 74, 236, 151, 104, 64, 183, 249] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CloseTokenIxAccounts {
                    operator: next_account(accounts)?,
                    wallet: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    program_token_account: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CloseTokenIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::CloseToken(ix_accounts, de_ix_data))
            },
            [229, 194, 212, 172, 8, 10, 134, 147] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateOpenOrdersIxAccounts {
                    open_orders: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    dex_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    market: next_account(accounts)?,
                };
                Ok(JupiterProgramIx::CreateOpenOrders(ix_accounts))
            },
            [28, 226, 32, 148, 188, 136, 113, 171] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateProgramOpenOrdersIxAccounts {
                    open_orders: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    dex_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    market: next_account(accounts)?,
                };
                let de_ix_data: CreateProgramOpenOrdersIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::CreateProgramOpenOrders(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [232, 242, 197, 253, 240, 143, 129, 52] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenLedgerIxAccounts {
                    token_ledger: next_account(accounts)?,
                    payer: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(JupiterProgramIx::CreateTokenLedger(ix_accounts))
            },
            [147, 241, 123, 100, 244, 132, 174, 118] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenAccountIxAccounts {
                    token_account: next_account(accounts)?,
                    user: next_account(accounts)?,
                    mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenAccountIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::CreateTokenAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [208, 51, 239, 151, 123, 43, 237, 92] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ExactOutRouteIxAccounts {
                    token_program: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    user_source_token_account: next_account(accounts)?,
                    user_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_program_id_optional_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    token2022_program: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: ExactOutRouteIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::ExactOutRoute(ix_accounts, de_ix_data))
            },
            [229, 23, 203, 151, 122, 227, 173, 42] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RouteIxAccounts {
                    token_program: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    user_source_token_account: next_account(accounts)?,
                    user_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_program_id_optional_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: RouteIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                // Search for all SwapEvents in inner instructions
                let swap_events: Vec<SwapEvent> = ix
                    .inner
                    .iter()
                    .filter_map(|inner_ix| SwapEvent::from_inner_instruction_data(&inner_ix.data))
                    .collect();

                Ok(JupiterProgramIx::Route(
                    ix_accounts,
                    de_ix_data,
                    swap_events,
                ))
            },
            [150, 86, 71, 116, 167, 93, 14, 104] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = RouteWithTokenLedgerIxAccounts {
                    token_program: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    user_source_token_account: next_account(accounts)?,
                    user_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_program_id_optional_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    token_ledger: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: RouteWithTokenLedgerIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::RouteWithTokenLedger(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [228, 85, 185, 112, 78, 79, 77, 2] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SetTokenLedgerIxAccounts {
                    token_ledger: next_account(accounts)?,
                    token_account: next_account(accounts)?,
                };
                Ok(JupiterProgramIx::SetTokenLedger(ix_accounts))
            },
            [176, 209, 105, 168, 154, 125, 69, 62] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SharedAccountsExactOutRouteIxAccounts {
                    token_program: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    program_source_token_account: next_account(accounts)?,
                    program_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    token2022_program: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: SharedAccountsExactOutRouteIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::SharedAccountsExactOutRoute(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [193, 32, 155, 51, 65, 214, 156, 129] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SharedAccountsRouteIxAccounts {
                    token_program: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    program_source_token_account: next_account(accounts)?,
                    program_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    token2022_program: next_program_id_optional_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: SharedAccountsRouteIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                // Search for all SwapEvents in inner instructions
                let swap_events: Vec<SwapEvent> = ix
                    .inner
                    .iter()
                    .filter_map(|inner_ix| SwapEvent::from_inner_instruction_data(&inner_ix.data))
                    .collect();

                Ok(JupiterProgramIx::SharedAccountsRoute(
                    ix_accounts,
                    de_ix_data,
                    swap_events,
                ))
            },
            [230, 121, 143, 80, 119, 159, 106, 170] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SharedAccountsRouteWithTokenLedgerIxAccounts {
                    token_program: next_account(accounts)?,
                    program_authority: next_account(accounts)?,
                    user_transfer_authority: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    program_source_token_account: next_account(accounts)?,
                    program_destination_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    token2022_program: next_program_id_optional_account(accounts)?,
                    token_ledger: next_account(accounts)?,
                    event_authority: next_account(accounts)?,
                    program: next_account(accounts)?,
                };
                let de_ix_data: SharedAccountsRouteWithTokenLedgerIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(JupiterProgramIx::SharedAccountsRouteWithTokenLedger(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{ClaimIxAccounts, InstructionParser, JupiterProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimIxAccounts> for ClaimIxAccounts {
        fn into_proto(self) -> proto_def::ClaimIxAccounts {
            proto_def::ClaimIxAccounts {
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ClaimIxData;
    impl IntoProto<proto_def::ClaimIxData> for ClaimIxData {
        fn into_proto(self) -> proto_def::ClaimIxData {
            proto_def::ClaimIxData { id: self.id.into() }
        }
    }
    use super::ClaimTokenIxAccounts;
    impl IntoProto<proto_def::ClaimTokenIxAccounts> for ClaimTokenIxAccounts {
        fn into_proto(self) -> proto_def::ClaimTokenIxAccounts {
            proto_def::ClaimTokenIxAccounts {
                payer: self.payer.to_string(),
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                program_token_account: self.program_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ClaimTokenIxData;
    impl IntoProto<proto_def::ClaimTokenIxData> for ClaimTokenIxData {
        fn into_proto(self) -> proto_def::ClaimTokenIxData {
            proto_def::ClaimTokenIxData { id: self.id.into() }
        }
    }
    use super::CloseTokenIxAccounts;
    impl IntoProto<proto_def::CloseTokenIxAccounts> for CloseTokenIxAccounts {
        fn into_proto(self) -> proto_def::CloseTokenIxAccounts {
            proto_def::CloseTokenIxAccounts {
                operator: self.operator.to_string(),
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                program_token_account: self.program_token_account.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CloseTokenIxData;
    impl IntoProto<proto_def::CloseTokenIxData> for CloseTokenIxData {
        fn into_proto(self) -> proto_def::CloseTokenIxData {
            proto_def::CloseTokenIxData {
                id: self.id.into(),
                burn_all: self.burn_all,
            }
        }
    }
    use super::CreateOpenOrdersIxAccounts;
    impl IntoProto<proto_def::CreateOpenOrdersIxAccounts> for CreateOpenOrdersIxAccounts {
        fn into_proto(self) -> proto_def::CreateOpenOrdersIxAccounts {
            proto_def::CreateOpenOrdersIxAccounts {
                open_orders: self.open_orders.to_string(),
                payer: self.payer.to_string(),
                dex_program: self.dex_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
                market: self.market.to_string(),
            }
        }
    }
    use super::CreateProgramOpenOrdersIxAccounts;
    impl IntoProto<proto_def::CreateProgramOpenOrdersIxAccounts> for CreateProgramOpenOrdersIxAccounts {
        fn into_proto(self) -> proto_def::CreateProgramOpenOrdersIxAccounts {
            proto_def::CreateProgramOpenOrdersIxAccounts {
                open_orders: self.open_orders.to_string(),
                payer: self.payer.to_string(),
                program_authority: self.program_authority.to_string(),
                dex_program: self.dex_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
                market: self.market.to_string(),
            }
        }
    }
    use super::CreateProgramOpenOrdersIxData;
    impl IntoProto<proto_def::CreateProgramOpenOrdersIxData> for CreateProgramOpenOrdersIxData {
        fn into_proto(self) -> proto_def::CreateProgramOpenOrdersIxData {
            proto_def::CreateProgramOpenOrdersIxData { id: self.id.into() }
        }
    }
    use super::CreateTokenLedgerIxAccounts;
    impl IntoProto<proto_def::CreateTokenLedgerIxAccounts> for CreateTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenLedgerIxAccounts {
            proto_def::CreateTokenLedgerIxAccounts {
                token_ledger: self.token_ledger.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountIxAccounts> for CreateTokenAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxAccounts {
            proto_def::CreateTokenAccountIxAccounts {
                token_account: self.token_account.to_string(),
                user: self.user.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxData;
    impl IntoProto<proto_def::CreateTokenAccountIxData> for CreateTokenAccountIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxData {
            proto_def::CreateTokenAccountIxData {
                bump: self.bump.into(),
            }
        }
    }
    use super::ExactOutRouteIxAccounts;
    impl IntoProto<proto_def::ExactOutRouteIxAccounts> for ExactOutRouteIxAccounts {
        fn into_proto(self) -> proto_def::ExactOutRouteIxAccounts {
            proto_def::ExactOutRouteIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ExactOutRouteIxData;
    impl IntoProto<proto_def::ExactOutRouteIxData> for ExactOutRouteIxData {
        fn into_proto(self) -> proto_def::ExactOutRouteIxData {
            proto_def::ExactOutRouteIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                out_amount: self.out_amount,
                quoted_in_amount: self.quoted_in_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::RouteIxAccounts;
    impl IntoProto<proto_def::RouteIxAccounts> for RouteIxAccounts {
        fn into_proto(self) -> proto_def::RouteIxAccounts {
            proto_def::RouteIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RouteIxData;
    impl IntoProto<proto_def::RouteIxData> for RouteIxData {
        fn into_proto(self) -> proto_def::RouteIxData {
            proto_def::RouteIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                in_amount: self.in_amount,
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::RouteWithTokenLedgerIxAccounts;
    impl IntoProto<proto_def::RouteWithTokenLedgerIxAccounts> for RouteWithTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::RouteWithTokenLedgerIxAccounts {
            proto_def::RouteWithTokenLedgerIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token_ledger: self.token_ledger.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RouteWithTokenLedgerIxData;
    impl IntoProto<proto_def::RouteWithTokenLedgerIxData> for RouteWithTokenLedgerIxData {
        fn into_proto(self) -> proto_def::RouteWithTokenLedgerIxData {
            proto_def::RouteWithTokenLedgerIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SetTokenLedgerIxAccounts;
    impl IntoProto<proto_def::SetTokenLedgerIxAccounts> for SetTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::SetTokenLedgerIxAccounts {
            proto_def::SetTokenLedgerIxAccounts {
                token_ledger: self.token_ledger.to_string(),
                token_account: self.token_account.to_string(),
            }
        }
    }
    use super::SharedAccountsExactOutRouteIxAccounts;
    impl IntoProto<proto_def::SharedAccountsExactOutRouteIxAccounts>
        for SharedAccountsExactOutRouteIxAccounts
    {
        fn into_proto(self) -> proto_def::SharedAccountsExactOutRouteIxAccounts {
            proto_def::SharedAccountsExactOutRouteIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsExactOutRouteIxData;
    impl IntoProto<proto_def::SharedAccountsExactOutRouteIxData> for SharedAccountsExactOutRouteIxData {
        fn into_proto(self) -> proto_def::SharedAccountsExactOutRouteIxData {
            proto_def::SharedAccountsExactOutRouteIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                out_amount: self.out_amount,
                quoted_in_amount: self.quoted_in_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SharedAccountsRouteIxAccounts;
    impl IntoProto<proto_def::SharedAccountsRouteIxAccounts> for SharedAccountsRouteIxAccounts {
        fn into_proto(self) -> proto_def::SharedAccountsRouteIxAccounts {
            proto_def::SharedAccountsRouteIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsRouteIxData;
    impl IntoProto<proto_def::SharedAccountsRouteIxData> for SharedAccountsRouteIxData {
        fn into_proto(self) -> proto_def::SharedAccountsRouteIxData {
            proto_def::SharedAccountsRouteIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                in_amount: self.in_amount,
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SharedAccountsRouteWithTokenLedgerIxAccounts;
    impl IntoProto<proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts>
        for SharedAccountsRouteWithTokenLedgerIxAccounts
    {
        fn into_proto(self) -> proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts {
            proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                token_ledger: self.token_ledger.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsRouteWithTokenLedgerIxData;
    impl IntoProto<proto_def::SharedAccountsRouteWithTokenLedgerIxData>
        for SharedAccountsRouteWithTokenLedgerIxData
    {
        fn into_proto(self) -> proto_def::SharedAccountsRouteWithTokenLedgerIxData {
            proto_def::SharedAccountsRouteWithTokenLedgerIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for JupiterProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                JupiterProgramIx::Claim(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Claim(proto_def::ClaimIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                JupiterProgramIx::ClaimToken(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimToken(
                        proto_def::ClaimTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CloseToken(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseToken(
                        proto_def::CloseTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateOpenOrders(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateOpenOrders(
                        proto_def::CreateOpenOrdersIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateProgramOpenOrders(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateProgramOpenOrders(
                        proto_def::CreateProgramOpenOrdersIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateTokenLedger(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenLedger(
                        proto_def::CreateTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateTokenAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenAccount(
                        proto_def::CreateTokenAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::ExactOutRoute(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ExactOutRoute(
                        proto_def::ExactOutRouteIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::Route(acc, data, _swap_events) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Route(proto_def::RouteIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                JupiterProgramIx::RouteWithTokenLedger(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RouteWithTokenLedger(
                        proto_def::RouteWithTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::SetTokenLedger(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SetTokenLedger(
                        proto_def::SetTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::SharedAccountsExactOutRoute(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(
                        proto_def::program_ixs::IxOneof::SharedAccountsExactOutRoute(
                            proto_def::SharedAccountsExactOutRouteIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        ),
                    ),
                },
                JupiterProgramIx::SharedAccountsRoute(acc, data, _swap_events) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::SharedAccountsRoute(
                            proto_def::SharedAccountsRouteIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                JupiterProgramIx::SharedAccountsRouteWithTokenLedger(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::SharedAccountsRouteWithTokenLedger(
                                proto_def::SharedAccountsRouteWithTokenLedgerIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
