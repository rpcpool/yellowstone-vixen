//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        Claim as ClaimIxAccounts, ClaimInstructionArgs as ClaimIxData,
        ClaimToken as ClaimTokenIxAccounts, ClaimTokenInstructionArgs as ClaimTokenIxData,
        CloseToken as CloseTokenIxAccounts, CloseTokenInstructionArgs as CloseTokenIxData,
        CreateOpenOrders as CreateOpenOrdersIxAccounts,
        CreateProgramOpenOrders as CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersInstructionArgs as CreateProgramOpenOrdersIxData,
        CreateTokenAccount as CreateTokenAccountIxAccounts,
        CreateTokenAccountInstructionArgs as CreateTokenAccountIxData,
        CreateTokenLedger as CreateTokenLedgerIxAccounts, ExactOutRoute as ExactOutRouteIxAccounts,
        ExactOutRouteInstructionArgs as ExactOutRouteIxData, Route as RouteIxAccounts,
        RouteInstructionArgs as RouteIxData,
        RouteWithTokenLedger as RouteWithTokenLedgerIxAccounts,
        RouteWithTokenLedgerInstructionArgs as RouteWithTokenLedgerIxData,
        SetTokenLedger as SetTokenLedgerIxAccounts,
        SharedAccountsExactOutRoute as SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteInstructionArgs as SharedAccountsExactOutRouteIxData,
        SharedAccountsRoute as SharedAccountsRouteIxAccounts,
        SharedAccountsRouteInstructionArgs as SharedAccountsRouteIxData,
        SharedAccountsRouteWithTokenLedger as SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerInstructionArgs as SharedAccountsRouteWithTokenLedgerIxData,
    },
    ID,
};

/// Jupiter Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum JupiterProgramIx {
    Claim(ClaimIxAccounts, ClaimIxData),
    ClaimToken(ClaimTokenIxAccounts, ClaimTokenIxData),
    CloseToken(CloseTokenIxAccounts, CloseTokenIxData),
    CreateOpenOrders(CreateOpenOrdersIxAccounts),
    CreateProgramOpenOrders(
        CreateProgramOpenOrdersIxAccounts,
        CreateProgramOpenOrdersIxData,
    ),
    CreateTokenLedger(CreateTokenLedgerIxAccounts),
    CreateTokenAccount(CreateTokenAccountIxAccounts, CreateTokenAccountIxData),
    ExactOutRoute(ExactOutRouteIxAccounts, ExactOutRouteIxData),
    Route(RouteIxAccounts, RouteIxData),
    RouteWithTokenLedger(RouteWithTokenLedgerIxAccounts, RouteWithTokenLedgerIxData),
    SetTokenLedger(SetTokenLedgerIxAccounts),
    SharedAccountsExactOutRoute(
        SharedAccountsExactOutRouteIxAccounts,
        SharedAccountsExactOutRouteIxData,
    ),
    SharedAccountsRoute(SharedAccountsRouteIxAccounts, SharedAccountsRouteIxData),
    SharedAccountsRouteWithTokenLedger(
        SharedAccountsRouteWithTokenLedgerIxAccounts,
        SharedAccountsRouteWithTokenLedgerIxData,
    ),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = JupiterProgramIx;

    fn id(&self) -> std::borrow::Cow<str> { "Jupiter::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<JupiterProgramIx> {
        let accounts_len = ix.accounts.len();

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = ClaimIxAccounts {
                    wallet: ix.accounts[0].0.into(),
                    program_authority: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: ClaimIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::Claim(ix_accounts, de_ix_data))
            },
            [116, 206, 27, 191, 166, 19, 0, 73] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = ClaimTokenIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    wallet: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    program_token_account: ix.accounts[3].0.into(),
                    destination_token_account: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                    token_program: ix.accounts[6].0.into(),
                    associated_token_program: ix.accounts[7].0.into(),
                    system_program: ix.accounts[8].0.into(),
                };
                let de_ix_data: ClaimTokenIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::ClaimToken(ix_accounts, de_ix_data))
            },
            [26, 74, 236, 151, 104, 64, 183, 249] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CloseTokenIxAccounts {
                    operator: ix.accounts[0].0.into(),
                    wallet: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    program_token_account: ix.accounts[3].0.into(),
                    mint: ix.accounts[4].0.into(),
                    token_program: ix.accounts[5].0.into(),
                };
                let de_ix_data: CloseTokenIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CloseToken(ix_accounts, de_ix_data))
            },
            [229, 194, 212, 172, 8, 10, 134, 147] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = CreateOpenOrdersIxAccounts {
                    open_orders: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    dex_program: ix.accounts[2].0.into(),
                    system_program: ix.accounts[3].0.into(),
                    rent: ix.accounts[4].0.into(),
                    market: ix.accounts[5].0.into(),
                };
                Ok(JupiterProgramIx::CreateOpenOrders(ix_accounts))
            },
            [28, 226, 32, 148, 188, 136, 113, 171] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = CreateProgramOpenOrdersIxAccounts {
                    open_orders: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    program_authority: ix.accounts[2].0.into(),
                    dex_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                    rent: ix.accounts[5].0.into(),
                    market: ix.accounts[6].0.into(),
                };
                let de_ix_data: CreateProgramOpenOrdersIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CreateProgramOpenOrders(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [232, 242, 197, 253, 240, 143, 129, 52] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = CreateTokenLedgerIxAccounts {
                    token_ledger: ix.accounts[0].0.into(),
                    payer: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                Ok(JupiterProgramIx::CreateTokenLedger(ix_accounts))
            },
            [147, 241, 123, 100, 244, 132, 174, 118] => {
                check_min_accounts_req(accounts_len, 5)?;
                let ix_accounts = CreateTokenAccountIxAccounts {
                    token_account: ix.accounts[0].0.into(),
                    user: ix.accounts[1].0.into(),
                    mint: ix.accounts[2].0.into(),
                    token_program: ix.accounts[3].0.into(),
                    system_program: ix.accounts[4].0.into(),
                };
                let de_ix_data: CreateTokenAccountIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::CreateTokenAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [208, 51, 239, 151, 123, 43, 237, 92] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = ExactOutRouteIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    user_transfer_authority: ix.accounts[1].0.into(),
                    user_source_token_account: ix.accounts[2].0.into(),
                    user_destination_token_account: ix.accounts[3].0.into(),
                    destination_token_account: if ix.accounts[4]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[4].0.into())
                    },
                    source_mint: ix.accounts[5].0.into(),
                    destination_mint: ix.accounts[6].0.into(),
                    platform_fee_account: if ix.accounts[7]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[7].0.into())
                    },
                    token2022_program: if ix.accounts[8]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[8].0.into())
                    },
                    event_authority: ix.accounts[9].0.into(),
                    program: ix.accounts[10].0.into(),
                };
                let de_ix_data: ExactOutRouteIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::ExactOutRoute(ix_accounts, de_ix_data))
            },
            [229, 23, 203, 151, 122, 227, 173, 42] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = RouteIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    user_transfer_authority: ix.accounts[1].0.into(),
                    user_source_token_account: ix.accounts[2].0.into(),
                    user_destination_token_account: ix.accounts[3].0.into(),
                    destination_token_account: if ix.accounts[4]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[4].0.into())
                    },
                    destination_mint: ix.accounts[5].0.into(),
                    platform_fee_account: if ix.accounts[6]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[6].0.into())
                    },
                    event_authority: ix.accounts[7].0.into(),
                    program: ix.accounts[8].0.into(),
                };
                let de_ix_data: RouteIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::Route(ix_accounts, de_ix_data))
            },
            [150, 86, 71, 116, 167, 93, 14, 104] => {
                check_min_accounts_req(accounts_len, 10)?;
                let ix_accounts = RouteWithTokenLedgerIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    user_transfer_authority: ix.accounts[1].0.into(),
                    user_source_token_account: ix.accounts[2].0.into(),
                    user_destination_token_account: ix.accounts[3].0.into(),
                    destination_token_account: if ix.accounts[4]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[4].0.into())
                    },
                    destination_mint: ix.accounts[5].0.into(),
                    platform_fee_account: if ix.accounts[6]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[6].0.into())
                    },
                    token_ledger: ix.accounts[7].0.into(),
                    event_authority: ix.accounts[8].0.into(),
                    program: ix.accounts[9].0.into(),
                };
                let de_ix_data: RouteWithTokenLedgerIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::RouteWithTokenLedger(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [228, 85, 185, 112, 78, 79, 77, 2] => {
                check_min_accounts_req(accounts_len, 2)?;
                let ix_accounts = SetTokenLedgerIxAccounts {
                    token_ledger: ix.accounts[0].0.into(),
                    token_account: ix.accounts[1].0.into(),
                };
                Ok(JupiterProgramIx::SetTokenLedger(ix_accounts))
            },
            [176, 209, 105, 168, 154, 125, 69, 62] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SharedAccountsExactOutRouteIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    program_authority: ix.accounts[1].0.into(),
                    user_transfer_authority: ix.accounts[2].0.into(),
                    source_token_account: ix.accounts[3].0.into(),
                    program_source_token_account: ix.accounts[4].0.into(),
                    program_destination_token_account: ix.accounts[5].0.into(),
                    destination_token_account: ix.accounts[6].0.into(),
                    source_mint: ix.accounts[7].0.into(),
                    destination_mint: ix.accounts[8].0.into(),
                    platform_fee_account: if ix.accounts[9]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[9].0.into())
                    },
                    token2022_program: if ix.accounts[10]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[10].0.into())
                    },
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                let de_ix_data: SharedAccountsExactOutRouteIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::SharedAccountsExactOutRoute(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [193, 32, 155, 51, 65, 214, 156, 129] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = SharedAccountsRouteIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    program_authority: ix.accounts[1].0.into(),
                    user_transfer_authority: ix.accounts[2].0.into(),
                    source_token_account: ix.accounts[3].0.into(),
                    program_source_token_account: ix.accounts[4].0.into(),
                    program_destination_token_account: ix.accounts[5].0.into(),
                    destination_token_account: ix.accounts[6].0.into(),
                    source_mint: ix.accounts[7].0.into(),
                    destination_mint: ix.accounts[8].0.into(),
                    platform_fee_account: if ix.accounts[9]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[9].0.into())
                    },
                    token2022_program: if ix.accounts[10]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[10].0.into())
                    },
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                let de_ix_data: SharedAccountsRouteIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::SharedAccountsRoute(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [230, 121, 143, 80, 119, 159, 106, 170] => {
                check_min_accounts_req(accounts_len, 14)?;
                let ix_accounts = SharedAccountsRouteWithTokenLedgerIxAccounts {
                    token_program: ix.accounts[0].0.into(),
                    program_authority: ix.accounts[1].0.into(),
                    user_transfer_authority: ix.accounts[2].0.into(),
                    source_token_account: ix.accounts[3].0.into(),
                    program_source_token_account: ix.accounts[4].0.into(),
                    program_destination_token_account: ix.accounts[5].0.into(),
                    destination_token_account: ix.accounts[6].0.into(),
                    source_mint: ix.accounts[7].0.into(),
                    destination_mint: ix.accounts[8].0.into(),
                    platform_fee_account: if ix.accounts[9]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[9].0.into())
                    },
                    token2022_program: if ix.accounts[10]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[10].0.into())
                    },
                    token_ledger: ix.accounts[11].0.into(),
                    event_authority: ix.accounts[12].0.into(),
                    program: ix.accounts[13].0.into(),
                };
                let de_ix_data: SharedAccountsRouteWithTokenLedgerIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(JupiterProgramIx::SharedAccountsRouteWithTokenLedger(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        ix
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{ClaimIxAccounts, InstructionParser, JupiterProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimIxAccounts> for ClaimIxAccounts {
        fn into_proto(self) -> proto_def::ClaimIxAccounts {
            proto_def::ClaimIxAccounts {
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ClaimIxData;
    impl IntoProto<proto_def::ClaimIxData> for ClaimIxData {
        fn into_proto(self) -> proto_def::ClaimIxData {
            proto_def::ClaimIxData { id: self.id.into() }
        }
    }
    use super::ClaimTokenIxAccounts;
    impl IntoProto<proto_def::ClaimTokenIxAccounts> for ClaimTokenIxAccounts {
        fn into_proto(self) -> proto_def::ClaimTokenIxAccounts {
            proto_def::ClaimTokenIxAccounts {
                payer: self.payer.to_string(),
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                program_token_account: self.program_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::ClaimTokenIxData;
    impl IntoProto<proto_def::ClaimTokenIxData> for ClaimTokenIxData {
        fn into_proto(self) -> proto_def::ClaimTokenIxData {
            proto_def::ClaimTokenIxData { id: self.id.into() }
        }
    }
    use super::CloseTokenIxAccounts;
    impl IntoProto<proto_def::CloseTokenIxAccounts> for CloseTokenIxAccounts {
        fn into_proto(self) -> proto_def::CloseTokenIxAccounts {
            proto_def::CloseTokenIxAccounts {
                operator: self.operator.to_string(),
                wallet: self.wallet.to_string(),
                program_authority: self.program_authority.to_string(),
                program_token_account: self.program_token_account.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CloseTokenIxData;
    impl IntoProto<proto_def::CloseTokenIxData> for CloseTokenIxData {
        fn into_proto(self) -> proto_def::CloseTokenIxData {
            proto_def::CloseTokenIxData {
                id: self.id.into(),
                burn_all: self.burn_all,
            }
        }
    }
    use super::CreateOpenOrdersIxAccounts;
    impl IntoProto<proto_def::CreateOpenOrdersIxAccounts> for CreateOpenOrdersIxAccounts {
        fn into_proto(self) -> proto_def::CreateOpenOrdersIxAccounts {
            proto_def::CreateOpenOrdersIxAccounts {
                open_orders: self.open_orders.to_string(),
                payer: self.payer.to_string(),
                dex_program: self.dex_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
                market: self.market.to_string(),
            }
        }
    }
    use super::CreateProgramOpenOrdersIxAccounts;
    impl IntoProto<proto_def::CreateProgramOpenOrdersIxAccounts> for CreateProgramOpenOrdersIxAccounts {
        fn into_proto(self) -> proto_def::CreateProgramOpenOrdersIxAccounts {
            proto_def::CreateProgramOpenOrdersIxAccounts {
                open_orders: self.open_orders.to_string(),
                payer: self.payer.to_string(),
                program_authority: self.program_authority.to_string(),
                dex_program: self.dex_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
                market: self.market.to_string(),
            }
        }
    }
    use super::CreateProgramOpenOrdersIxData;
    impl IntoProto<proto_def::CreateProgramOpenOrdersIxData> for CreateProgramOpenOrdersIxData {
        fn into_proto(self) -> proto_def::CreateProgramOpenOrdersIxData {
            proto_def::CreateProgramOpenOrdersIxData { id: self.id.into() }
        }
    }
    use super::CreateTokenLedgerIxAccounts;
    impl IntoProto<proto_def::CreateTokenLedgerIxAccounts> for CreateTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenLedgerIxAccounts {
            proto_def::CreateTokenLedgerIxAccounts {
                token_ledger: self.token_ledger.to_string(),
                payer: self.payer.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountIxAccounts> for CreateTokenAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxAccounts {
            proto_def::CreateTokenAccountIxAccounts {
                token_account: self.token_account.to_string(),
                user: self.user.to_string(),
                mint: self.mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxData;
    impl IntoProto<proto_def::CreateTokenAccountIxData> for CreateTokenAccountIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxData {
            proto_def::CreateTokenAccountIxData {
                bump: self.bump.into(),
            }
        }
    }
    use super::ExactOutRouteIxAccounts;
    impl IntoProto<proto_def::ExactOutRouteIxAccounts> for ExactOutRouteIxAccounts {
        fn into_proto(self) -> proto_def::ExactOutRouteIxAccounts {
            proto_def::ExactOutRouteIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::ExactOutRouteIxData;
    impl IntoProto<proto_def::ExactOutRouteIxData> for ExactOutRouteIxData {
        fn into_proto(self) -> proto_def::ExactOutRouteIxData {
            proto_def::ExactOutRouteIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                out_amount: self.out_amount,
                quoted_in_amount: self.quoted_in_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::RouteIxAccounts;
    impl IntoProto<proto_def::RouteIxAccounts> for RouteIxAccounts {
        fn into_proto(self) -> proto_def::RouteIxAccounts {
            proto_def::RouteIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RouteIxData;
    impl IntoProto<proto_def::RouteIxData> for RouteIxData {
        fn into_proto(self) -> proto_def::RouteIxData {
            proto_def::RouteIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                in_amount: self.in_amount,
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::RouteWithTokenLedgerIxAccounts;
    impl IntoProto<proto_def::RouteWithTokenLedgerIxAccounts> for RouteWithTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::RouteWithTokenLedgerIxAccounts {
            proto_def::RouteWithTokenLedgerIxAccounts {
                token_program: self.token_program.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                user_source_token_account: self.user_source_token_account.to_string(),
                user_destination_token_account: self.user_destination_token_account.to_string(),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token_ledger: self.token_ledger.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::RouteWithTokenLedgerIxData;
    impl IntoProto<proto_def::RouteWithTokenLedgerIxData> for RouteWithTokenLedgerIxData {
        fn into_proto(self) -> proto_def::RouteWithTokenLedgerIxData {
            proto_def::RouteWithTokenLedgerIxData {
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SetTokenLedgerIxAccounts;
    impl IntoProto<proto_def::SetTokenLedgerIxAccounts> for SetTokenLedgerIxAccounts {
        fn into_proto(self) -> proto_def::SetTokenLedgerIxAccounts {
            proto_def::SetTokenLedgerIxAccounts {
                token_ledger: self.token_ledger.to_string(),
                token_account: self.token_account.to_string(),
            }
        }
    }
    use super::SharedAccountsExactOutRouteIxAccounts;
    impl IntoProto<proto_def::SharedAccountsExactOutRouteIxAccounts>
        for SharedAccountsExactOutRouteIxAccounts
    {
        fn into_proto(self) -> proto_def::SharedAccountsExactOutRouteIxAccounts {
            proto_def::SharedAccountsExactOutRouteIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsExactOutRouteIxData;
    impl IntoProto<proto_def::SharedAccountsExactOutRouteIxData> for SharedAccountsExactOutRouteIxData {
        fn into_proto(self) -> proto_def::SharedAccountsExactOutRouteIxData {
            proto_def::SharedAccountsExactOutRouteIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                out_amount: self.out_amount,
                quoted_in_amount: self.quoted_in_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SharedAccountsRouteIxAccounts;
    impl IntoProto<proto_def::SharedAccountsRouteIxAccounts> for SharedAccountsRouteIxAccounts {
        fn into_proto(self) -> proto_def::SharedAccountsRouteIxAccounts {
            proto_def::SharedAccountsRouteIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsRouteIxData;
    impl IntoProto<proto_def::SharedAccountsRouteIxData> for SharedAccountsRouteIxData {
        fn into_proto(self) -> proto_def::SharedAccountsRouteIxData {
            proto_def::SharedAccountsRouteIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                in_amount: self.in_amount,
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }
    use super::SharedAccountsRouteWithTokenLedgerIxAccounts;
    impl IntoProto<proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts>
        for SharedAccountsRouteWithTokenLedgerIxAccounts
    {
        fn into_proto(self) -> proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts {
            proto_def::SharedAccountsRouteWithTokenLedgerIxAccounts {
                token_program: self.token_program.to_string(),
                program_authority: self.program_authority.to_string(),
                user_transfer_authority: self.user_transfer_authority.to_string(),
                source_token_account: self.source_token_account.to_string(),
                program_source_token_account: self.program_source_token_account.to_string(),
                program_destination_token_account: self
                    .program_destination_token_account
                    .to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                token2022_program: self.token2022_program.map(|p| p.to_string()),
                token_ledger: self.token_ledger.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::SharedAccountsRouteWithTokenLedgerIxData;
    impl IntoProto<proto_def::SharedAccountsRouteWithTokenLedgerIxData>
        for SharedAccountsRouteWithTokenLedgerIxData
    {
        fn into_proto(self) -> proto_def::SharedAccountsRouteWithTokenLedgerIxData {
            proto_def::SharedAccountsRouteWithTokenLedgerIxData {
                id: self.id.into(),
                route_plan: self
                    .route_plan
                    .into_iter()
                    .map(|x| x.into_proto())
                    .collect(),
                quoted_out_amount: self.quoted_out_amount,
                slippage_bps: self.slippage_bps.into(),
                platform_fee_bps: self.platform_fee_bps.into(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for JupiterProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                JupiterProgramIx::Claim(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Claim(proto_def::ClaimIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                JupiterProgramIx::ClaimToken(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClaimToken(
                        proto_def::ClaimTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CloseToken(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CloseToken(
                        proto_def::CloseTokenIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateOpenOrders(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateOpenOrders(
                        proto_def::CreateOpenOrdersIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateProgramOpenOrders(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateProgramOpenOrders(
                        proto_def::CreateProgramOpenOrdersIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateTokenLedger(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenLedger(
                        proto_def::CreateTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::CreateTokenAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenAccount(
                        proto_def::CreateTokenAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::ExactOutRoute(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ExactOutRoute(
                        proto_def::ExactOutRouteIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::Route(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Route(proto_def::RouteIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                JupiterProgramIx::RouteWithTokenLedger(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::RouteWithTokenLedger(
                        proto_def::RouteWithTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::SetTokenLedger(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SetTokenLedger(
                        proto_def::SetTokenLedgerIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::SharedAccountsExactOutRoute(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(
                        proto_def::program_ixs::IxOneof::SharedAccountsExactOutRoute(
                            proto_def::SharedAccountsExactOutRouteIx {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        ),
                    ),
                },
                JupiterProgramIx::SharedAccountsRoute(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SharedAccountsRoute(
                        proto_def::SharedAccountsRouteIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                JupiterProgramIx::SharedAccountsRouteWithTokenLedger(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::SharedAccountsRouteWithTokenLedger(
                                proto_def::SharedAccountsRouteWithTokenLedgerIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
