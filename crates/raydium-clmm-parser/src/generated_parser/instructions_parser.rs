//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    instructions::{
        ClosePosition as ClosePositionIxAccounts, CollectFundFee as CollectFundFeeIxAccounts,
        CollectFundFeeInstructionArgs as CollectFundFeeIxData,
        CollectProtocolFee as CollectProtocolFeeIxAccounts,
        CollectProtocolFeeInstructionArgs as CollectProtocolFeeIxData,
        CollectRemainingRewards as CollectRemainingRewardsIxAccounts,
        CollectRemainingRewardsInstructionArgs as CollectRemainingRewardsIxData,
        CreateAmmConfig as CreateAmmConfigIxAccounts,
        CreateAmmConfigInstructionArgs as CreateAmmConfigIxData,
        CreateOperationAccount as CreateOperationAccountIxAccounts,
        CreatePool as CreatePoolIxAccounts, CreatePoolInstructionArgs as CreatePoolIxData,
        DecreaseLiquidity as DecreaseLiquidityIxAccounts,
        DecreaseLiquidityInstructionArgs as DecreaseLiquidityIxData,
        DecreaseLiquidityV2 as DecreaseLiquidityV2IxAccounts,
        DecreaseLiquidityV2InstructionArgs as DecreaseLiquidityV2IxData,
        IncreaseLiquidity as IncreaseLiquidityIxAccounts,
        IncreaseLiquidityInstructionArgs as IncreaseLiquidityIxData,
        IncreaseLiquidityV2 as IncreaseLiquidityV2IxAccounts,
        IncreaseLiquidityV2InstructionArgs as IncreaseLiquidityV2IxData,
        InitializeReward as InitializeRewardIxAccounts,
        InitializeRewardInstructionArgs as InitializeRewardIxData,
        OpenPosition as OpenPositionIxAccounts, OpenPositionInstructionArgs as OpenPositionIxData,
        OpenPositionV2 as OpenPositionV2IxAccounts,
        OpenPositionV2InstructionArgs as OpenPositionV2IxData,
        OpenPositionWithToken22Nft as OpenPositionWithToken22NftIxAccounts,
        OpenPositionWithToken22NftInstructionArgs as OpenPositionWithToken22NftIxData,
        SetRewardParams as SetRewardParamsIxAccounts,
        SetRewardParamsInstructionArgs as SetRewardParamsIxData, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData, SwapRouterBaseIn as SwapRouterBaseInIxAccounts,
        SwapRouterBaseInInstructionArgs as SwapRouterBaseInIxData, SwapV2 as SwapV2IxAccounts,
        SwapV2InstructionArgs as SwapV2IxData,
        TransferRewardOwner as TransferRewardOwnerIxAccounts,
        TransferRewardOwnerInstructionArgs as TransferRewardOwnerIxData,
        UpdateAmmConfig as UpdateAmmConfigIxAccounts,
        UpdateAmmConfigInstructionArgs as UpdateAmmConfigIxData,
        UpdateOperationAccount as UpdateOperationAccountIxAccounts,
        UpdateOperationAccountInstructionArgs as UpdateOperationAccountIxData,
        UpdatePoolStatus as UpdatePoolStatusIxAccounts,
        UpdatePoolStatusInstructionArgs as UpdatePoolStatusIxData,
        UpdateRewardInfos as UpdateRewardInfosIxAccounts,
    },
    ID,
};

/// AmmV3 Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum AmmV3ProgramIx {
    CreateAmmConfig(CreateAmmConfigIxAccounts, CreateAmmConfigIxData),
    UpdateAmmConfig(UpdateAmmConfigIxAccounts, UpdateAmmConfigIxData),
    CreatePool(CreatePoolIxAccounts, CreatePoolIxData),
    UpdatePoolStatus(UpdatePoolStatusIxAccounts, UpdatePoolStatusIxData),
    CreateOperationAccount(CreateOperationAccountIxAccounts),
    UpdateOperationAccount(
        UpdateOperationAccountIxAccounts,
        UpdateOperationAccountIxData,
    ),
    TransferRewardOwner(TransferRewardOwnerIxAccounts, TransferRewardOwnerIxData),
    InitializeReward(InitializeRewardIxAccounts, InitializeRewardIxData),
    CollectRemainingRewards(
        CollectRemainingRewardsIxAccounts,
        CollectRemainingRewardsIxData,
    ),
    UpdateRewardInfos(UpdateRewardInfosIxAccounts),
    SetRewardParams(SetRewardParamsIxAccounts, SetRewardParamsIxData),
    CollectProtocolFee(CollectProtocolFeeIxAccounts, CollectProtocolFeeIxData),
    CollectFundFee(CollectFundFeeIxAccounts, CollectFundFeeIxData),
    OpenPosition(OpenPositionIxAccounts, OpenPositionIxData),
    OpenPositionV2(OpenPositionV2IxAccounts, OpenPositionV2IxData),
    OpenPositionWithToken22Nft(
        OpenPositionWithToken22NftIxAccounts,
        OpenPositionWithToken22NftIxData,
    ),
    ClosePosition(ClosePositionIxAccounts),
    IncreaseLiquidity(IncreaseLiquidityIxAccounts, IncreaseLiquidityIxData),
    IncreaseLiquidityV2(IncreaseLiquidityV2IxAccounts, IncreaseLiquidityV2IxData),
    DecreaseLiquidity(DecreaseLiquidityIxAccounts, DecreaseLiquidityIxData),
    DecreaseLiquidityV2(DecreaseLiquidityV2IxAccounts, DecreaseLiquidityV2IxData),
    Swap(SwapIxAccounts, SwapIxData),
    SwapV2(SwapV2IxAccounts, SwapV2IxData),
    SwapRouterBaseIn(SwapRouterBaseInIxAccounts, SwapRouterBaseInIxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = AmmV3ProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<AmmV3ProgramIx>;

    fn id(&self) -> std::borrow::Cow<str> { "AmmV3::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [137, 52, 237, 212, 215, 117, 108, 104] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CreateAmmConfig(ix_accounts, de_ix_data))
            },
            [49, 60, 174, 136, 154, 28, 116, 200] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                };
                let de_ix_data: UpdateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdateAmmConfig(ix_accounts, de_ix_data))
            },
            [233, 146, 209, 142, 207, 104, 64, 188] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatePoolIxAccounts {
                    pool_creator: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token_mint0: next_account(accounts)?,
                    token_mint1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    tick_array_bitmap: next_account(accounts)?,
                    token_program0: next_account(accounts)?,
                    token_program1: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: CreatePoolIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CreatePool(ix_accounts, de_ix_data))
            },
            [130, 87, 108, 6, 46, 224, 117, 123] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdatePoolStatusIxAccounts {
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                };
                let de_ix_data: UpdatePoolStatusIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdatePoolStatus(ix_accounts, de_ix_data))
            },
            [63, 87, 148, 33, 109, 35, 8, 104] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateOperationAccountIxAccounts {
                    owner: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::CreateOperationAccount(ix_accounts))
            },
            [127, 70, 119, 40, 188, 227, 61, 7] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateOperationAccountIxAccounts {
                    owner: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: UpdateOperationAccountIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdateOperationAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [7, 22, 12, 83, 242, 43, 48, 121] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TransferRewardOwnerIxAccounts {
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                };
                let de_ix_data: TransferRewardOwnerIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::TransferRewardOwner(ix_accounts, de_ix_data))
            },
            [95, 135, 192, 196, 242, 129, 230, 68] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeRewardIxAccounts {
                    reward_funder: next_account(accounts)?,
                    funder_token_account: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    reward_token_mint: next_account(accounts)?,
                    reward_token_vault: next_account(accounts)?,
                    reward_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: InitializeRewardIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::InitializeReward(ix_accounts, de_ix_data))
            },
            [18, 237, 166, 197, 34, 16, 213, 144] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectRemainingRewardsIxAccounts {
                    reward_funder: next_account(accounts)?,
                    funder_token_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    reward_token_vault: next_account(accounts)?,
                    reward_vault_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                let de_ix_data: CollectRemainingRewardsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectRemainingRewards(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [163, 172, 224, 52, 11, 154, 106, 223] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateRewardInfosIxAccounts {
                    pool_state: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::UpdateRewardInfos(ix_accounts))
            },
            [112, 52, 167, 75, 32, 201, 211, 137] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SetRewardParamsIxAccounts {
                    authority: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: SetRewardParamsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::SetRewardParams(ix_accounts, de_ix_data))
            },
            [136, 136, 252, 221, 194, 66, 126, 89] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectProtocolFeeIxAccounts {
                    owner: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectProtocolFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectProtocolFee(ix_accounts, de_ix_data))
            },
            [167, 138, 78, 149, 223, 194, 6, 126] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectFundFeeIxAccounts {
                    owner: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectFundFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectFundFee(ix_accounts, de_ix_data))
            },
            [135, 128, 47, 77, 15, 152, 240, 49] => {
                let expected_accounts_len = 19;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionIxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    metadata_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPosition(ix_accounts, de_ix_data))
            },
            [77, 184, 74, 214, 112, 86, 241, 199] => {
                let expected_accounts_len = 22;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionV2IxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    metadata_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPositionV2(ix_accounts, de_ix_data))
            },
            [77, 255, 174, 82, 125, 29, 201, 46] => {
                let expected_accounts_len = 20;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionWithToken22NftIxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionWithToken22NftIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPositionWithToken22Nft(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [123, 134, 81, 0, 49, 68, 98, 98] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClosePositionIxAccounts {
                    nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::ClosePosition(ix_accounts))
            },
            [46, 156, 243, 118, 13, 205, 251, 178] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = IncreaseLiquidityIxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: IncreaseLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::IncreaseLiquidity(ix_accounts, de_ix_data))
            },
            [133, 29, 89, 223, 69, 238, 176, 10] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = IncreaseLiquidityV2IxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: IncreaseLiquidityV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::IncreaseLiquidityV2(ix_accounts, de_ix_data))
            },
            [160, 38, 208, 111, 104, 91, 44, 1] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DecreaseLiquidityIxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: DecreaseLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::DecreaseLiquidity(ix_accounts, de_ix_data))
            },
            [58, 127, 188, 62, 79, 82, 196, 96] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DecreaseLiquidityV2IxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: DecreaseLiquidityV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::DecreaseLiquidityV2(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    payer: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    tick_array: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::Swap(ix_accounts, de_ix_data))
            },
            [43, 4, 237, 11, 26, 201, 30, 98] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                    input_vault_mint: next_account(accounts)?,
                    output_vault_mint: next_account(accounts)?,
                };
                let de_ix_data: SwapV2IxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::SwapV2(ix_accounts, de_ix_data))
            },
            [69, 125, 115, 218, 245, 186, 242, 196] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapRouterBaseInIxAccounts {
                    payer: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                let de_ix_data: SwapRouterBaseInIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::SwapRouterBaseIn(ix_accounts, de_ix_data))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AmmV3ProgramIx, CreateAmmConfigIxAccounts, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::CreateAmmConfigIxAccounts> for CreateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxAccounts {
            proto_def::CreateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateAmmConfigIxData;
    impl IntoProto<proto_def::CreateAmmConfigIxData> for CreateAmmConfigIxData {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxData {
            proto_def::CreateAmmConfigIxData {
                index: self.index.into(),
                tick_spacing: self.tick_spacing.into(),
                trade_fee_rate: self.trade_fee_rate,
                protocol_fee_rate: self.protocol_fee_rate,
                fund_fee_rate: self.fund_fee_rate,
            }
        }
    }
    use super::UpdateAmmConfigIxAccounts;
    impl IntoProto<proto_def::UpdateAmmConfigIxAccounts> for UpdateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxAccounts {
            proto_def::UpdateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
            }
        }
    }
    use super::UpdateAmmConfigIxData;
    impl IntoProto<proto_def::UpdateAmmConfigIxData> for UpdateAmmConfigIxData {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxData {
            proto_def::UpdateAmmConfigIxData {
                param: self.param.into(),
                value: self.value,
            }
        }
    }
    use super::CreatePoolIxAccounts;
    impl IntoProto<proto_def::CreatePoolIxAccounts> for CreatePoolIxAccounts {
        fn into_proto(self) -> proto_def::CreatePoolIxAccounts {
            proto_def::CreatePoolIxAccounts {
                pool_creator: self.pool_creator.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                token_mint0: self.token_mint0.to_string(),
                token_mint1: self.token_mint1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                observation_state: self.observation_state.to_string(),
                tick_array_bitmap: self.tick_array_bitmap.to_string(),
                token_program0: self.token_program0.to_string(),
                token_program1: self.token_program1.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::CreatePoolIxData;
    impl IntoProto<proto_def::CreatePoolIxData> for CreatePoolIxData {
        fn into_proto(self) -> proto_def::CreatePoolIxData {
            proto_def::CreatePoolIxData {
                sqrt_price_x64: self.sqrt_price_x64.to_string(),
                open_time: self.open_time,
            }
        }
    }
    use super::UpdatePoolStatusIxAccounts;
    impl IntoProto<proto_def::UpdatePoolStatusIxAccounts> for UpdatePoolStatusIxAccounts {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxAccounts {
            proto_def::UpdatePoolStatusIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::UpdatePoolStatusIxData;
    impl IntoProto<proto_def::UpdatePoolStatusIxData> for UpdatePoolStatusIxData {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxData {
            proto_def::UpdatePoolStatusIxData {
                status: self.status.into(),
            }
        }
    }
    use super::CreateOperationAccountIxAccounts;
    impl IntoProto<proto_def::CreateOperationAccountIxAccounts> for CreateOperationAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateOperationAccountIxAccounts {
            proto_def::CreateOperationAccountIxAccounts {
                owner: self.owner.to_string(),
                operation_state: self.operation_state.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateOperationAccountIxAccounts;
    impl IntoProto<proto_def::UpdateOperationAccountIxAccounts> for UpdateOperationAccountIxAccounts {
        fn into_proto(self) -> proto_def::UpdateOperationAccountIxAccounts {
            proto_def::UpdateOperationAccountIxAccounts {
                owner: self.owner.to_string(),
                operation_state: self.operation_state.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateOperationAccountIxData;
    impl IntoProto<proto_def::UpdateOperationAccountIxData> for UpdateOperationAccountIxData {
        fn into_proto(self) -> proto_def::UpdateOperationAccountIxData {
            proto_def::UpdateOperationAccountIxData {
                param: self.param.into(),
                keys: self.keys.into_iter().map(|x| x.to_string()).collect(),
            }
        }
    }
    use super::TransferRewardOwnerIxAccounts;
    impl IntoProto<proto_def::TransferRewardOwnerIxAccounts> for TransferRewardOwnerIxAccounts {
        fn into_proto(self) -> proto_def::TransferRewardOwnerIxAccounts {
            proto_def::TransferRewardOwnerIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::TransferRewardOwnerIxData;
    impl IntoProto<proto_def::TransferRewardOwnerIxData> for TransferRewardOwnerIxData {
        fn into_proto(self) -> proto_def::TransferRewardOwnerIxData {
            proto_def::TransferRewardOwnerIxData {
                new_owner: self.new_owner.to_string(),
            }
        }
    }
    use super::InitializeRewardIxAccounts;
    impl IntoProto<proto_def::InitializeRewardIxAccounts> for InitializeRewardIxAccounts {
        fn into_proto(self) -> proto_def::InitializeRewardIxAccounts {
            proto_def::InitializeRewardIxAccounts {
                reward_funder: self.reward_funder.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                operation_state: self.operation_state.to_string(),
                reward_token_mint: self.reward_token_mint.to_string(),
                reward_token_vault: self.reward_token_vault.to_string(),
                reward_token_program: self.reward_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::InitializeRewardIxData;
    impl IntoProto<proto_def::InitializeRewardIxData> for InitializeRewardIxData {
        fn into_proto(self) -> proto_def::InitializeRewardIxData {
            proto_def::InitializeRewardIxData {
                open_time: self.open_time,
                end_time: self.end_time,
                emissions_per_second_x64: self.emissions_per_second_x64.to_string(),
            }
        }
    }
    use super::CollectRemainingRewardsIxAccounts;
    impl IntoProto<proto_def::CollectRemainingRewardsIxAccounts> for CollectRemainingRewardsIxAccounts {
        fn into_proto(self) -> proto_def::CollectRemainingRewardsIxAccounts {
            proto_def::CollectRemainingRewardsIxAccounts {
                reward_funder: self.reward_funder.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                pool_state: self.pool_state.to_string(),
                reward_token_vault: self.reward_token_vault.to_string(),
                reward_vault_mint: self.reward_vault_mint.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::CollectRemainingRewardsIxData;
    impl IntoProto<proto_def::CollectRemainingRewardsIxData> for CollectRemainingRewardsIxData {
        fn into_proto(self) -> proto_def::CollectRemainingRewardsIxData {
            proto_def::CollectRemainingRewardsIxData {
                reward_index: self.reward_index.into(),
            }
        }
    }
    use super::UpdateRewardInfosIxAccounts;
    impl IntoProto<proto_def::UpdateRewardInfosIxAccounts> for UpdateRewardInfosIxAccounts {
        fn into_proto(self) -> proto_def::UpdateRewardInfosIxAccounts {
            proto_def::UpdateRewardInfosIxAccounts {
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::SetRewardParamsIxAccounts;
    impl IntoProto<proto_def::SetRewardParamsIxAccounts> for SetRewardParamsIxAccounts {
        fn into_proto(self) -> proto_def::SetRewardParamsIxAccounts {
            proto_def::SetRewardParamsIxAccounts {
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                operation_state: self.operation_state.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::SetRewardParamsIxData;
    impl IntoProto<proto_def::SetRewardParamsIxData> for SetRewardParamsIxData {
        fn into_proto(self) -> proto_def::SetRewardParamsIxData {
            proto_def::SetRewardParamsIxData {
                reward_index: self.reward_index.into(),
                emissions_per_second_x64: self.emissions_per_second_x64.to_string(),
                open_time: self.open_time,
                end_time: self.end_time,
            }
        }
    }
    use super::CollectProtocolFeeIxAccounts;
    impl IntoProto<proto_def::CollectProtocolFeeIxAccounts> for CollectProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxAccounts {
            proto_def::CollectProtocolFeeIxAccounts {
                owner: self.owner.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectProtocolFeeIxData;
    impl IntoProto<proto_def::CollectProtocolFeeIxData> for CollectProtocolFeeIxData {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxData {
            proto_def::CollectProtocolFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CollectFundFeeIxAccounts;
    impl IntoProto<proto_def::CollectFundFeeIxAccounts> for CollectFundFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectFundFeeIxAccounts {
            proto_def::CollectFundFeeIxAccounts {
                owner: self.owner.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxData;
    impl IntoProto<proto_def::CollectFundFeeIxData> for CollectFundFeeIxData {
        fn into_proto(self) -> proto_def::CollectFundFeeIxData {
            proto_def::CollectFundFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::OpenPositionIxAccounts;
    impl IntoProto<proto_def::OpenPositionIxAccounts> for OpenPositionIxAccounts {
        fn into_proto(self) -> proto_def::OpenPositionIxAccounts {
            proto_def::OpenPositionIxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                metadata_account: self.metadata_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                metadata_program: self.metadata_program.to_string(),
            }
        }
    }
    use super::OpenPositionIxData;
    impl IntoProto<proto_def::OpenPositionIxData> for OpenPositionIxData {
        fn into_proto(self) -> proto_def::OpenPositionIxData {
            proto_def::OpenPositionIxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
            }
        }
    }
    use super::OpenPositionV2IxAccounts;
    impl IntoProto<proto_def::OpenPositionV2IxAccounts> for OpenPositionV2IxAccounts {
        fn into_proto(self) -> proto_def::OpenPositionV2IxAccounts {
            proto_def::OpenPositionV2IxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                metadata_account: self.metadata_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                metadata_program: self.metadata_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::OpenPositionV2IxData;
    impl IntoProto<proto_def::OpenPositionV2IxData> for OpenPositionV2IxData {
        fn into_proto(self) -> proto_def::OpenPositionV2IxData {
            proto_def::OpenPositionV2IxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                with_metadata: self.with_metadata,
                base_flag: self.base_flag,
            }
        }
    }
    use super::OpenPositionWithToken22NftIxAccounts;
    impl IntoProto<proto_def::OpenPositionWithToken22NftIxAccounts>
        for OpenPositionWithToken22NftIxAccounts
    {
        fn into_proto(self) -> proto_def::OpenPositionWithToken22NftIxAccounts {
            proto_def::OpenPositionWithToken22NftIxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::OpenPositionWithToken22NftIxData;
    impl IntoProto<proto_def::OpenPositionWithToken22NftIxData> for OpenPositionWithToken22NftIxData {
        fn into_proto(self) -> proto_def::OpenPositionWithToken22NftIxData {
            proto_def::OpenPositionWithToken22NftIxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                with_metadata: self.with_metadata,
                base_flag: self.base_flag,
            }
        }
    }
    use super::ClosePositionIxAccounts;
    impl IntoProto<proto_def::ClosePositionIxAccounts> for ClosePositionIxAccounts {
        fn into_proto(self) -> proto_def::ClosePositionIxAccounts {
            proto_def::ClosePositionIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::IncreaseLiquidityIxAccounts;
    impl IntoProto<proto_def::IncreaseLiquidityIxAccounts> for IncreaseLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::IncreaseLiquidityIxAccounts {
            proto_def::IncreaseLiquidityIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                personal_position: self.personal_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::IncreaseLiquidityIxData;
    impl IntoProto<proto_def::IncreaseLiquidityIxData> for IncreaseLiquidityIxData {
        fn into_proto(self) -> proto_def::IncreaseLiquidityIxData {
            proto_def::IncreaseLiquidityIxData {
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
            }
        }
    }
    use super::IncreaseLiquidityV2IxAccounts;
    impl IntoProto<proto_def::IncreaseLiquidityV2IxAccounts> for IncreaseLiquidityV2IxAccounts {
        fn into_proto(self) -> proto_def::IncreaseLiquidityV2IxAccounts {
            proto_def::IncreaseLiquidityV2IxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                personal_position: self.personal_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::IncreaseLiquidityV2IxData;
    impl IntoProto<proto_def::IncreaseLiquidityV2IxData> for IncreaseLiquidityV2IxData {
        fn into_proto(self) -> proto_def::IncreaseLiquidityV2IxData {
            proto_def::IncreaseLiquidityV2IxData {
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                base_flag: self.base_flag,
            }
        }
    }
    use super::DecreaseLiquidityIxAccounts;
    impl IntoProto<proto_def::DecreaseLiquidityIxAccounts> for DecreaseLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::DecreaseLiquidityIxAccounts {
            proto_def::DecreaseLiquidityIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::DecreaseLiquidityIxData;
    impl IntoProto<proto_def::DecreaseLiquidityIxData> for DecreaseLiquidityIxData {
        fn into_proto(self) -> proto_def::DecreaseLiquidityIxData {
            proto_def::DecreaseLiquidityIxData {
                liquidity: self.liquidity.to_string(),
                amount0_min: self.amount0_min,
                amount1_min: self.amount1_min,
            }
        }
    }
    use super::DecreaseLiquidityV2IxAccounts;
    impl IntoProto<proto_def::DecreaseLiquidityV2IxAccounts> for DecreaseLiquidityV2IxAccounts {
        fn into_proto(self) -> proto_def::DecreaseLiquidityV2IxAccounts {
            proto_def::DecreaseLiquidityV2IxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::DecreaseLiquidityV2IxData;
    impl IntoProto<proto_def::DecreaseLiquidityV2IxData> for DecreaseLiquidityV2IxData {
        fn into_proto(self) -> proto_def::DecreaseLiquidityV2IxData {
            proto_def::DecreaseLiquidityV2IxData {
                liquidity: self.liquidity.to_string(),
                amount0_min: self.amount0_min,
                amount1_min: self.amount1_min,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                payer: self.payer.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                tick_array: self.tick_array.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                amount: self.amount,
                other_amount_threshold: self.other_amount_threshold,
                sqrt_price_limit_x64: self.sqrt_price_limit_x64.to_string(),
                is_base_input: self.is_base_input,
            }
        }
    }
    use super::SwapV2IxAccounts;
    impl IntoProto<proto_def::SwapV2IxAccounts> for SwapV2IxAccounts {
        fn into_proto(self) -> proto_def::SwapV2IxAccounts {
            proto_def::SwapV2IxAccounts {
                payer: self.payer.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
                input_vault_mint: self.input_vault_mint.to_string(),
                output_vault_mint: self.output_vault_mint.to_string(),
            }
        }
    }
    use super::SwapV2IxData;
    impl IntoProto<proto_def::SwapV2IxData> for SwapV2IxData {
        fn into_proto(self) -> proto_def::SwapV2IxData {
            proto_def::SwapV2IxData {
                amount: self.amount,
                other_amount_threshold: self.other_amount_threshold,
                sqrt_price_limit_x64: self.sqrt_price_limit_x64.to_string(),
                is_base_input: self.is_base_input,
            }
        }
    }
    use super::SwapRouterBaseInIxAccounts;
    impl IntoProto<proto_def::SwapRouterBaseInIxAccounts> for SwapRouterBaseInIxAccounts {
        fn into_proto(self) -> proto_def::SwapRouterBaseInIxAccounts {
            proto_def::SwapRouterBaseInIxAccounts {
                payer: self.payer.to_string(),
                input_token_account: self.input_token_account.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::SwapRouterBaseInIxData;
    impl IntoProto<proto_def::SwapRouterBaseInIxData> for SwapRouterBaseInIxData {
        fn into_proto(self) -> proto_def::SwapRouterBaseInIxData {
            proto_def::SwapRouterBaseInIxData {
                amount_in: self.amount_in,
                amount_out_minimum: self.amount_out_minimum,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for AmmV3ProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                AmmV3ProgramIx::CreateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateAmmConfig(
                        proto_def::CreateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAmmConfig(
                        proto_def::UpdateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreatePool(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatePool(
                        proto_def::CreatePoolIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdatePoolStatus(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdatePoolStatus(
                        proto_def::UpdatePoolStatusIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreateOperationAccount(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateOperationAccount(
                        proto_def::CreateOperationAccountIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateOperationAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateOperationAccount(
                        proto_def::UpdateOperationAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::TransferRewardOwner(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TransferRewardOwner(
                        proto_def::TransferRewardOwnerIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::InitializeReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeReward(
                        proto_def::InitializeRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectRemainingRewards(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectRemainingRewards(
                        proto_def::CollectRemainingRewardsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateRewardInfos(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateRewardInfos(
                        proto_def::UpdateRewardInfosIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::SetRewardParams(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SetRewardParams(
                        proto_def::SetRewardParamsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectProtocolFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectProtocolFee(
                        proto_def::CollectProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectFundFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectFundFee(
                        proto_def::CollectFundFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPosition(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPosition(
                        proto_def::OpenPositionIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPositionV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPositionV2(
                        proto_def::OpenPositionV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPositionWithToken22Nft(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPositionWithToken22Nft(
                        proto_def::OpenPositionWithToken22NftIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::ClosePosition(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClosePosition(
                        proto_def::ClosePositionIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::IncreaseLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::IncreaseLiquidity(
                        proto_def::IncreaseLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::IncreaseLiquidityV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::IncreaseLiquidityV2(
                        proto_def::IncreaseLiquidityV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::DecreaseLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DecreaseLiquidity(
                        proto_def::DecreaseLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::DecreaseLiquidityV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DecreaseLiquidityV2(
                        proto_def::DecreaseLiquidityV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::Swap(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                AmmV3ProgramIx::SwapV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapV2(
                        proto_def::SwapV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::SwapRouterBaseIn(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapRouterBaseIn(
                        proto_def::SwapRouterBaseInIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
