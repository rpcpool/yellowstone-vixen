//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

use yellowstone_vixen_core::constants::is_known_aggregator;
#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    instructions::{
        ClosePosition as ClosePositionIxAccounts, CollectFundFee as CollectFundFeeIxAccounts,
        CollectFundFeeInstructionArgs as CollectFundFeeIxData,
        CollectProtocolFee as CollectProtocolFeeIxAccounts,
        CollectProtocolFeeInstructionArgs as CollectProtocolFeeIxData,
        CollectRemainingRewards as CollectRemainingRewardsIxAccounts,
        CollectRemainingRewardsInstructionArgs as CollectRemainingRewardsIxData,
        CreateAmmConfig as CreateAmmConfigIxAccounts,
        CreateAmmConfigInstructionArgs as CreateAmmConfigIxData,
        CreateOperationAccount as CreateOperationAccountIxAccounts,
        CreatePermissionlessFarmSwitch as CreatePermissionlessFarmSwitchIxAccounts,
        CreatePool as CreatePoolIxAccounts, CreatePoolInstructionArgs as CreatePoolIxData,
        CreateSupportMintAssociated as CreateSupportMintAssociatedIxAccounts,
        DecreaseLiquidity as DecreaseLiquidityIxAccounts,
        DecreaseLiquidityInstructionArgs as DecreaseLiquidityIxData,
        DecreaseLiquidityV2 as DecreaseLiquidityV2IxAccounts,
        DecreaseLiquidityV2InstructionArgs as DecreaseLiquidityV2IxData,
        IncreaseLiquidity as IncreaseLiquidityIxAccounts,
        IncreaseLiquidityInstructionArgs as IncreaseLiquidityIxData,
        IncreaseLiquidityV2 as IncreaseLiquidityV2IxAccounts,
        IncreaseLiquidityV2InstructionArgs as IncreaseLiquidityV2IxData,
        InitializeReward as InitializeRewardIxAccounts,
        InitializeRewardInstructionArgs as InitializeRewardIxData,
        OpenPosition as OpenPositionIxAccounts, OpenPositionInstructionArgs as OpenPositionIxData,
        OpenPositionV2 as OpenPositionV2IxAccounts,
        OpenPositionV2InstructionArgs as OpenPositionV2IxData,
        OpenPositionWithToken22Nft as OpenPositionWithToken22NftIxAccounts,
        OpenPositionWithToken22NftInstructionArgs as OpenPositionWithToken22NftIxData,
        SetRewardParams as SetRewardParamsIxAccounts,
        SetRewardParamsInstructionArgs as SetRewardParamsIxData, Swap as SwapIxAccounts,
        SwapInstructionArgs as SwapIxData, SwapRouterBaseIn as SwapRouterBaseInIxAccounts,
        SwapRouterBaseInInstructionArgs as SwapRouterBaseInIxData, SwapV2 as SwapV2IxAccounts,
        SwapV2InstructionArgs as SwapV2IxData,
        TogglePermissionlessFarmSwitch as TogglePermissionlessFarmSwitchIxAccounts,
        TogglePermissionlessFarmSwitchInstructionArgs as TogglePermissionlessFarmSwitchIxData,
        TransferRewardOwner as TransferRewardOwnerIxAccounts,
        TransferRewardOwnerInstructionArgs as TransferRewardOwnerIxData,
        UpdateAmmConfig as UpdateAmmConfigIxAccounts,
        UpdateAmmConfigInstructionArgs as UpdateAmmConfigIxData,
        UpdateOperationAccount as UpdateOperationAccountIxAccounts,
        UpdateOperationAccountInstructionArgs as UpdateOperationAccountIxData,
        UpdatePoolStatus as UpdatePoolStatusIxAccounts,
        UpdatePoolStatusInstructionArgs as UpdatePoolStatusIxData,
        UpdateRewardInfos as UpdateRewardInfosIxAccounts,
    },
    types::SwapEvent,
    ID,
};

/// AmmV3 Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum AmmV3ProgramIx {
    ClosePosition(ClosePositionIxAccounts),
    CollectFundFee(CollectFundFeeIxAccounts, CollectFundFeeIxData),
    CollectProtocolFee(CollectProtocolFeeIxAccounts, CollectProtocolFeeIxData),
    CollectRemainingRewards(
        CollectRemainingRewardsIxAccounts,
        CollectRemainingRewardsIxData,
    ),
    CreateAmmConfig(CreateAmmConfigIxAccounts, CreateAmmConfigIxData),
    CreateOperationAccount(CreateOperationAccountIxAccounts),
    CreatePermissionlessFarmSwitch(CreatePermissionlessFarmSwitchIxAccounts),
    CreatePool(CreatePoolIxAccounts, CreatePoolIxData),
    CreateSupportMintAssociated(CreateSupportMintAssociatedIxAccounts),
    DecreaseLiquidity(DecreaseLiquidityIxAccounts, DecreaseLiquidityIxData),
    DecreaseLiquidityV2(DecreaseLiquidityV2IxAccounts, DecreaseLiquidityV2IxData),
    IncreaseLiquidity(IncreaseLiquidityIxAccounts, IncreaseLiquidityIxData),
    IncreaseLiquidityV2(IncreaseLiquidityV2IxAccounts, IncreaseLiquidityV2IxData),
    InitializeReward(InitializeRewardIxAccounts, InitializeRewardIxData),
    OpenPosition(OpenPositionIxAccounts, OpenPositionIxData),
    OpenPositionV2(OpenPositionV2IxAccounts, OpenPositionV2IxData),
    OpenPositionWithToken22Nft(
        OpenPositionWithToken22NftIxAccounts,
        OpenPositionWithToken22NftIxData,
    ),
    SetRewardParams(SetRewardParamsIxAccounts, SetRewardParamsIxData),
    Swap(SwapIxAccounts, SwapIxData, Option<SwapEvent>),
    SwapRouterBaseIn(SwapRouterBaseInIxAccounts, SwapRouterBaseInIxData),
    SwapV2(SwapV2IxAccounts, SwapV2IxData, Option<SwapEvent>),
    TogglePermissionlessFarmSwitch(
        TogglePermissionlessFarmSwitchIxAccounts,
        TogglePermissionlessFarmSwitchIxData,
    ),
    TransferRewardOwner(TransferRewardOwnerIxAccounts, TransferRewardOwnerIxData),
    UpdateAmmConfig(UpdateAmmConfigIxAccounts, UpdateAmmConfigIxData),
    UpdateOperationAccount(
        UpdateOperationAccountIxAccounts,
        UpdateOperationAccountIxData,
    ),
    UpdatePoolStatus(UpdatePoolStatusIxAccounts, UpdatePoolStatusIxData),
    UpdateRewardInfos(UpdateRewardInfosIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = AmmV3ProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<AmmV3ProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> { "PancakeAmmV3::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [123, 134, 81, 0, 49, 68, 98, 98] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClosePositionIxAccounts {
                    nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::ClosePosition(ix_accounts))
            },
            [167, 138, 78, 149, 223, 194, 6, 126] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectFundFeeIxAccounts {
                    owner: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectFundFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectFundFee(ix_accounts, de_ix_data))
            },
            [136, 136, 252, 221, 194, 66, 126, 89] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectProtocolFeeIxAccounts {
                    owner: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: CollectProtocolFeeIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectProtocolFee(ix_accounts, de_ix_data))
            },
            [18, 237, 166, 197, 34, 16, 213, 144] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CollectRemainingRewardsIxAccounts {
                    reward_funder: next_account(accounts)?,
                    funder_token_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    reward_token_vault: next_account(accounts)?,
                    reward_vault_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                let de_ix_data: CollectRemainingRewardsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CollectRemainingRewards(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [137, 52, 237, 212, 215, 117, 108, 104] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CreateAmmConfig(ix_accounts, de_ix_data))
            },
            [63, 87, 148, 33, 109, 35, 8, 104] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateOperationAccountIxAccounts {
                    owner: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::CreateOperationAccount(ix_accounts))
            },
            [88, 242, 198, 70, 241, 6, 196, 251] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatePermissionlessFarmSwitchIxAccounts {
                    owner: next_account(accounts)?,
                    permissionless_farm_switch: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::CreatePermissionlessFarmSwitch(ix_accounts))
            },
            [233, 146, 209, 142, 207, 104, 64, 188] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreatePoolIxAccounts {
                    pool_creator: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    token_mint0: next_account(accounts)?,
                    token_mint1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    tick_array_bitmap: next_account(accounts)?,
                    token_program0: next_account(accounts)?,
                    token_program1: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: CreatePoolIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::CreatePool(ix_accounts, de_ix_data))
            },
            [17, 251, 65, 92, 136, 242, 14, 169] => {
                let expected_accounts_len = 4;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateSupportMintAssociatedIxAccounts {
                    owner: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    support_mint_associated: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::CreateSupportMintAssociated(ix_accounts))
            },
            [160, 38, 208, 111, 104, 91, 44, 1] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DecreaseLiquidityIxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: DecreaseLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::DecreaseLiquidity(ix_accounts, de_ix_data))
            },
            [58, 127, 188, 62, 79, 82, 196, 96] => {
                let expected_accounts_len = 16;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = DecreaseLiquidityV2IxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    recipient_token_account0: next_account(accounts)?,
                    recipient_token_account1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: DecreaseLiquidityV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::DecreaseLiquidityV2(ix_accounts, de_ix_data))
            },
            [46, 156, 243, 118, 13, 205, 251, 178] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = IncreaseLiquidityIxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: IncreaseLiquidityIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::IncreaseLiquidity(ix_accounts, de_ix_data))
            },
            [133, 29, 89, 223, 69, 238, 176, 10] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = IncreaseLiquidityV2IxAccounts {
                    nft_owner: next_account(accounts)?,
                    nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: IncreaseLiquidityV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::IncreaseLiquidityV2(ix_accounts, de_ix_data))
            },
            [95, 135, 192, 196, 242, 129, 230, 68] => {
                let expected_accounts_len = 11;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = InitializeRewardIxAccounts {
                    reward_funder: next_account(accounts)?,
                    funder_token_account: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    permissionless_farm_switch: next_account(accounts)?,
                    reward_token_mint: next_account(accounts)?,
                    reward_token_vault: next_account(accounts)?,
                    reward_token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    rent: next_account(accounts)?,
                };
                let de_ix_data: InitializeRewardIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::InitializeReward(ix_accounts, de_ix_data))
            },
            [135, 128, 47, 77, 15, 152, 240, 49] => {
                let expected_accounts_len = 19;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionIxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    metadata_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPosition(ix_accounts, de_ix_data))
            },
            [77, 184, 74, 214, 112, 86, 241, 199] => {
                let expected_accounts_len = 22;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionV2IxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    metadata_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    metadata_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPositionV2(ix_accounts, de_ix_data))
            },
            [77, 255, 174, 82, 125, 29, 201, 46] => {
                let expected_accounts_len = 20;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = OpenPositionWithToken22NftIxAccounts {
                    payer: next_account(accounts)?,
                    position_nft_owner: next_account(accounts)?,
                    position_nft_mint: next_account(accounts)?,
                    position_nft_account: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    protocol_position: next_account(accounts)?,
                    tick_array_lower: next_account(accounts)?,
                    tick_array_upper: next_account(accounts)?,
                    personal_position: next_account(accounts)?,
                    token_account0: next_account(accounts)?,
                    token_account1: next_account(accounts)?,
                    token_vault0: next_account(accounts)?,
                    token_vault1: next_account(accounts)?,
                    rent: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    associated_token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    vault0_mint: next_account(accounts)?,
                    vault1_mint: next_account(accounts)?,
                };
                let de_ix_data: OpenPositionWithToken22NftIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::OpenPositionWithToken22Nft(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [112, 52, 167, 75, 32, 201, 211, 137] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SetRewardParamsIxAccounts {
                    authority: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                };
                let de_ix_data: SetRewardParamsIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::SetRewardParams(ix_accounts, de_ix_data))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    payer: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    tick_array: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }
                let swap_event = SwapEvent::from_logs(&ix.parsed_logs);
                Ok(AmmV3ProgramIx::Swap(ix_accounts, de_ix_data, swap_event))
            },
            [69, 125, 115, 218, 245, 186, 242, 196] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapRouterBaseInIxAccounts {
                    payer: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    input_token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                };
                let de_ix_data: SwapRouterBaseInIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::SwapRouterBaseIn(ix_accounts, de_ix_data))
            },
            [43, 4, 237, 11, 26, 201, 30, 98] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                    input_token_account: next_account(accounts)?,
                    output_token_account: next_account(accounts)?,
                    input_vault: next_account(accounts)?,
                    output_vault: next_account(accounts)?,
                    observation_state: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    token_program2022: next_account(accounts)?,
                    memo_program: next_account(accounts)?,
                    input_vault_mint: next_account(accounts)?,
                    output_vault_mint: next_account(accounts)?,
                };
                let de_ix_data: SwapV2IxData = deserialize_checked(ix_data, &ix_discriminator)?;
                // Filter out trades handled by Jupiter or OKX aggregators
                if ix.parent_program.as_ref().is_some_and(is_known_aggregator) {
                    return Err(yellowstone_vixen_core::ParseError::Filtered);
                }
                let swap_event = SwapEvent::from_logs(&ix.parsed_logs);
                Ok(AmmV3ProgramIx::SwapV2(ix_accounts, de_ix_data, swap_event))
            },
            [150, 112, 54, 233, 238, 161, 7, 86] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TogglePermissionlessFarmSwitchIxAccounts {
                    owner: next_account(accounts)?,
                    permissionless_farm_switch: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: TogglePermissionlessFarmSwitchIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::TogglePermissionlessFarmSwitch(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [7, 22, 12, 83, 242, 43, 48, 121] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = TransferRewardOwnerIxAccounts {
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                };
                let de_ix_data: TransferRewardOwnerIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::TransferRewardOwner(ix_accounts, de_ix_data))
            },
            [49, 60, 174, 136, 154, 28, 116, 200] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateAmmConfigIxAccounts {
                    owner: next_account(accounts)?,
                    amm_config: next_account(accounts)?,
                };
                let de_ix_data: UpdateAmmConfigIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdateAmmConfig(ix_accounts, de_ix_data))
            },
            [127, 70, 119, 40, 188, 227, 61, 7] => {
                let expected_accounts_len = 3;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateOperationAccountIxAccounts {
                    owner: next_account(accounts)?,
                    operation_state: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: UpdateOperationAccountIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdateOperationAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [130, 87, 108, 6, 46, 224, 117, 123] => {
                let expected_accounts_len = 2;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdatePoolStatusIxAccounts {
                    authority: next_account(accounts)?,
                    pool_state: next_account(accounts)?,
                };
                let de_ix_data: UpdatePoolStatusIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(AmmV3ProgramIx::UpdatePoolStatus(ix_accounts, de_ix_data))
            },
            [163, 172, 224, 52, 11, 154, 106, 223] => {
                let expected_accounts_len = 1;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = UpdateRewardInfosIxAccounts {
                    pool_state: next_account(accounts)?,
                };
                Ok(AmmV3ProgramIx::UpdateRewardInfos(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{AmmV3ProgramIx, ClosePositionIxAccounts, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClosePositionIxAccounts> for ClosePositionIxAccounts {
        fn into_proto(self) -> proto_def::ClosePositionIxAccounts {
            proto_def::ClosePositionIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxAccounts;
    impl IntoProto<proto_def::CollectFundFeeIxAccounts> for CollectFundFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectFundFeeIxAccounts {
            proto_def::CollectFundFeeIxAccounts {
                owner: self.owner.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectFundFeeIxData;
    impl IntoProto<proto_def::CollectFundFeeIxData> for CollectFundFeeIxData {
        fn into_proto(self) -> proto_def::CollectFundFeeIxData {
            proto_def::CollectFundFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CollectProtocolFeeIxAccounts;
    impl IntoProto<proto_def::CollectProtocolFeeIxAccounts> for CollectProtocolFeeIxAccounts {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxAccounts {
            proto_def::CollectProtocolFeeIxAccounts {
                owner: self.owner.to_string(),
                pool_state: self.pool_state.to_string(),
                amm_config: self.amm_config.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::CollectProtocolFeeIxData;
    impl IntoProto<proto_def::CollectProtocolFeeIxData> for CollectProtocolFeeIxData {
        fn into_proto(self) -> proto_def::CollectProtocolFeeIxData {
            proto_def::CollectProtocolFeeIxData {
                amount0_requested: self.amount0_requested,
                amount1_requested: self.amount1_requested,
            }
        }
    }
    use super::CollectRemainingRewardsIxAccounts;
    impl IntoProto<proto_def::CollectRemainingRewardsIxAccounts> for CollectRemainingRewardsIxAccounts {
        fn into_proto(self) -> proto_def::CollectRemainingRewardsIxAccounts {
            proto_def::CollectRemainingRewardsIxAccounts {
                reward_funder: self.reward_funder.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                pool_state: self.pool_state.to_string(),
                reward_token_vault: self.reward_token_vault.to_string(),
                reward_vault_mint: self.reward_vault_mint.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::CollectRemainingRewardsIxData;
    impl IntoProto<proto_def::CollectRemainingRewardsIxData> for CollectRemainingRewardsIxData {
        fn into_proto(self) -> proto_def::CollectRemainingRewardsIxData {
            proto_def::CollectRemainingRewardsIxData {
                reward_index: self.reward_index.into(),
            }
        }
    }
    use super::CreateAmmConfigIxAccounts;
    impl IntoProto<proto_def::CreateAmmConfigIxAccounts> for CreateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxAccounts {
            proto_def::CreateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateAmmConfigIxData;
    impl IntoProto<proto_def::CreateAmmConfigIxData> for CreateAmmConfigIxData {
        fn into_proto(self) -> proto_def::CreateAmmConfigIxData {
            proto_def::CreateAmmConfigIxData {
                index: self.index.into(),
                tick_spacing: self.tick_spacing.into(),
                trade_fee_rate: self.trade_fee_rate,
                protocol_fee_rate: self.protocol_fee_rate,
                fund_fee_rate: self.fund_fee_rate,
            }
        }
    }
    use super::CreateOperationAccountIxAccounts;
    impl IntoProto<proto_def::CreateOperationAccountIxAccounts> for CreateOperationAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateOperationAccountIxAccounts {
            proto_def::CreateOperationAccountIxAccounts {
                owner: self.owner.to_string(),
                operation_state: self.operation_state.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreatePermissionlessFarmSwitchIxAccounts;
    impl IntoProto<proto_def::CreatePermissionlessFarmSwitchIxAccounts>
        for CreatePermissionlessFarmSwitchIxAccounts
    {
        fn into_proto(self) -> proto_def::CreatePermissionlessFarmSwitchIxAccounts {
            proto_def::CreatePermissionlessFarmSwitchIxAccounts {
                owner: self.owner.to_string(),
                permissionless_farm_switch: self.permissionless_farm_switch.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreatePoolIxAccounts;
    impl IntoProto<proto_def::CreatePoolIxAccounts> for CreatePoolIxAccounts {
        fn into_proto(self) -> proto_def::CreatePoolIxAccounts {
            proto_def::CreatePoolIxAccounts {
                pool_creator: self.pool_creator.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                token_mint0: self.token_mint0.to_string(),
                token_mint1: self.token_mint1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                observation_state: self.observation_state.to_string(),
                tick_array_bitmap: self.tick_array_bitmap.to_string(),
                token_program0: self.token_program0.to_string(),
                token_program1: self.token_program1.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::CreatePoolIxData;
    impl IntoProto<proto_def::CreatePoolIxData> for CreatePoolIxData {
        fn into_proto(self) -> proto_def::CreatePoolIxData {
            proto_def::CreatePoolIxData {
                sqrt_price_x64: self.sqrt_price_x64.to_string(),
                open_time: self.open_time,
            }
        }
    }
    use super::CreateSupportMintAssociatedIxAccounts;
    impl IntoProto<proto_def::CreateSupportMintAssociatedIxAccounts>
        for CreateSupportMintAssociatedIxAccounts
    {
        fn into_proto(self) -> proto_def::CreateSupportMintAssociatedIxAccounts {
            proto_def::CreateSupportMintAssociatedIxAccounts {
                owner: self.owner.to_string(),
                token_mint: self.token_mint.to_string(),
                support_mint_associated: self.support_mint_associated.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::DecreaseLiquidityIxAccounts;
    impl IntoProto<proto_def::DecreaseLiquidityIxAccounts> for DecreaseLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::DecreaseLiquidityIxAccounts {
            proto_def::DecreaseLiquidityIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::DecreaseLiquidityIxData;
    impl IntoProto<proto_def::DecreaseLiquidityIxData> for DecreaseLiquidityIxData {
        fn into_proto(self) -> proto_def::DecreaseLiquidityIxData {
            proto_def::DecreaseLiquidityIxData {
                liquidity: self.liquidity.to_string(),
                amount0_min: self.amount0_min,
                amount1_min: self.amount1_min,
            }
        }
    }
    use super::DecreaseLiquidityV2IxAccounts;
    impl IntoProto<proto_def::DecreaseLiquidityV2IxAccounts> for DecreaseLiquidityV2IxAccounts {
        fn into_proto(self) -> proto_def::DecreaseLiquidityV2IxAccounts {
            proto_def::DecreaseLiquidityV2IxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                personal_position: self.personal_position.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                recipient_token_account0: self.recipient_token_account0.to_string(),
                recipient_token_account1: self.recipient_token_account1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::DecreaseLiquidityV2IxData;
    impl IntoProto<proto_def::DecreaseLiquidityV2IxData> for DecreaseLiquidityV2IxData {
        fn into_proto(self) -> proto_def::DecreaseLiquidityV2IxData {
            proto_def::DecreaseLiquidityV2IxData {
                liquidity: self.liquidity.to_string(),
                amount0_min: self.amount0_min,
                amount1_min: self.amount1_min,
            }
        }
    }
    use super::IncreaseLiquidityIxAccounts;
    impl IntoProto<proto_def::IncreaseLiquidityIxAccounts> for IncreaseLiquidityIxAccounts {
        fn into_proto(self) -> proto_def::IncreaseLiquidityIxAccounts {
            proto_def::IncreaseLiquidityIxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                personal_position: self.personal_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::IncreaseLiquidityIxData;
    impl IntoProto<proto_def::IncreaseLiquidityIxData> for IncreaseLiquidityIxData {
        fn into_proto(self) -> proto_def::IncreaseLiquidityIxData {
            proto_def::IncreaseLiquidityIxData {
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
            }
        }
    }
    use super::IncreaseLiquidityV2IxAccounts;
    impl IntoProto<proto_def::IncreaseLiquidityV2IxAccounts> for IncreaseLiquidityV2IxAccounts {
        fn into_proto(self) -> proto_def::IncreaseLiquidityV2IxAccounts {
            proto_def::IncreaseLiquidityV2IxAccounts {
                nft_owner: self.nft_owner.to_string(),
                nft_account: self.nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                personal_position: self.personal_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::IncreaseLiquidityV2IxData;
    impl IntoProto<proto_def::IncreaseLiquidityV2IxData> for IncreaseLiquidityV2IxData {
        fn into_proto(self) -> proto_def::IncreaseLiquidityV2IxData {
            proto_def::IncreaseLiquidityV2IxData {
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                base_flag: self.base_flag,
            }
        }
    }
    use super::InitializeRewardIxAccounts;
    impl IntoProto<proto_def::InitializeRewardIxAccounts> for InitializeRewardIxAccounts {
        fn into_proto(self) -> proto_def::InitializeRewardIxAccounts {
            proto_def::InitializeRewardIxAccounts {
                reward_funder: self.reward_funder.to_string(),
                funder_token_account: self.funder_token_account.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                operation_state: self.operation_state.to_string(),
                permissionless_farm_switch: self.permissionless_farm_switch.to_string(),
                reward_token_mint: self.reward_token_mint.to_string(),
                reward_token_vault: self.reward_token_vault.to_string(),
                reward_token_program: self.reward_token_program.to_string(),
                system_program: self.system_program.to_string(),
                rent: self.rent.to_string(),
            }
        }
    }
    use super::InitializeRewardIxData;
    impl IntoProto<proto_def::InitializeRewardIxData> for InitializeRewardIxData {
        fn into_proto(self) -> proto_def::InitializeRewardIxData {
            proto_def::InitializeRewardIxData {
                open_time: self.open_time,
                end_time: self.end_time,
                emissions_per_second_x64: self.emissions_per_second_x64.to_string(),
            }
        }
    }
    use super::OpenPositionIxAccounts;
    impl IntoProto<proto_def::OpenPositionIxAccounts> for OpenPositionIxAccounts {
        fn into_proto(self) -> proto_def::OpenPositionIxAccounts {
            proto_def::OpenPositionIxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                metadata_account: self.metadata_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                metadata_program: self.metadata_program.to_string(),
            }
        }
    }
    use super::OpenPositionIxData;
    impl IntoProto<proto_def::OpenPositionIxData> for OpenPositionIxData {
        fn into_proto(self) -> proto_def::OpenPositionIxData {
            proto_def::OpenPositionIxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
            }
        }
    }
    use super::OpenPositionV2IxAccounts;
    impl IntoProto<proto_def::OpenPositionV2IxAccounts> for OpenPositionV2IxAccounts {
        fn into_proto(self) -> proto_def::OpenPositionV2IxAccounts {
            proto_def::OpenPositionV2IxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                metadata_account: self.metadata_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                metadata_program: self.metadata_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::OpenPositionV2IxData;
    impl IntoProto<proto_def::OpenPositionV2IxData> for OpenPositionV2IxData {
        fn into_proto(self) -> proto_def::OpenPositionV2IxData {
            proto_def::OpenPositionV2IxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                with_metadata: self.with_metadata,
                base_flag: self.base_flag,
            }
        }
    }
    use super::OpenPositionWithToken22NftIxAccounts;
    impl IntoProto<proto_def::OpenPositionWithToken22NftIxAccounts>
        for OpenPositionWithToken22NftIxAccounts
    {
        fn into_proto(self) -> proto_def::OpenPositionWithToken22NftIxAccounts {
            proto_def::OpenPositionWithToken22NftIxAccounts {
                payer: self.payer.to_string(),
                position_nft_owner: self.position_nft_owner.to_string(),
                position_nft_mint: self.position_nft_mint.to_string(),
                position_nft_account: self.position_nft_account.to_string(),
                pool_state: self.pool_state.to_string(),
                protocol_position: self.protocol_position.to_string(),
                tick_array_lower: self.tick_array_lower.to_string(),
                tick_array_upper: self.tick_array_upper.to_string(),
                personal_position: self.personal_position.to_string(),
                token_account0: self.token_account0.to_string(),
                token_account1: self.token_account1.to_string(),
                token_vault0: self.token_vault0.to_string(),
                token_vault1: self.token_vault1.to_string(),
                rent: self.rent.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                vault0_mint: self.vault0_mint.to_string(),
                vault1_mint: self.vault1_mint.to_string(),
            }
        }
    }
    use super::OpenPositionWithToken22NftIxData;
    impl IntoProto<proto_def::OpenPositionWithToken22NftIxData> for OpenPositionWithToken22NftIxData {
        fn into_proto(self) -> proto_def::OpenPositionWithToken22NftIxData {
            proto_def::OpenPositionWithToken22NftIxData {
                tick_lower_index: self.tick_lower_index,
                tick_upper_index: self.tick_upper_index,
                tick_array_lower_start_index: self.tick_array_lower_start_index,
                tick_array_upper_start_index: self.tick_array_upper_start_index,
                liquidity: self.liquidity.to_string(),
                amount0_max: self.amount0_max,
                amount1_max: self.amount1_max,
                with_metadata: self.with_metadata,
                base_flag: self.base_flag,
            }
        }
    }
    use super::SetRewardParamsIxAccounts;
    impl IntoProto<proto_def::SetRewardParamsIxAccounts> for SetRewardParamsIxAccounts {
        fn into_proto(self) -> proto_def::SetRewardParamsIxAccounts {
            proto_def::SetRewardParamsIxAccounts {
                authority: self.authority.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                operation_state: self.operation_state.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
            }
        }
    }
    use super::SetRewardParamsIxData;
    impl IntoProto<proto_def::SetRewardParamsIxData> for SetRewardParamsIxData {
        fn into_proto(self) -> proto_def::SetRewardParamsIxData {
            proto_def::SetRewardParamsIxData {
                reward_index: self.reward_index.into(),
                emissions_per_second_x64: self.emissions_per_second_x64.to_string(),
                open_time: self.open_time,
                end_time: self.end_time,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                payer: self.payer.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                tick_array: self.tick_array.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                amount: self.amount,
                other_amount_threshold: self.other_amount_threshold,
                sqrt_price_limit_x64: self.sqrt_price_limit_x64.to_string(),
                is_base_input: self.is_base_input,
            }
        }
    }
    use super::SwapRouterBaseInIxAccounts;
    impl IntoProto<proto_def::SwapRouterBaseInIxAccounts> for SwapRouterBaseInIxAccounts {
        fn into_proto(self) -> proto_def::SwapRouterBaseInIxAccounts {
            proto_def::SwapRouterBaseInIxAccounts {
                payer: self.payer.to_string(),
                input_token_account: self.input_token_account.to_string(),
                input_token_mint: self.input_token_mint.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
            }
        }
    }
    use super::SwapRouterBaseInIxData;
    impl IntoProto<proto_def::SwapRouterBaseInIxData> for SwapRouterBaseInIxData {
        fn into_proto(self) -> proto_def::SwapRouterBaseInIxData {
            proto_def::SwapRouterBaseInIxData {
                amount_in: self.amount_in,
                amount_out_minimum: self.amount_out_minimum,
            }
        }
    }
    use super::SwapV2IxAccounts;
    impl IntoProto<proto_def::SwapV2IxAccounts> for SwapV2IxAccounts {
        fn into_proto(self) -> proto_def::SwapV2IxAccounts {
            proto_def::SwapV2IxAccounts {
                payer: self.payer.to_string(),
                amm_config: self.amm_config.to_string(),
                pool_state: self.pool_state.to_string(),
                input_token_account: self.input_token_account.to_string(),
                output_token_account: self.output_token_account.to_string(),
                input_vault: self.input_vault.to_string(),
                output_vault: self.output_vault.to_string(),
                observation_state: self.observation_state.to_string(),
                token_program: self.token_program.to_string(),
                token_program2022: self.token_program2022.to_string(),
                memo_program: self.memo_program.to_string(),
                input_vault_mint: self.input_vault_mint.to_string(),
                output_vault_mint: self.output_vault_mint.to_string(),
            }
        }
    }
    use super::SwapV2IxData;
    impl IntoProto<proto_def::SwapV2IxData> for SwapV2IxData {
        fn into_proto(self) -> proto_def::SwapV2IxData {
            proto_def::SwapV2IxData {
                amount: self.amount,
                other_amount_threshold: self.other_amount_threshold,
                sqrt_price_limit_x64: self.sqrt_price_limit_x64.to_string(),
                is_base_input: self.is_base_input,
            }
        }
    }
    use super::TogglePermissionlessFarmSwitchIxAccounts;
    impl IntoProto<proto_def::TogglePermissionlessFarmSwitchIxAccounts>
        for TogglePermissionlessFarmSwitchIxAccounts
    {
        fn into_proto(self) -> proto_def::TogglePermissionlessFarmSwitchIxAccounts {
            proto_def::TogglePermissionlessFarmSwitchIxAccounts {
                owner: self.owner.to_string(),
                permissionless_farm_switch: self.permissionless_farm_switch.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::TogglePermissionlessFarmSwitchIxData;
    impl IntoProto<proto_def::TogglePermissionlessFarmSwitchIxData>
        for TogglePermissionlessFarmSwitchIxData
    {
        fn into_proto(self) -> proto_def::TogglePermissionlessFarmSwitchIxData {
            proto_def::TogglePermissionlessFarmSwitchIxData { is_on: self.is_on }
        }
    }
    use super::TransferRewardOwnerIxAccounts;
    impl IntoProto<proto_def::TransferRewardOwnerIxAccounts> for TransferRewardOwnerIxAccounts {
        fn into_proto(self) -> proto_def::TransferRewardOwnerIxAccounts {
            proto_def::TransferRewardOwnerIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::TransferRewardOwnerIxData;
    impl IntoProto<proto_def::TransferRewardOwnerIxData> for TransferRewardOwnerIxData {
        fn into_proto(self) -> proto_def::TransferRewardOwnerIxData {
            proto_def::TransferRewardOwnerIxData {
                new_owner: self.new_owner.to_string(),
            }
        }
    }
    use super::UpdateAmmConfigIxAccounts;
    impl IntoProto<proto_def::UpdateAmmConfigIxAccounts> for UpdateAmmConfigIxAccounts {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxAccounts {
            proto_def::UpdateAmmConfigIxAccounts {
                owner: self.owner.to_string(),
                amm_config: self.amm_config.to_string(),
            }
        }
    }
    use super::UpdateAmmConfigIxData;
    impl IntoProto<proto_def::UpdateAmmConfigIxData> for UpdateAmmConfigIxData {
        fn into_proto(self) -> proto_def::UpdateAmmConfigIxData {
            proto_def::UpdateAmmConfigIxData {
                param: self.param.into(),
                value: self.value,
            }
        }
    }
    use super::UpdateOperationAccountIxAccounts;
    impl IntoProto<proto_def::UpdateOperationAccountIxAccounts> for UpdateOperationAccountIxAccounts {
        fn into_proto(self) -> proto_def::UpdateOperationAccountIxAccounts {
            proto_def::UpdateOperationAccountIxAccounts {
                owner: self.owner.to_string(),
                operation_state: self.operation_state.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateOperationAccountIxData;
    impl IntoProto<proto_def::UpdateOperationAccountIxData> for UpdateOperationAccountIxData {
        fn into_proto(self) -> proto_def::UpdateOperationAccountIxData {
            proto_def::UpdateOperationAccountIxData {
                param: self.param.into(),
                keys: self.keys.into_iter().map(|x| x.to_string()).collect(),
            }
        }
    }
    use super::UpdatePoolStatusIxAccounts;
    impl IntoProto<proto_def::UpdatePoolStatusIxAccounts> for UpdatePoolStatusIxAccounts {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxAccounts {
            proto_def::UpdatePoolStatusIxAccounts {
                authority: self.authority.to_string(),
                pool_state: self.pool_state.to_string(),
            }
        }
    }
    use super::UpdatePoolStatusIxData;
    impl IntoProto<proto_def::UpdatePoolStatusIxData> for UpdatePoolStatusIxData {
        fn into_proto(self) -> proto_def::UpdatePoolStatusIxData {
            proto_def::UpdatePoolStatusIxData {
                status: self.status.into(),
            }
        }
    }
    use super::UpdateRewardInfosIxAccounts;
    impl IntoProto<proto_def::UpdateRewardInfosIxAccounts> for UpdateRewardInfosIxAccounts {
        fn into_proto(self) -> proto_def::UpdateRewardInfosIxAccounts {
            proto_def::UpdateRewardInfosIxAccounts {
                pool_state: self.pool_state.to_string(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for AmmV3ProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                AmmV3ProgramIx::ClosePosition(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ClosePosition(
                        proto_def::ClosePositionIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectFundFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectFundFee(
                        proto_def::CollectFundFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectProtocolFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectProtocolFee(
                        proto_def::CollectProtocolFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CollectRemainingRewards(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CollectRemainingRewards(
                        proto_def::CollectRemainingRewardsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateAmmConfig(
                        proto_def::CreateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreateOperationAccount(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateOperationAccount(
                        proto_def::CreateOperationAccountIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreatePermissionlessFarmSwitch(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(
                        proto_def::program_ixs::IxOneof::CreatePermissionlessFarmSwitch(
                            proto_def::CreatePermissionlessFarmSwitchIx {
                                accounts: Some(acc.into_proto()),
                            },
                        ),
                    ),
                },
                AmmV3ProgramIx::CreatePool(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreatePool(
                        proto_def::CreatePoolIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::CreateSupportMintAssociated(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(
                        proto_def::program_ixs::IxOneof::CreateSupportMintAssociated(
                            proto_def::CreateSupportMintAssociatedIx {
                                accounts: Some(acc.into_proto()),
                            },
                        ),
                    ),
                },
                AmmV3ProgramIx::DecreaseLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DecreaseLiquidity(
                        proto_def::DecreaseLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::DecreaseLiquidityV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::DecreaseLiquidityV2(
                        proto_def::DecreaseLiquidityV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::IncreaseLiquidity(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::IncreaseLiquidity(
                        proto_def::IncreaseLiquidityIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::IncreaseLiquidityV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::IncreaseLiquidityV2(
                        proto_def::IncreaseLiquidityV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::InitializeReward(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeReward(
                        proto_def::InitializeRewardIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPosition(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPosition(
                        proto_def::OpenPositionIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPositionV2(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPositionV2(
                        proto_def::OpenPositionV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::OpenPositionWithToken22Nft(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::OpenPositionWithToken22Nft(
                        proto_def::OpenPositionWithToken22NftIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::SetRewardParams(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SetRewardParams(
                        proto_def::SetRewardParamsIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::Swap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                AmmV3ProgramIx::SwapRouterBaseIn(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapRouterBaseIn(
                        proto_def::SwapRouterBaseInIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::SwapV2(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapV2(
                        proto_def::SwapV2Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::TogglePermissionlessFarmSwitch(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::TogglePermissionlessFarmSwitch(
                                proto_def::TogglePermissionlessFarmSwitchIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                AmmV3ProgramIx::TransferRewardOwner(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::TransferRewardOwner(
                        proto_def::TransferRewardOwnerIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateAmmConfig(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateAmmConfig(
                        proto_def::UpdateAmmConfigIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateOperationAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateOperationAccount(
                        proto_def::UpdateOperationAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdatePoolStatus(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdatePoolStatus(
                        proto_def::UpdatePoolStatusIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                AmmV3ProgramIx::UpdateRewardInfos(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateRewardInfos(
                        proto_def::UpdateRewardInfosIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
